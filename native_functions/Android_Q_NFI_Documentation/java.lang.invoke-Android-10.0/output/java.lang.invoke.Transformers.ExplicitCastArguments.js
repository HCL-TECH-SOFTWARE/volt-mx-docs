Ext.data.JsonP.java_lang_invoke_Transformers_ExplicitCastArguments({"tagname":"class","name":"java.lang.invoke.Transformers.ExplicitCastArguments","autodetected":{},"files":[{"filename":"ExplicitCastArguments.js","href":"ExplicitCastArguments.html#java-lang-invoke-Transformers-ExplicitCastArguments"}],"extends":"java.lang.invoke.Transformers.Transformer","members":[{"name":"asCollector","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-asCollector","meta":{}},{"name":"asFixedArity","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-asFixedArity","meta":{}},{"name":"asSpreader","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-asSpreader","meta":{}},{"name":"asType","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-asType","meta":{}},{"name":"asVarargsCollector","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-asVarargsCollector","meta":{}},{"name":"bindTo","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-bindTo","meta":{}},{"name":"clone","tagname":"method","owner":"java.lang.invoke.Transformers.Transformer","id":"method-clone","meta":{}},{"name":"invoke","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-invoke","meta":{}},{"name":"invokeExact","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-invokeExact","meta":{}},{"name":"invokeWithArguments","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-invokeWithArguments","meta":{}},{"name":"isVarargsCollector","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-isVarargsCollector","meta":{}},{"name":"toString","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-toString","meta":{}},{"name":"transform","tagname":"method","owner":"java.lang.invoke.Transformers.ExplicitCastArguments","id":"method-transform","meta":{}},{"name":"type","tagname":"method","owner":"java.lang.invoke.MethodHandle","id":"method-type","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.lang.invoke.Transformers.ExplicitCastArguments","classIcon":"icon-class","superclasses":["java.lang.Object","java.lang.invoke.MethodHandle","java.lang.invoke.Transformers.Transformer"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='docClass'>java.lang.invoke.MethodHandle</a><div class='subclass '><a href='#!/api/java.lang.invoke.Transformers.Transformer' rel='java.lang.invoke.Transformers.Transformer' class='docClass'>java.lang.invoke.Transformers.Transformer</a><div class='subclass '><strong>java.lang.invoke.Transformers.ExplicitCastArguments</strong></div></div></div></div><h4>Files</h4><div class='dependency'><a href='source/ExplicitCastArguments.html#java-lang-invoke-Transformers-ExplicitCastArguments' target='_blank'>ExplicitCastArguments.js</a></div></pre><div class='doc-contents'><p>Implements java.lang.invokeMethodHandles.explicitCastArguments().</p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-asCollector' class='member first-child inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-asCollector' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-asCollector' class='name expandable'>asCollector</a>( <span class='pre'>arrayType, arrayLength</span> ) : Object {java.lang.invoke.MethodHandle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Makes an array-collecting method handle, which accepts a given number of trailing\n positional arguments and collects ...</div><div class='long'><p>Makes an <em>array-collecting</em> method handle, which accepts a given number of trailing\n positional arguments and collects them into an array argument.\n The new method handle adapts, as its <i>target</i>,\n the current method handle.  The type of the adapter will be\n the same as the type of the target, except that a single trailing\n parameter (usually of type {@code arrayType}) is replaced by\n {@code arrayLength} parameters whose type is element type of {@code arrayType}.\n <p>\n If the array type differs from the final argument type on the original target,\n the original target is adapted to take the array type directly,\n as if by a call to <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asType\" rel=\"java.lang.invoke.MethodHandle-method-asType\" class=\"docClass\">asType</a>.\n <p>\n When called, the adapter replaces its trailing {@code arrayLength}\n arguments by a single new array of type {@code arrayType}, whose elements\n comprise (in order) the replaced arguments.\n Finally the target is called.\n What the target eventually returns is returned unchanged by the adapter.\n <p>\n (The array may also be a shared constant when {@code arrayLength} is zero.)\n <p>\n (<em>Note:</em> The {@code arrayType} is often identical to the last\n parameter type of the original target.\n It is an explicit argument for symmetry with {@code asSpreader}, and also\n to allow the target to use a simple {@code Object} as its last parameter type.)\n <p>\n In order to create a collecting adapter which is not restricted to a particular\n number of collected arguments, use <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a> instead.\n <p>\n Here are some examples of array-collecting method handles:\n <blockquote><pre>{@code\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nassertEquals(\"[won]\",   (String) deepToString.invokeExact(new Object[]{\"won\"}));\nMethodHandle ts1 = deepToString.asCollector(Object[].class, 1);\nassertEquals(methodType(String.class, Object.class), ts1.type());\n//assertEquals(\"[won]\", (String) ts1.invokeExact(         new Object[]{\"won\"})); //FAIL\nassertEquals(\"[[won]]\", (String) ts1.invokeExact((Object) new Object[]{\"won\"}));\n// arrayType can be a subtype of Object[]\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(methodType(String.class, String.class, String.class), ts2.type());\nassertEquals(\"[two, too]\", (String) ts2.invokeExact(\"two\", \"too\"));\nMethodHandle ts0 = deepToString.asCollector(Object[].class, 0);\nassertEquals(\"[]\", (String) ts0.invokeExact());\n// collectors can be nested, Lisp-style\nMethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);\nassertEquals(\"[A, B, [C, D]]\", ((String) ts22.invokeExact((Object)'A', (Object)\"B\", \"C\", \"D\")));\n// arrayType can be any primitive array type\nMethodHandle bytesToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, byte[].class))\n  .asCollector(byte[].class, 3);\nassertEquals(\"[1, 2, 3]\", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));\nMethodHandle longsToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, long[].class))\n  .asCollector(long[].class, 1);\nassertEquals(\"[123]\", (String) longsToString.invokeExact((long)123));\n }</pre></blockquote></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>arrayType</span> : Object {java.lang.Class}<div class='sub-desc'><p>often {@code Object[]}, the type of the array argument which will collect the arguments</p>\n</div></li><li><span class='pre'>arrayLength</span> : Number<div class='sub-desc'><p>the number of arguments to collect into a new array argument</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodHandle}</span><div class='sub-desc'><p>a new method handle which collects some trailing argument\n         into an array, before calling the original method handle</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if {@code arrayType} is a null reference</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code arrayType} is not an array type\n         or {@code arrayType} is not assignable to this method handle's trailing parameter type,\n         or {@code arrayLength} is not a legal array size,\n         or the resulting method handle's type would have\n         <a href=\"MethodHandle.html#maxarity\">too many parameters</a></p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>WrongMethodTypeException if the implied {@code asType} call fails\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asSpreader\" rel=\"java.lang.invoke.MethodHandle-method-asSpreader\" class=\"docClass\">asSpreader</a>\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a></p>\n</div></li></ul></div></div></div><div id='method-asFixedArity' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-asFixedArity' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-asFixedArity' class='name expandable'>asFixedArity</a>( <span class='pre'></span> ) : Object {java.lang.invoke.MethodHandle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Makes a fixed arity method handle which is otherwise\n equivalent to the current method handle. ...</div><div class='long'><p>Makes a <em>fixed arity</em> method handle which is otherwise\n equivalent to the current method handle.\n <p>\n If the current method handle is not of\n {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a> variable arity},\n the current method handle is returned.\n This is true even if the current method handle\n could not be a valid input to {@code asVarargsCollector}.\n <p>\n Otherwise, the resulting fixed-arity method handle has the same\n type and behavior of the current method handle,\n except that <a href=\"#!/api/java.lang.invoke.MethodHandle-method-isVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-isVarargsCollector\" class=\"docClass\">isVarargsCollector</a>\n will be false.\n The fixed-arity method handle may (or may not) be the\n a previous argument to {@code asVarargsCollector}.\n <p>\n Here is an example, of a list-making variable arity method handle:\n <blockquote><pre>{@code\nMethodHandle asListVar = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class))\n  .asVarargsCollector(Object[].class);\nMethodHandle asListFix = asListVar.asFixedArity();\nassertEquals(\"[1]\", asListVar.invoke(1).toString());\nException caught = null;\ntry { asListFix.invoke((Object)1); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof ClassCastException);\nassertEquals(\"[two, too]\", asListVar.invoke(\"two\", \"too\").toString());\ntry { asListFix.invoke(\"two\", \"too\"); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof WrongMethodTypeException);\nObject[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asListVar.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke(argv).toString());\nassertEquals(1, ((List) asListVar.invoke((Object)argv)).size());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke((Object)argv).toString());\n }</pre></blockquote></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodHandle}</span><div class='sub-desc'><p>a new method handle which accepts only a fixed number of arguments\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a>\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-isVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-isVarargsCollector\" class=\"docClass\">isVarargsCollector</a></p>\n</div></li></ul></div></div></div><div id='method-asSpreader' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-asSpreader' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-asSpreader' class='name expandable'>asSpreader</a>( <span class='pre'>arrayType, arrayLength</span> ) : Object {java.lang.invoke.MethodHandle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Makes an array-spreading method handle, which accepts a trailing array argument\n and spreads its elements as position...</div><div class='long'><p>Makes an <em>array-spreading</em> method handle, which accepts a trailing array argument\n and spreads its elements as positional arguments.\n The new method handle adapts, as its <i>target</i>,\n the current method handle.  The type of the adapter will be\n the same as the type of the target, except that the final\n {@code arrayLength} parameters of the target's type are replaced\n by a single array parameter of type {@code arrayType}.\n <p>\n If the array element type differs from any of the corresponding\n argument types on the original target,\n the original target is adapted to take the array elements directly,\n as if by a call to <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asType\" rel=\"java.lang.invoke.MethodHandle-method-asType\" class=\"docClass\">asType</a>.\n <p>\n When called, the adapter replaces a trailing array argument\n by the array's elements, each as its own argument to the target.\n (The order of the arguments is preserved.)\n They are converted pairwise by casting and/or unboxing\n to the types of the trailing parameters of the target.\n Finally the target is called.\n What the target eventually returns is returned unchanged by the adapter.\n <p>\n Before calling the target, the adapter verifies that the array\n contains exactly enough elements to provide a correct argument count\n to the target method handle.\n (The array may also be null when zero elements are required.)\n <p>\n If, when the adapter is called, the supplied array argument does\n not have the correct number of elements, the adapter will throw\n an IllegalArgumentException instead of invoking the target.\n <p>\n Here are some simple examples of array-spreading method handles:\n <blockquote><pre>{@code\nMethodHandle equals = publicLookup()\n  .findVirtual(String.class, \"equals\", methodType(boolean.class, Object.class));\nassert( (boolean) equals.invokeExact(\"me\", (Object)\"me\"));\nassert(!(boolean) equals.invokeExact(\"me\", (Object)\"thee\"));\n// spread both arguments from a 2-array:\nMethodHandle eq2 = equals.asSpreader(Object[].class, 2);\nassert( (boolean) eq2.invokeExact(new Object[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2.invokeExact(new Object[]{ \"me\", \"thee\" }));\n// try to spread from anything but a 2-array:\nfor (int n = 0; n &lt;= 10; n++) {\n  Object[] badArityArgs = (n == 2 ? null : new Object[n]);\n  try { assert((boolean) eq2.invokeExact(badArityArgs) &amp;&amp; false); }\n  catch (IllegalArgumentException ex) { } // OK\n}\n// spread both arguments from a String array:\nMethodHandle eq2s = equals.asSpreader(String[].class, 2);\nassert( (boolean) eq2s.invokeExact(new String[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2s.invokeExact(new String[]{ \"me\", \"thee\" }));\n// spread second arguments from a 1-array:\nMethodHandle eq1 = equals.asSpreader(Object[].class, 1);\nassert( (boolean) eq1.invokeExact(\"me\", new Object[]{ \"me\" }));\nassert(!(boolean) eq1.invokeExact(\"me\", new Object[]{ \"thee\" }));\n// spread no arguments from a 0-array or null:\nMethodHandle eq0 = equals.asSpreader(Object[].class, 0);\nassert( (boolean) eq0.invokeExact(\"me\", (Object)\"me\", new Object[0]));\nassert(!(boolean) eq0.invokeExact(\"me\", (Object)\"thee\", (Object[])null));\n// asSpreader and asCollector are approximate inverses:\nfor (int n = 0; n &lt;= 2; n++) {\n    for (Class&lt;?> a : new Class&lt;?>[]{Object[].class, String[].class, CharSequence[].class}) {\n        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);\n        assert( (boolean) equals2.invokeWithArguments(\"me\", \"me\"));\n        assert(!(boolean) equals2.invokeWithArguments(\"me\", \"thee\"));\n    }\n}\nMethodHandle caToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, char[].class));\nassertEquals(\"[A, B, C]\", (String) caToString.invokeExact(\"ABC\".toCharArray()));\nMethodHandle caString3 = caToString.asCollector(char[].class, 3);\nassertEquals(\"[A, B, C]\", (String) caString3.invokeExact('A', 'B', 'C'));\nMethodHandle caToString2 = caString3.asSpreader(char[].class, 2);\nassertEquals(\"[A, B, C]\", (String) caToString2.invokeExact('A', \"BC\".toCharArray()));\n }</pre></blockquote></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>arrayType</span> : Object {java.lang.Class}<div class='sub-desc'><p>usually {@code Object[]}, the type of the array argument from which to extract the spread arguments</p>\n</div></li><li><span class='pre'>arrayLength</span> : Number<div class='sub-desc'><p>the number of arguments to spread from an incoming array argument</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodHandle}</span><div class='sub-desc'><p>a new method handle which spreads its final array argument,\n         before calling the original method handle</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if {@code arrayType} is a null reference</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code arrayType} is not an array type,\n         or if target does not have at least\n         {@code arrayLength} parameter types,\n         or if {@code arrayLength} is negative,\n         or if the resulting method handle's type would have\n         <a href=\"MethodHandle.html#maxarity\">too many parameters</a></p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>WrongMethodTypeException if the implied {@code asType} call fails\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asCollector\" rel=\"java.lang.invoke.MethodHandle-method-asCollector\" class=\"docClass\">asCollector</a></p>\n</div></li></ul></div></div></div><div id='method-asType' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-asType' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-asType' class='name expandable'>asType</a>( <span class='pre'>newType</span> ) : Object {java.lang.invoke.MethodHandle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Produces an adapter method handle which adapts the type of the\n current method handle to a new type. ...</div><div class='long'><p>Produces an adapter method handle which adapts the type of the\n current method handle to a new type.\n The resulting method handle is guaranteed to report a type\n which is equal to the desired new type.\n <p>\n If the original type and new type are equal, returns {@code this}.\n <p>\n The new method handle, when invoked, will perform the following\n steps:\n <ul>\n <li>Convert the incoming argument list to match the original\n     method handle's argument list.\n <li>Invoke the original method handle on the converted argument list.\n <li>Convert any result returned by the original method handle\n     to the return type of new method handle.\n </li></li></li></ul>\n <p>\n This method provides the crucial behavioral difference between\n <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invokeExact\" rel=\"java.lang.invoke.MethodHandle-method-invokeExact\" class=\"docClass\">invokeExact</a> and plain, inexact <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invoke\" rel=\"java.lang.invoke.MethodHandle-method-invoke\" class=\"docClass\">invoke</a>.\n The two methods\n perform the same steps when the caller's type descriptor exactly m atches\n the callee's, but when the types differ, plain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invoke\" rel=\"java.lang.invoke.MethodHandle-method-invoke\" class=\"docClass\">invoke</a>\n also calls {@code asType} (or some internal equivalent) in order\n to match up the caller's and callee's types.\n <p>\n If the current method is a variable arity method handle\n argument list conversion may involve the conversion and collection\n of several arguments into an array, as\n {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a> described elsewhere}.\n In every other case, all conversions are applied <em>pairwise</em>,\n which means that each argument or return value is converted to\n exactly one argument or return value (or no return value).\n The applied conversions are defined by consulting the\n the corresponding component types of the old and new\n method handle types.\n <p>\n Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types,\n or old and new return types.  Specifically, for some valid index {@code i}, let\n <em>T0</em>{@code =newType.parameterType(i)} and <em>T1</em>{@code =this.type().parameterType(i)}.\n Or else, going the other way for return values, let\n <em>T0</em>{@code =this.type().returnType()} and <em>T1</em>{@code =newType.returnType()}.\n If the types are the same, the new method handle makes no change\n to the corresponding argument or return value (if any).\n Otherwise, one of the following conversions is applied\n if possible:\n <ul>\n <li>If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied.\n     (The types do not need to be related in any particular way.\n     This is because a dynamic value of null can convert to any reference type.)\n <li>If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation\n     conversion (JLS 5.3) is applied, if one exists.\n     (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.)\n <li>If <em>T0</em> is a primitive and <em>T1</em> a reference,\n     a Java casting conversion (JLS 5.5) is applied if one exists.\n     (Specifically, the value is boxed from <em>T0</em> to its wrapper class,\n     which is then widened as needed to <em>T1</em>.)\n <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing\n     conversion will be applied at runtime, possibly followed\n     by a Java method invocation conversion (JLS 5.3)\n     on the primitive value.  (These are the primitive widening conversions.)\n     <em>T0</em> must be a wrapper class or a supertype of one.\n     (In the case where <em>T0</em> is Object, these are the conversions\n     allowed by java.lang.reflect.Method.invoke.)\n     The unboxing conversion must have a possibility of success, which means that\n     if <em>T0</em> is not itself a wrapper class, there must exist at least one\n     wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed\n     primitive value can be widened to <em>T1</em>.\n <li>If the return type <em>T1</em> is marked as void, any returned value is discarded\n <li>If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced.\n <li>If the return type <em>T0</em> is void and <em>T1</em> a primitive,\n     a zero value is introduced.\n </li></li></li></li></li></li></li></ul>\n (<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types,\n because neither corresponds specifically to the <em>dynamic type</em> of any\n actual argument or return value.)\n <p>\n The method handle conversion cannot be made if any one of the required\n pairwise conversions cannot be made.\n <p>\n At runtime, the conversions applied to reference arguments\n or return values may require additional runtime checks which can fail.\n An unboxing operation may fail because the original reference is null,\n causing a NullPointerException.\n An unboxing operation or a reference cast may also fail on a reference\n to an object of the wrong type,\n causing a ClassCastException.\n Although an unboxing operation may accept several kinds of wrappers,\n if none are available, a {@code ClassCastException} will be thrown.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>newType</span> : Object {MethodType}<div class='sub-desc'><p>the expected type of the new method handle</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodHandle}</span><div class='sub-desc'><p>a method handle which delegates to {@code this} after performing\n           any necessary argument conversions, and arranges for any\n           necessary return value conversions</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if {@code newType} is a null reference</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>WrongMethodTypeException if the conversion cannot be made\n@see MethodHandles#explicitCastArguments</p>\n</div></li></ul></div></div></div><div id='method-asVarargsCollector' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-asVarargsCollector' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector' class='name expandable'>asVarargsCollector</a>( <span class='pre'>arrayType</span> ) : Object {java.lang.invoke.MethodHandle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Makes a variable arity adapter which is able to accept\n any number of trailing positional arguments and collect them\n...</div><div class='long'><p>Makes a <em>variable arity</em> adapter which is able to accept\n any number of trailing positional arguments and collect them\n into an array argument.\n <p>\n The type and behavior of the adapter will be the same as\n the type and behavior of the target, except that certain\n {@code invoke} and {@code asType} requests can lead to\n trailing positional arguments being collected into target's\n trailing parameter.\n Also, the last parameter type of the adapter will be\n {@code arrayType}, even if the target has a different\n last parameter type.\n <p>\n This transformation may return {@code this} if the method handle is\n already of variable arity and its trailing parameter type\n is identical to {@code arrayType}.\n <p>\n When called with <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invokeExact\" rel=\"java.lang.invoke.MethodHandle-method-invokeExact\" class=\"docClass\">invokeExact</a>, the adapter invokes\n the target with no argument changes.\n (<em>Note:</em> This behavior is different from a\n {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asCollector\" rel=\"java.lang.invoke.MethodHandle-method-asCollector\" class=\"docClass\">asCollector</a> fixed arity collector},\n since it accepts a whole array of indeterminate length,\n rather than a fixed number of arguments.)\n <p>\n When called with plain, inexact <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invoke\" rel=\"java.lang.invoke.MethodHandle-method-invoke\" class=\"docClass\">invoke</a>, if the caller\n type is the same as the adapter, the adapter invokes the target as with\n {@code invokeExact}.\n (This is the normal behavior for {@code invoke} when types match.)\n <p>\n Otherwise, if the caller and adapter arity are the same, and the\n trailing parameter type of the caller is a reference type identical to\n or assignable to the trailing parameter type of the adapter,\n the arguments and return values are converted pairwise,\n as if by <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asType\" rel=\"java.lang.invoke.MethodHandle-method-asType\" class=\"docClass\">asType</a> on a fixed arity\n method handle.\n <p>\n Otherwise, the arities differ, or the adapter's trailing parameter\n type is not assignable from the corresponding caller type.\n In this case, the adapter replaces all trailing arguments from\n the original trailing argument position onward, by\n a new array of type {@code arrayType}, whose elements\n comprise (in order) the replaced arguments.\n <p>\n The caller type must provides as least enough arguments,\n and of the correct type, to satisfy the target's requirement for\n positional arguments before the trailing array argument.\n Thus, the caller must supply, at a minimum, {@code N-1} arguments,\n where {@code N} is the arity of the target.\n Also, there must exist conversions from the incoming arguments\n to the target's arguments.\n As with other uses of plain {@code invoke}, if these basic\n requirements are not fulfilled, a {@code WrongMethodTypeException}\n may be thrown.\n <p>\n In all cases, what the target eventually returns is returned unchanged by the adapter.\n <p>\n In the final case, it is exactly as if the target method handle were\n temporarily adapted with a {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asCollector\" rel=\"java.lang.invoke.MethodHandle-method-asCollector\" class=\"docClass\">asCollector</a> fixed arity collector}\n to the arity required by the caller type.\n (As with {@code asCollector}, if the array length is zero,\n a shared constant may be used instead of a new array.\n If the implied call to {@code asCollector} would throw\n an {@code IllegalArgumentException} or {@code WrongMethodTypeException},\n the call to the variable arity adapter must throw\n {@code WrongMethodTypeException}.)\n <p>\n The behavior of <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asType\" rel=\"java.lang.invoke.MethodHandle-method-asType\" class=\"docClass\">asType</a> is also specialized for\n variable arity adapters, to maintain the invariant that\n plain, inexact {@code invoke} is always equivalent to an {@code asType}\n call to adjust the target type, followed by {@code invokeExact}.\n Therefore, a variable arity adapter responds\n to an {@code asType} request by building a fixed arity collector,\n if and only if the adapter and requested type differ either\n in arity or trailing argument type.\n The resulting fixed arity collector has its type further adjusted\n (if necessary) to the requested type by pairwise conversion,\n as if by another application of {@code asType}.\n <p>\n When a method handle is obtained by executing an {@code ldc} instruction\n of a {@code CONSTANT_MethodHandle} constant, and the target method is marked\n as a variable arity method (with the modifier bit {@code 0x0080}),\n the method handle will accept multiple arities, as if the method handle\n constant were created by means of a call to {@code asVarargsCollector}.\n <p>\n In order to create a collecting adapter which collects a predetermined\n number of arguments, and whose type reflects this predetermined number,\n use <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asCollector\" rel=\"java.lang.invoke.MethodHandle-method-asCollector\" class=\"docClass\">asCollector</a> instead.\n <p>\n No method handle transformations produce new method handles with\n variable arity, unless they are documented as doing so.\n Therefore, besides {@code asVarargsCollector},\n all methods in {@code MethodHandle} and {@code MethodHandles}\n will return a method handle with fixed arity,\n except in the cases where they are specified to return their original\n operand (e.g., {@code asType} of the method handle's own type).\n <p>\n Calling {@code asVarargsCollector} on a method handle which is already\n of variable arity will produce a method handle with the same type and behavior.\n It may (or may not) return the original variable arity method handle.\n <p>\n Here is an example, of a list-making variable arity method handle:\n <blockquote><pre>{@code\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nMethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);\nassertEquals(\"[won]\",   (String) ts1.invokeExact(    new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(         new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(                      \"won\" ));\nassertEquals(\"[[won]]\", (String) ts1.invoke((Object) new Object[]{\"won\"}));\n// findStatic of Arrays.asList(...) produces a variable arity method handle:\nMethodHandle asList = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class));\nassertEquals(methodType(List.class, Object[].class), asList.type());\nassert(asList.isVarargsCollector());\nassertEquals(\"[]\", asList.invoke().toString());\nassertEquals(\"[1]\", asList.invoke(1).toString());\nassertEquals(\"[two, too]\", asList.invoke(\"two\", \"too\").toString());\nString[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asList.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asList.invoke((Object[])argv).toString());\nList ls = (List) asList.invoke((Object)argv);\nassertEquals(1, ls.size());\nassertEquals(\"[three, thee, tee]\", Arrays.toString((Object[])ls.get(0)));\n }</pre></blockquote>\n <p style=\"font-size:smaller;\">\n <em>Discussion:</em>\n These rules are designed as a dynamically-typed variation\n of the Java rules for variable arity methods.\n In both cases, callers to a variable arity method or method handle\n can either pass zero or more positional arguments, or else pass\n pre-collected arrays of any length.  Users should be aware of the\n special role of the final argument, and of the effect of a\n type match on that final argument, which determines whether\n or not a single trailing argument is interpreted as a whole\n array or a single element of an array to be collected.\n Note that the dynamic type of the trailing argument has no\n effect on this decision, only a comparison between the symbolic\n type descriptor of the call site and the type descriptor of the method handle.)</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>arrayType</span> : Object {java.lang.Class}<div class='sub-desc'><p>often {@code Object[]}, the type of the array argument which will collect the arguments</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodHandle}</span><div class='sub-desc'><p>a new method handle which can collect any number of trailing arguments\n         into an array, before calling the original method handle</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if {@code arrayType} is a null reference</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code arrayType} is not an array type\n         or {@code arrayType} is not assignable to this method handle's trailing parameter type\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asCollector\" rel=\"java.lang.invoke.MethodHandle-method-asCollector\" class=\"docClass\">asCollector</a>\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-isVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-isVarargsCollector\" class=\"docClass\">isVarargsCollector</a>\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asFixedArity\" rel=\"java.lang.invoke.MethodHandle-method-asFixedArity\" class=\"docClass\">asFixedArity</a></p>\n</div></li></ul></div></div></div><div id='method-bindTo' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-bindTo' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-bindTo' class='name expandable'>bindTo</a>( <span class='pre'>x</span> ) : Object {java.lang.invoke.MethodHandle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Binds a value {@code x} to the first argument of a method handle, without invoking it. ...</div><div class='long'><p>Binds a value {@code x} to the first argument of a method handle, without invoking it.\n The new method handle adapts, as its <i>target</i>,\n the current method handle by binding it to the given argument.\n The type of the bound handle will be\n the same as the type of the target, except that a single leading\n reference parameter will be omitted.\n <p>\n When called, the bound handle inserts the given value {@code x}\n as a new leading argument to the target.  The other arguments are\n also passed unchanged.\n What the target eventually returns is returned unchanged by the bound handle.\n <p>\n The reference {@code x} must be convertible to the first parameter\n type of the target.\n <p>\n (<em>Note:</em>  Because method handles are immutable, the target method handle\n retains its original type and behavior.)</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>x</span> : Object {Object}<div class='sub-desc'><p>the value to bind to the first argument of the target</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodHandle}</span><div class='sub-desc'><p>a new method handle which prepends the given value to the incoming\n         argument list, before calling the original method handle</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the target does not have a\n         leading parameter type that is a reference type</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClassCastException if {@code x} cannot be converted\n         to the leading parameter type of the target\n@see MethodHandles#insertArguments</p>\n</div></li></ul></div></div></div><div id='method-clone' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.Transformers.Transformer' rel='java.lang.invoke.Transformers.Transformer' class='defined-in docClass'>java.lang.invoke.Transformers.Transformer</a><br/><a href='source/Transformer.html#java-lang-invoke-Transformers-Transformer-method-clone' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.Transformers.Transformer-method-clone' class='name expandable'>clone</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div><div id='method-invoke' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-invoke' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-invoke' class='name expandable'>invoke</a>( <span class='pre'>args</span> ) : Object {java.lang.Object}<span class=\"signature\"></span></div><div class='description'><div class='short'>Invokes the method handle, allowing any caller type descriptor,\n and optionally performing conversions on arguments a...</div><div class='long'><p>Invokes the method handle, allowing any caller type descriptor,\n and optionally performing conversions on arguments and return values.\n <p>\n If the call site's symbolic type descriptor exactly matches this method handle's <a href=\"#!/api/java.lang.invoke.MethodHandle-method-type\" rel=\"java.lang.invoke.MethodHandle-method-type\" class=\"docClass\">type</a>,\n the call proceeds as if by <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invokeExact\" rel=\"java.lang.invoke.MethodHandle-method-invokeExact\" class=\"docClass\">invokeExact</a>.\n <p>\n Otherwise, the call proceeds as if this method handle were first\n adjusted by calling <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asType\" rel=\"java.lang.invoke.MethodHandle-method-asType\" class=\"docClass\">asType</a> to adjust this method handle\n to the required type, and then the call proceeds as if by\n <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invokeExact\" rel=\"java.lang.invoke.MethodHandle-method-invokeExact\" class=\"docClass\">invokeExact</a> on the adjusted method handle.\n <p>\n There is no guarantee that the {@code asType} call is actually made.\n If the JVM can predict the results of making the call, it may perform\n adaptations directly on the caller's arguments,\n and call the target method handle according to its own exact type.\n <p>\n The resolved type descriptor at the call site of {@code invoke} must\n be a valid argument to the receivers {@code asType} method.\n In particular, the caller must specify the same argument arity\n as the callee's type,\n if the callee is not a {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a> variable arity collector}.\n <p>\n When this method is observed via the Core Reflection API,\n it will appear as a single native method, taking an object array and returning an object.\n If this native method is invoked directly via\n java.lang.reflect.Method.invoke, via JNI,\n or indirectly via <a href=\"#!/api/java.lang.invoke.MethodHandles.Lookup-method-unreflect\" rel=\"java.lang.invoke.MethodHandles.Lookup-method-unreflect\" class=\"docClass\">Lookup.unreflect</a>,\n it will throw an {@code UnsupportedOperationException}.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>args</span> : Object {java.lang.Object[]}<div class='sub-desc'><p>the signature-polymorphic parameter list, statically represented using varargs</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.Object}</span><div class='sub-desc'><p>the signature-polymorphic result, statically represented using {@code Object}</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>WrongMethodTypeException if the target's type cannot be adjusted to the caller's symbolic type descriptor</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClassCastException if the target's type can be adjusted to the caller, but a reference cast fails</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>Throwable anything thrown by the underlying method propagates unchanged through the method handle call</p>\n</div></li></ul></div></div></div><div id='method-invokeExact' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-invokeExact' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-invokeExact' class='name expandable'>invokeExact</a>( <span class='pre'>args</span> ) : Object {java.lang.Object}<span class=\"signature\"></span></div><div class='description'><div class='short'>Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match. ...</div><div class='long'><p>Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.\n The symbolic type descriptor at the call site of {@code invokeExact} must\n exactly match this method handle's <a href=\"#!/api/java.lang.invoke.MethodHandle-method-type\" rel=\"java.lang.invoke.MethodHandle-method-type\" class=\"docClass\">type</a>.\n No conversions are allowed on arguments or return values.\n <p>\n When this method is observed via the Core Reflection API,\n it will appear as a single native method, taking an object array and returning an object.\n If this native method is invoked directly via\n java.lang.reflect.Method.invoke, via JNI,\n or indirectly via <a href=\"#!/api/java.lang.invoke.MethodHandles.Lookup-method-unreflect\" rel=\"java.lang.invoke.MethodHandles.Lookup-method-unreflect\" class=\"docClass\">Lookup.unreflect</a>,\n it will throw an {@code UnsupportedOperationException}.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>args</span> : Object {java.lang.Object[]}<div class='sub-desc'><p>the signature-polymorphic parameter list, statically represented using varargs</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.Object}</span><div class='sub-desc'><p>the signature-polymorphic result, statically represented using {@code Object}</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>WrongMethodTypeException if the target's type is not identical with the caller's symbolic type descriptor</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>Throwable anything thrown by the underlying method propagates unchanged through the method handle call</p>\n</div></li></ul></div></div></div><div id='method-invokeWithArguments' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-invokeWithArguments' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-invokeWithArguments' class='name expandable'>invokeWithArguments</a>( <span class='pre'>arguments</span> ) : Object {java.lang.Object}<span class=\"signature\"></span></div><div class='description'><div class='short'>Performs a variable arity invocation, passing the arguments in the given array\n to the method handle, as if via an in...</div><div class='long'><p>Performs a variable arity invocation, passing the arguments in the given array\n to the method handle, as if via an inexact <a href=\"#!/api/java.lang.invoke.MethodHandle-method-invoke\" rel=\"java.lang.invoke.MethodHandle-method-invoke\" class=\"docClass\">invoke</a> from a call site\n which mentions only the type {@code Object}, and whose arity is the length\n of the argument array.\n <p>\n This method is also equivalent to the following code:\n <blockquote><pre>{@code\n   invokeWithArguments(arguments.toArray()\n }</pre></blockquote></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>arguments</span> : Object {java.util.List}<div class='sub-desc'><p>the arguments to pass to the target</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.Object}</span><div class='sub-desc'><p>the result returned by the target</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if {@code arguments} is a null reference</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClassCastException if an argument cannot be converted by reference casting</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>WrongMethodTypeException if the target's type cannot be adjusted to take the given number of {@code Object} arguments</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>Throwable anything thrown by the target method invocation</p>\n</div></li></ul></div></div></div><div id='method-isVarargsCollector' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-isVarargsCollector' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-isVarargsCollector' class='name expandable'>isVarargsCollector</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Determines if this method handle\n supports {@linkplain asVarargsCollector variable arity} calls. ...</div><div class='long'><p>Determines if this method handle\n supports {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a> variable arity} calls.\n Such method handles arise from the following sources:\n <ul>\n <li>a call to {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a> asVarargsCollector}\n <li>a call to a {@linkplain <a href=\"#!/api/java.lang.invoke.MethodHandles.Lookup\" rel=\"java.lang.invoke.MethodHandles.Lookup\" class=\"docClass\">java.lang.invoke.MethodHandles.Lookup</a> lookup method}\n     which resolves to a variable arity Java method or constructor\n <li>an {@code ldc} instruction of a {@code CONSTANT_MethodHandle}\n     which resolves to a variable arity Java method or constructor\n </li></li></li></ul></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if this method handle accepts more than one arity of plain, inexact {@code invoke} calls\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asVarargsCollector\" rel=\"java.lang.invoke.MethodHandle-method-asVarargsCollector\" class=\"docClass\">asVarargsCollector</a>\n@see <a href=\"#!/api/java.lang.invoke.MethodHandle-method-asFixedArity\" rel=\"java.lang.invoke.MethodHandle-method-asFixedArity\" class=\"docClass\">asFixedArity</a></p>\n</div></li></ul></div></div></div><div id='method-toString' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-toString' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-toString' class='name expandable'>toString</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a string representation of the method handle,\n starting with the string {@code \"MethodHandle\"} and\n ending wi...</div><div class='long'><p>Returns a string representation of the method handle,\n starting with the string {@code \"MethodHandle\"} and\n ending with the string representation of the method handle's type.\n In other words, this method returns a string equal to the value of:\n <blockquote><pre>{@code\n \"MethodHandle\" + type().toString()\n }</pre></blockquote>\n <p>\n (<em>Note:</em>  Future releases of this API may add further information\n to the string representation.\n Therefore, the present syntax should not be parsed by applications.)</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>a string representation of the method handle</p>\n</div></li></ul></div></div></div><div id='method-transform' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.lang.invoke.Transformers.ExplicitCastArguments'>java.lang.invoke.Transformers.ExplicitCastArguments</span><br/><a href='source/ExplicitCastArguments.html#java-lang-invoke-Transformers-ExplicitCastArguments-method-transform' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.Transformers.ExplicitCastArguments-method-transform' class='name expandable'>transform</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div><div id='method-type' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/java.lang.invoke.MethodHandle' rel='java.lang.invoke.MethodHandle' class='defined-in docClass'>java.lang.invoke.MethodHandle</a><br/><a href='source/MethodHandle.html#java-lang-invoke-MethodHandle-method-type' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.lang.invoke.MethodHandle-method-type' class='name expandable'>type</a>( <span class='pre'></span> ) : Object {java.lang.invoke.MethodType}<span class=\"signature\"></span></div><div class='description'><div class='short'>Reports the type of this method handle. ...</div><div class='long'><p>Reports the type of this method handle.\n Every invocation of this method handle via {@code invokeExact} must exactly match this type.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.invoke.MethodType}</span><div class='sub-desc'><p>the method handle type</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});