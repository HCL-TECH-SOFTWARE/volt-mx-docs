<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-lang-invoke-MethodHandles'>/**@class java.lang.invoke.MethodHandles
</span>@extends java.lang.Object

 This class consists exclusively of static methods that operate on or return
 method handles. They fall into several categories:
 &lt;ul&gt;
 &lt;li&gt;Lookup methods which help create method handles for methods and fields.
 &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.
 &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.
 &lt;/ul&gt;
 &lt;p&gt;
 @author John Rose, JSR 292 EG
 @since 1.7
*/
var MethodHandles = {

<span id='java-lang-invoke-MethodHandles-method-lookup'>/**Returns a {@link java.lang.invoke.MethodHandles.Lookup lookup object} with
</span> full capabilities to emulate all supported bytecode behaviors of the caller.
 These capabilities include &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt; to the caller.
 Factory methods on the lookup object can create
 &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
 for any member that the caller has access to via bytecodes,
 including protected and private fields and methods.
 This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
 Do not store it in place where untrusted code can access it.
 &lt;p&gt;
 This method is caller sensitive, which means that it may return different
 values to different callers.
 &lt;p&gt;
 For any given caller class {@code C}, the lookup object returned by this call
 has equivalent capabilities to any lookup object
 supplied by the JVM to the bootstrap method of an
 &lt;a href=&quot;package-summary.html#indyinsn&quot;&gt;invokedynamic instruction&lt;/a&gt;
 executing in the same caller class {@code C}.
@return {Object {java.lang.invoke.MethodHandles.Lookup}} a lookup object for the caller of this method, with private access
*/
lookup : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-publicLookup'>/**Returns a {@link java.lang.invoke.MethodHandles.Lookup lookup object} which is trusted minimally.
</span> It can only be used to create method handles to
 publicly accessible fields and methods.
 &lt;p&gt;
 As a matter of pure convention, the {@linkplain java.lang.invoke.MethodHandles.Lookup#lookupClass lookup class}
 of this lookup object will be {@link java.lang.Object}.

 &lt;p style=&quot;font-size:smaller;&quot;&gt;
 &lt;em&gt;Discussion:&lt;/em&gt;
 The lookup class can be changed to any other class {@code C} using an expression of the form
 {@link java.lang.invoke.MethodHandles.Lookup#in publicjava.lang.invoke.MethodHandles.Lookup().in(C.class)}.
 Since all classes have equal access to public names,
 such a change would confer no new access rights.
 A public lookup object is always subject to
 &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
 Also, it cannot access
 &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
@return {Object {java.lang.invoke.MethodHandles.Lookup}} a lookup object which is trusted minimally
*/
publicLookup : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-reflectAs'>/**Performs an unchecked &quot;crack&quot; of a
</span> &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 The result is as if the user had obtained a lookup object capable enough
 to crack the target method handle, called
 {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 on the target to obtain its symbolic reference, and then called
 {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 to resolve the symbolic reference to a member.
 &lt;p&gt;
 If there is a security manager, its {@code checkPermission} method
 is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
@param {Object {java.lang.Class}} target a direct method handle to crack into symbolic reference components
@param {Object {MethodHandle}} expected a class object representing the desired result type {@code T}
@param expected a class object representing the desired result type {@code T}
@return {Object {java.lang.reflect.Member}} a reference to the method, constructor, or field object
@exception SecurityException if the caller is not privileged to call {@code setAccessible}
@exception NullPointerException if either argument is {@code null}
@exception IllegalArgumentException if the target is not a direct method handle
@exception ClassCastException if the member is not of the expected type
@since 1.8
*/
reflectAs : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**Produces a method handle giving read access to elements of an array.
</span> The type of the method handle will have a return type of the array's
 element type.  Its first argument will be the array type,
 and the second will be {@code int}.
@param {Object {java.lang.Class}} arrayClass an array type
@return {Object {java.lang.invoke.MethodHandle}} a method handle which can load values from the given array type
@throws NullPointerException if the argument is null
@throws IllegalArgumentException if arrayClass is not an array type
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementGetter'>/**
</span>@hide 
*/
arrayElementGetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**Produces a method handle giving write access to elements of an array.
</span> The type of the method handle will have a void return type.
 Its last argument will be the array's element type.
 The first and second arguments will be the array type and int.
@param {Object {java.lang.Class}} arrayClass the class of an array
@return {Object {java.lang.invoke.MethodHandle}} a method handle which can store values into the array type
@throws NullPointerException if the argument is null
@throws IllegalArgumentException if arrayClass is not an array type
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementSetter'>/**
</span>@hide 
*/
arrayElementSetter : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-arrayElementVarHandle'>/**Produces a VarHandle giving access to elements of an array of type
</span> {@code arrayClass}.  The VarHandle's variable type is the component type
 of {@code arrayClass} and the list of coordinate types is
 {@code (arrayClass, int)}, where the {@code int} coordinate type
 corresponds to an argument that is an index into an array.
 &lt;p&gt;
 Certain access modes of the returned VarHandle are unsupported under
 the following conditions:
 &lt;ul&gt;
 &lt;li&gt;if the component type is anything other than {@code byte},
     {@code short}, {@code char}, {@code int}, {@code long},
     {@code float}, or {@code double} then numeric atomic update access
     modes are unsupported.
 &lt;li&gt;if the field type is anything other than {@code boolean},
     {@code byte}, {@code short}, {@code char}, {@code int} or
     {@code long} then bitwise atomic update access modes are
     unsupported.
 &lt;/ul&gt;
 &lt;p&gt;
 If the component type is {@code float} or {@code double} then numeric
 and atomic update access modes compare values using their bitwise
 representation (see {@link Float#floatToRawIntBits} and
 {@link Double#doubleToRawLongBits}, respectively).
@param {Object {java.lang.Class}} arrayClass the class of an array, of type {@code T[]}
@param arrayClass the class of an array, of type {@code T[]}
@return {Object {java.lang.invoke.VarHandle}} a VarHandle giving access to elements of an array
@throws NullPointerException if the arrayClass is null
@throws IllegalArgumentException if arrayClass is not an array type
@since 9
@hide 
*/
arrayElementVarHandle : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-byteArrayViewVarHandle'>/**Produces a VarHandle giving access to elements of a {@code byte[]} array
</span> viewed as if it were a different primitive array type, such as
 {@code int[]} or {@code long[]}.
 The VarHandle's variable type is the component type of
 {@code viewArrayClass} and the list of coordinate types is
 {@code (byte[], int)}, where the {@code int} coordinate type
 corresponds to an argument that is an index into a {@code byte[]} array.
 The returned VarHandle accesses bytes at an index in a {@code byte[]}
 array, composing bytes to or from a value of the component type of
 {@code viewArrayClass} according to the given endianness.
 &lt;p&gt;
 The supported component types (variables types) are {@code short},
 {@code char}, {@code int}, {@code long}, {@code float} and
 {@code double}.
 &lt;p&gt;
 Access of bytes at a given index will result in an
 {@code IndexOutOfBoundsException} if the index is less than {@code 0}
 or greater than the {@code byte[]} array length minus the size (in bytes)
 of {@code T}.
 &lt;p&gt;
 Access of bytes at an index may be aligned or misaligned for {@code T},
 with respect to the underlying memory address, {@code A} say, associated
 with the array and index.
 If access is misaligned then access for anything other than the
 {@code get} and {@code set} access modes will result in an
 {@code IllegalStateException}.  In such cases atomic access is only
 guaranteed with respect to the largest power of two that divides the GCD
 of {@code A} and the size (in bytes) of {@code T}.
 If access is aligned then following access modes are supported and are
 guaranteed to support atomic access:
 &lt;ul&gt;
 &lt;li&gt;read write access modes for all {@code T}, with the exception of
     access modes {@code get} and {@code set} for {@code long} and
     {@code double} on 32-bit platforms.
 &lt;li&gt;atomic update access modes for {@code int}, {@code long},
     {@code float} or {@code double}.
     (Future major platform releases of the JDK may support additional
     types for certain currently unsupported access modes.)
 &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
     (Future major platform releases of the JDK may support additional
     numeric types for certain currently unsupported access modes.)
 &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
     (Future major platform releases of the JDK may support additional
     numeric types for certain currently unsupported access modes.)
 &lt;/ul&gt;
 &lt;p&gt;
 Misaligned access, and therefore atomicity guarantees, may be determined
 for {@code byte[]} arrays without operating on a specific array.  Given
 an {@code index}, {@code T} and it's corresponding boxed type,
 {@code T_BOX}, misalignment may be determined as follows:
 &lt;pre&gt;{@code
 int sizeOfT = T_BOX.BYTES;  // size in bytes of T
 int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).
     alignmentOffset(0, sizeOfT);
 int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;
 boolean isMisaligned = misalignedAtIndex != 0;
 }&lt;/pre&gt;
 &lt;p&gt;
 If the variable type is {@code float} or {@code double} then atomic
 update access modes compare values using their bitwise representation
 (see {@link Float#floatToRawIntBits} and
 {@link Double#doubleToRawLongBits}, respectively).
@param {Object {java.lang.Class}} viewArrayClass the view array class, with a component type of
 type {@code T}
@param {Object {ByteOrder}} byteOrder the endianness of the view array elements, as
 stored in the underlying {@code byte} array
@return {Object {java.lang.invoke.VarHandle}} a VarHandle giving access to elements of a {@code byte[]} array
 viewed as if elements corresponding to the components type of the view
 array class
@throws NullPointerException if viewArrayClass or byteOrder is null
@throws IllegalArgumentException if viewArrayClass is not an array type
@throws UnsupportedOperationException if the component type of
 viewArrayClass is not supported as a variable type
@since 9
@hide 
*/
byteArrayViewVarHandle : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-byteBufferViewVarHandle'>/**Produces a VarHandle giving access to elements of a {@code ByteBuffer}
</span> viewed as if it were an array of elements of a different primitive
 component type to that of {@code byte}, such as {@code int[]} or
 {@code long[]}.
 The VarHandle's variable type is the component type of
 {@code viewArrayClass} and the list of coordinate types is
 {@code (ByteBuffer, int)}, where the {@code int} coordinate type
 corresponds to an argument that is an index into a {@code byte[]} array.
 The returned VarHandle accesses bytes at an index in a
 {@code ByteBuffer}, composing bytes to or from a value of the component
 type of {@code viewArrayClass} according to the given endianness.
 &lt;p&gt;
 The supported component types (variables types) are {@code short},
 {@code char}, {@code int}, {@code long}, {@code float} and
 {@code double}.
 &lt;p&gt;
 Access will result in a {@code ReadOnlyBufferException} for anything
 other than the read access modes if the {@code ByteBuffer} is read-only.
 &lt;p&gt;
 Access of bytes at a given index will result in an
 {@code IndexOutOfBoundsException} if the index is less than {@code 0}
 or greater than the {@code ByteBuffer} limit minus the size (in bytes) of
 {@code T}.
 &lt;p&gt;
 Access of bytes at an index may be aligned or misaligned for {@code T},
 with respect to the underlying memory address, {@code A} say, associated
 with the {@code ByteBuffer} and index.
 If access is misaligned then access for anything other than the
 {@code get} and {@code set} access modes will result in an
 {@code IllegalStateException}.  In such cases atomic access is only
 guaranteed with respect to the largest power of two that divides the GCD
 of {@code A} and the size (in bytes) of {@code T}.
 If access is aligned then following access modes are supported and are
 guaranteed to support atomic access:
 &lt;ul&gt;
 &lt;li&gt;read write access modes for all {@code T}, with the exception of
     access modes {@code get} and {@code set} for {@code long} and
     {@code double} on 32-bit platforms.
 &lt;li&gt;atomic update access modes for {@code int}, {@code long},
     {@code float} or {@code double}.
     (Future major platform releases of the JDK may support additional
     types for certain currently unsupported access modes.)
 &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
     (Future major platform releases of the JDK may support additional
     numeric types for certain currently unsupported access modes.)
 &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
     (Future major platform releases of the JDK may support additional
     numeric types for certain currently unsupported access modes.)
 &lt;/ul&gt;
 &lt;p&gt;
 Misaligned access, and therefore atomicity guarantees, may be determined
 for a {@code ByteBuffer}, {@code bb} (direct or otherwise), an
 {@code index}, {@code T} and it's corresponding boxed type,
 {@code T_BOX}, as follows:
 &lt;pre&gt;{@code
 int sizeOfT = T_BOX.BYTES;  // size in bytes of T
 ByteBuffer bb = ...
 int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);
 boolean isMisaligned = misalignedAtIndex != 0;
 }&lt;/pre&gt;
 &lt;p&gt;
 If the variable type is {@code float} or {@code double} then atomic
 update access modes compare values using their bitwise representation
 (see {@link Float#floatToRawIntBits} and
 {@link Double#doubleToRawLongBits}, respectively).
@param {Object {java.lang.Class}} viewArrayClass the view array class, with a component type of
 type {@code T}
@param {Object {ByteOrder}} byteOrder the endianness of the view array elements, as
 stored in the underlying {@code ByteBuffer} (Note this overrides the
 endianness of a {@code ByteBuffer})
@return {Object {java.lang.invoke.VarHandle}} a VarHandle giving access to elements of a {@code ByteBuffer}
 viewed as if elements corresponding to the components type of the view
 array class
@throws NullPointerException if viewArrayClass or byteOrder is null
@throws IllegalArgumentException if viewArrayClass is not an array type
@throws UnsupportedOperationException if the component type of
 viewArrayClass is not supported as a variable type
@since 9
@hide 
*/
byteBufferViewVarHandle : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-spreadInvoker'>/**Produces a method handle which will invoke any method handle of the
</span> given {@code type}, with a given number of trailing arguments replaced by
 a single trailing {@code Object[]} array.
 The resulting invoker will be a method handle with the following
 arguments:
 &lt;ul&gt;
 &lt;li&gt;a single {@code MethodHandle} target
 &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
 &lt;li&gt;an {@code Object[]} array containing trailing arguments
 &lt;/ul&gt;
 &lt;p&gt;
 The invoker will invoke its target like a call to {@link java.lang.invoke.MethodHandle#invoke invoke} with
 the indicated {@code type}.
 That is, if the target is exactly of the given {@code type}, it will behave
 like {@code invokeExact}; otherwise it behave as if {@link java.lang.invoke.MethodHandle#asType asType}
 is used to convert the target to the required {@code type}.
 &lt;p&gt;
 The type of the returned invoker will not be the given {@code type}, but rather
 will have all parameters except the first {@code leadingArgCount}
 replaced by a single array of type {@code Object[]}, which will be
 the final parameter.
 &lt;p&gt;
 Before invoking its target, the invoker will spread the final array, apply
 reference casts as necessary, and unbox and widen primitive arguments.
 If, when the invoker is called, the supplied array argument does
 not have the correct number of elements, the invoker will throw
 an {@link IllegalArgumentException} instead of invoking the target.
 &lt;p&gt;
 This method is equivalent to the following code (though it may be more efficient):
 &lt;blockquote&gt;&lt;pre&gt;{@code
MethodHandle invoker = MethodHandles.invoker(type);
int spreadArgCount = type.parameterCount() - leadingArgCount;
invoker = invoker.asSpreader(Object[].class, spreadArgCount);
return invoker;
 }&lt;/pre&gt;&lt;/blockquote&gt;
 This method throws no reflective or security exceptions.
@param {Object {MethodType}} type the desired target type
@param {Number} leadingArgCount number of fixed arguments, to be passed unchanged to the target
@return {Object {java.lang.invoke.MethodHandle}} a method handle suitable for invoking any method handle of the given type
@throws NullPointerException if {@code type} is null
@throws IllegalArgumentException if {@code leadingArgCount} is not in
                  the range from 0 to {@code type.parameterCount()} inclusive,
                  or if the resulting method handle's type would have
          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
*/
spreadInvoker : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-exactInvoker'>/**Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</span> invoke any method handle of the given type, as if by {@link java.lang.invoke.MethodHandle#invokeExact invokeExact}.
 The resulting invoker will have a type which is
 exactly equal to the desired type, except that it will accept
 an additional leading argument of type {@code MethodHandle}.
 &lt;p&gt;
 This method is equivalent to the following code (though it may be more efficient):
 {@code publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)}

 &lt;p style=&quot;font-size:smaller;&quot;&gt;
 &lt;em&gt;Discussion:&lt;/em&gt;
 Invoker method handles can be useful when working with variable method handles
 of unknown types.
 For example, to emulate an {@code invokeExact} call to a variable method
 handle {@code M}, extract its type {@code T},
 look up the invoker method {@code X} for {@code T},
 and call the invoker method, as {@code X.invoke(T, A...)}.
 (It would not work to call {@code X.invokeExact}, since the type {@code T}
 is unknown.)
 If spreading, collecting, or other argument transformations are required,
 they can be applied once to the invoker {@code X} and reused on many {@code M}
 method handle values, as long as they are compatible with the type of {@code X}.
 &lt;p style=&quot;font-size:smaller;&quot;&gt;
 &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
 An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
 on the declared {@code invokeExact} or {@code invoke} method will raise an
 {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
 &lt;p&gt;
 This method throws no reflective or security exceptions.
@param {Object {MethodType}} type the desired target type
@return {Object {java.lang.invoke.MethodHandle}} a method handle suitable for invoking any method handle of the given type
@throws IllegalArgumentException if the resulting method handle's type would have
          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
*/
exactInvoker : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-invoker'>/**Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</span> invoke any method handle compatible with the given type, as if by {@link java.lang.invoke.MethodHandle#invoke invoke}.
 The resulting invoker will have a type which is
 exactly equal to the desired type, except that it will accept
 an additional leading argument of type {@code MethodHandle}.
 &lt;p&gt;
 Before invoking its target, if the target differs from the expected type,
 the invoker will apply reference casts as
 necessary and box, unbox, or widen primitive values, as if by {@link java.lang.invoke.MethodHandle#asType asType}.
 Similarly, the return value will be converted as necessary.
 If the target is a {@linkplain java.lang.invoke.MethodHandle#asVarargsCollector variable arity method handle},
 the required arity conversion will be made, again as if by {@link java.lang.invoke.MethodHandle#asType asType}.
 &lt;p&gt;
 This method is equivalent to the following code (though it may be more efficient):
 {@code publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)}
 &lt;p style=&quot;font-size:smaller;&quot;&gt;
 &lt;em&gt;Discussion:&lt;/em&gt;
 A {@linkplain java.lang.invoke.MethodType#genericjava.lang.invoke.MethodType general method type} is one which
 mentions only {@code Object} arguments and return values.
 An invoker for such a type is capable of calling any method handle
 of the same arity as the general type.
 &lt;p style=&quot;font-size:smaller;&quot;&gt;
 &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
 An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
 on the declared {@code invokeExact} or {@code invoke} method will raise an
 {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
 &lt;p&gt;
 This method throws no reflective or security exceptions.
@param {Object {MethodType}} type the desired target type
@return {Object {java.lang.invoke.MethodHandle}} a method handle suitable for invoking any method handle convertible to the given type
@throws IllegalArgumentException if the resulting method handle's type would have
          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
*/
invoker : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-varHandleExactInvoker'>/**Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</span> invoke a signature-polymorphic access mode method on any VarHandle whose
 associated access mode type is compatible with the given type.
 The resulting invoker will have a type which is exactly equal to the
 desired given type, except that it will accept an additional leading
 argument of type {@code VarHandle}.
@param {Object {VarHandle.AccessMode}} accessMode the VarHandle access mode
@param {Object {MethodType}} type the desired target type
@return {Object {java.lang.invoke.MethodHandle}} a method handle suitable for invoking an access mode method of
         any VarHandle whose access mode type is of the given type.
@since 9
@hide 
*/
varHandleExactInvoker : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-varHandleInvoker'>/**Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</span> invoke a signature-polymorphic access mode method on any VarHandle whose
 associated access mode type is compatible with the given type.
 The resulting invoker will have a type which is exactly equal to the
 desired given type, except that it will accept an additional leading
 argument of type {@code VarHandle}.
 &lt;p&gt;
 Before invoking its target, if the access mode type differs from the
 desired given type, the invoker will apply reference casts as necessary
 and box, unbox, or widen primitive values, as if by
 {@link java.lang.invoke.MethodHandle#asType asType}.  Similarly, the return value will be
 converted as necessary.
 &lt;p&gt;
 This method is equivalent to the following code (though it may be more
 efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
@param {Object {VarHandle.AccessMode}} accessMode the VarHandle access mode
@param {Object {MethodType}} type the desired target type
@return {Object {java.lang.invoke.MethodHandle}} a method handle suitable for invoking an access mode method of
         any VarHandle whose access mode type is convertible to the given
         type.
@since 9
@hide 
*/
varHandleInvoker : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-explicitCastArguments'>/**Produces a method handle which adapts the type of the
</span> given method handle to a new type by pairwise argument and return type conversion.
 The original type and new type must have the same number of arguments.
 The resulting method handle is guaranteed to report a type
 which is equal to the desired new type.
 &lt;p&gt;
 If the original type and new type are equal, returns target.
 &lt;p&gt;
 The same conversions are allowed as for {@link java.lang.invoke.MethodHandle#asType java.lang.invoke.MethodHandle.asType},
 and some additional conversions are also applied if those conversions fail.
 Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
 if possible, before or instead of any conversions done by {@code asType}:
 &lt;ul&gt;
 &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
     then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast.
     (This treatment of interfaces follows the usage of the bytecode verifier.)
 &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive,
     the boolean is converted to a byte value, 1 for true, 0 for false.
     (This treatment follows the usage of the bytecode verifier.)
 &lt;li&gt;If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive,
     &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5),
     and the low order bit of the result is tested, as if by {@code (x &amp; 1) != 0}.
 &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean,
     then a Java casting conversion (JLS 5.5) is applied.
     (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
     widening and/or narrowing.)
 &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
     conversion will be applied at runtime, possibly followed
     by a Java casting conversion (JLS 5.5) on the primitive value,
     possibly followed by a conversion from byte to boolean by testing
     the low-order bit.
 &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
     and if the reference is null at runtime, a zero value is introduced.
 &lt;/ul&gt;
@param {Object {MethodHandle}} target the method handle to invoke after arguments are retyped
@param {Object {MethodType}} newType the expected type of the new method handle
@return {Object {java.lang.invoke.MethodHandle}} a method handle which delegates to the target after performing
           any necessary argument conversions, and arranges for any
           necessary return value conversions
@throws NullPointerException if either argument is null
@throws WrongMethodTypeException if the conversion cannot be made
@see MethodHandle#asType
*/
explicitCastArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-permuteArguments'>/**Produces a method handle which adapts the calling sequence of the
</span> given method handle to a new type, by reordering the arguments.
 The resulting method handle is guaranteed to report a type
 which is equal to the desired new type.
 &lt;p&gt;
 The given array controls the reordering.
 Call {@code #I} the number of incoming parameters (the value
 {@code newType.parameterCount()}, and call {@code #O} the number
 of outgoing parameters (the value {@code target.type().parameterCount()}).
 Then the length of the reordering array must be {@code #O},
 and each element must be a non-negative number less than {@code #I}.
 For every {@code N} less than {@code #O}, the {@code N}-th
 outgoing argument will be taken from the {@code I}-th incoming
 argument, where {@code I} is {@code reorder[N]}.
 &lt;p&gt;
 No argument or return value conversions are applied.
 The type of each incoming argument, as determined by {@code newType},
 must be identical to the type of the corresponding outgoing parameter
 or parameters in the target method handle.
 The return type of {@code newType} must be identical to the return
 type of the original target.
 &lt;p&gt;
 The reordering array need not specify an actual permutation.
 An incoming argument will be duplicated if its index appears
 more than once in the array, and an incoming argument will be dropped
 if its index does not appear in the array.
 As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},
 incoming arguments which are not mentioned in the reordering array
 are may be any type, as determined only by {@code newType}.
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodType intfn1 = methodType(int.class, int.class);
MethodType intfn2 = methodType(int.class, int.class, int.class);
MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
assert(sub.type().equals(intfn2));
MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
assert((int)rsub.invokeExact(1, 100) == 99);
MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
assert(add.type().equals(intfn2));
MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
assert(twice.type().equals(intfn1));
assert((int)twice.invokeExact(21) == 42);
 }&lt;/pre&gt;&lt;/blockquote&gt;
@param {Object {MethodHandle}} target the method handle to invoke after arguments are reordered
@param {Object {MethodType}} newType the expected type of the new method handle
@param {Object {int[]}} reorder an index array which controls the reordering
@return {Object {java.lang.invoke.MethodHandle}} a method handle which delegates to the target after it
           drops unused arguments and moves and/or duplicates the other arguments
@throws NullPointerException if any argument is null
@throws IllegalArgumentException if the index array length is not equal to
                  the arity of the target, or if any index array element
                  not a valid index for a parameter of {@code newType},
                  or if two corresponding parameter types in
                  {@code target.type()} and {@code newType} are not identical,
*/
permuteArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-constant'>/**Produces a method handle of the requested return type which returns the given
</span> constant value every time it is invoked.
 &lt;p&gt;
 Before the method handle is returned, the passed-in value is converted to the requested type.
 If the requested type is primitive, widening primitive conversions are attempted,
 else reference conversions are attempted.
 &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.
@param {Object {java.lang.Class}} type the return type of the desired method handle
@param {Object {Object}} value the value to return
@return {Object {java.lang.invoke.MethodHandle}} a method handle of the given return type and no arguments, which always returns the given value
@throws NullPointerException if the {@code type} argument is null
@throws ClassCastException if the value cannot be converted to the required return type
@throws IllegalArgumentException if the given type is {@code void.class}
*/
constant : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**Produces a method handle which returns its sole argument when invoked.
</span>@param {Object {java.lang.Class}} type the type of the sole parameter and return value of the desired method handle
@return {Object {java.lang.invoke.MethodHandle}} a unary method handle which accepts and returns the given type
@throws NullPointerException if the argument is null
@throws IllegalArgumentException if the given type is {@code void.class}
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-identity'>/**
</span>@hide 
*/
identity : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-insertArguments'>/**Provides a target method handle with one or more &lt;em&gt;bound arguments&lt;/em&gt;
</span> in advance of the method handle's invocation.
 The formal parameters to the target corresponding to the bound
 arguments are called &lt;em&gt;bound parameters&lt;/em&gt;.
 Returns a new method handle which saves away the bound arguments.
 When it is invoked, it receives arguments for any non-bound parameters,
 binds the saved arguments to their corresponding parameters,
 and calls the original target.
 &lt;p&gt;
 The type of the new method handle will drop the types for the bound
 parameters from the original target type, since the new method handle
 will no longer require those arguments to be supplied by its callers.
 &lt;p&gt;
 Each given argument object must match the corresponding bound parameter type.
 If a bound parameter type is a primitive, the argument object
 must be a wrapper, and will be unboxed to produce the primitive value.
 &lt;p&gt;
 The {@code pos} argument selects which parameters are to be bound.
 It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
 where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
 and &lt;i&gt;L&lt;/i&gt; is the length of the values array.
@param {Object {MethodHandle}} target the method handle to invoke after the argument is inserted
@param {Number} pos where to insert the argument (zero for the first)
@param {Object {java.lang.Object[]}} values the series of arguments to insert
@return {Object {java.lang.invoke.MethodHandle}} a method handle which inserts an additional argument,
         before calling the original method handle
@throws NullPointerException if the target or the {@code values} array is null
@see MethodHandle#bindTo
*/
insertArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-dropArguments'>/**Produces a method handle which will discard some dummy arguments
</span> before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
 The type of the new method handle will be the same as the target's type,
 except it will also include the dummy argument types,
 at some given position.
 &lt;p&gt;
 The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
 where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
 If {@code pos} is zero, the dummy arguments will precede
 the target's real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
 they will come after.
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  &quot;concat&quot;, methodType(String.class, String.class));
assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
assertEquals(bigType, d0.type());
assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method is also equivalent to the following code:
 &lt;blockquote&gt;&lt;pre&gt;
 {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
 &lt;/pre&gt;&lt;/blockquote&gt;
@param {Object {MethodHandle}} target the method handle to invoke after the arguments are dropped
@param {Number} valueTypes the type(s) of the argument(s) to drop
@param {Object {java.util.List}} pos position of first argument to drop (zero for the leftmost)
@return {Object {java.lang.invoke.MethodHandle}} a method handle which drops arguments of the given types,
         before calling the original method handle
@throws NullPointerException if the target is null,
                              or if the {@code valueTypes} list or any of its elements is null
@throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
                  or if {@code pos} is negative or greater than the arity of the target,
                  or if the new method handle's type would have too many parameters
*/
dropArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-dropArguments'>/**Produces a method handle which will discard some dummy arguments
</span> before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
 The type of the new method handle will be the same as the target's type,
 except it will also include the dummy argument types,
 at some given position.
 &lt;p&gt;
 The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
 where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
 If {@code pos} is zero, the dummy arguments will precede
 the target's real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
 they will come after.
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  &quot;concat&quot;, methodType(String.class, String.class));
assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
MethodHandle d0 = dropArguments(cat, 0, String.class);
assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
MethodHandle d1 = dropArguments(cat, 1, String.class);
assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
MethodHandle d2 = dropArguments(cat, 2, String.class);
assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method is also equivalent to the following code:
 &lt;blockquote&gt;&lt;pre&gt;
 {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
 &lt;/pre&gt;&lt;/blockquote&gt;
@param {Object {MethodHandle}} target the method handle to invoke after the arguments are dropped
@param {Number} valueTypes the type(s) of the argument(s) to drop
@param {Object {java.lang.Class[]}} pos position of first argument to drop (zero for the leftmost)
@return {Object {java.lang.invoke.MethodHandle}} a method handle which drops arguments of the given types,
         before calling the original method handle
@throws NullPointerException if the target is null,
                              or if the {@code valueTypes} array or any of its elements is null
@throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
                  or if {@code pos} is negative or greater than the arity of the target,
                  or if the new method handle's type would have
                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
*/
dropArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-filterArguments'>/**Adapts a target method handle by pre-processing
</span> one or more of its arguments, each with its own unary filter function,
 and then calling the target with each pre-processed argument
 replaced by the result of its corresponding filter function.
 &lt;p&gt;
 The pre-processing is performed by one or more method handles,
 specified in the elements of the {@code filters} array.
 The first element of the filter array corresponds to the {@code pos}
 argument of the target, and so on in sequence.
 &lt;p&gt;
 Null arguments in the array are treated as identity functions,
 and the corresponding arguments left unchanged.
 (If there are no non-null elements in the array, the original target is returned.)
 Each filter is applied to the corresponding argument of the adapter.
 &lt;p&gt;
 If a filter {@code F} applies to the {@code N}th argument of
 the target, then {@code F} must be a method handle which
 takes exactly one argument.  The type of {@code F}'s sole argument
 replaces the corresponding argument type of the target
 in the resulting adapted method handle.
 The return type of {@code F} must be identical to the corresponding
 parameter type of the target.
 &lt;p&gt;
 It is an error if there are elements of {@code filters}
 (null or not)
 which do not correspond to argument positions in the target.
 &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  &quot;concat&quot;, methodType(String.class, String.class));
MethodHandle upcase = lookup().findVirtual(String.class,
  &quot;toUpperCase&quot;, methodType(String.class));
assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
MethodHandle f0 = filterArguments(cat, 0, upcase);
assertEquals(&quot;Xy&quot;, (String) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // Xy
MethodHandle f1 = filterArguments(cat, 1, upcase);
assertEquals(&quot;xY&quot;, (String) f1.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xY
MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
assertEquals(&quot;XY&quot;, (String) f2.invokeExact(&quot;x&quot;, &quot;y&quot;)); // XY
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt; Here is pseudocode for the resulting adapter:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 V target(P... p, A[i]... a[i], B... b);
 A[i] filter[i](V[i]);
 T adapter(P... p, V[i]... v[i], B... b) {
   return target(p..., f[i](v[i])..., b...);
 }
 }&lt;/pre&gt;&lt;/blockquote&gt;
@param {Object {MethodHandle}} target the method handle to invoke after arguments are filtered
@param {Number} pos the position of the first argument to filter
@param {Object {java.lang.invoke.MethodHandle[]}} filters method handles to call initially on filtered arguments
@return {Object {java.lang.invoke.MethodHandle}} method handle which incorporates the specified argument filtering logic
@throws NullPointerException if the target is null
                              or if the {@code filters} array is null
@throws IllegalArgumentException if a non-null element of {@code filters}
          does not match a corresponding argument type of target as described above,
          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
          or if the resulting method handle's type would have
          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
*/
filterArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-collectArguments'>/**Adapts a target method handle by pre-processing
</span> a sub-sequence of its arguments with a filter (another method handle).
 The pre-processed arguments are replaced by the result (if any) of the
 filter function.
 The target is then called on the modified (usually shortened) argument list.
 &lt;p&gt;
 If the filter returns a value, the target must accept that value as
 its argument in position {@code pos}, preceded and/or followed by
 any arguments not passed to the filter.
 If the filter returns void, the target must accept all arguments
 not passed to the filter.
 No arguments are reordered, and a result returned from the filter
 replaces (in order) the whole subsequence of arguments originally
 passed to the adapter.
 &lt;p&gt;
 The argument types (if any) of the filter
 replace zero or one argument types of the target, at position {@code pos},
 in the resulting adapted method handle.
 The return type of the filter (if any) must be identical to the
 argument type of the target at position {@code pos}, and that target argument
 is supplied by the return value of the filter.
 &lt;p&gt;
 In all cases, {@code pos} must be greater than or equal to zero, and
 {@code pos} must also be less than or equal to the target's arity.
 &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, &quot;deepToString&quot;, methodType(String.class, Object[].class));

MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
assertEquals(&quot;[strange]&quot;, (String) ts1.invokeExact(&quot;strange&quot;));

MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals(&quot;[up, down]&quot;, (String) ts2.invokeExact(&quot;up&quot;, &quot;down&quot;));

MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
assertEquals(&quot;[top, [up, down], strange]&quot;,
             (String) ts3_ts2.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));

MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
assertEquals(&quot;[top, [up, down], [strange]]&quot;,
             (String) ts3_ts2_ts1.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));

MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
assertEquals(&quot;[top, [[up, down, strange], charm], bottom]&quot;,
             (String) ts3_ts2_ts3.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;, &quot;charm&quot;, &quot;bottom&quot;));
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt; Here is pseudocode for the resulting adapter:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 T target(A...,V,C...);
 V filter(B...);
 T adapter(A... a,B... b,C... c) {
   V v = filter(b...);
   return target(a...,v,c...);
 }
 // and if the filter has no arguments:
 T target2(A...,V,C...);
 V filter2();
 T adapter2(A... a,C... c) {
   V v = filter2();
   return target2(a...,v,c...);
 }
 // and if the filter has a void return:
 T target3(A...,C...);
 void filter3(B...);
 void adapter3(A... a,B... b,C... c) {
   filter3(b...);
   return target3(a...,c...);
 }
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 A collection adapter {@code collectArguments(mh, 0, coll)} is equivalent to
 one which first &quot;folds&quot; the affected arguments, and then drops them, in separate
 steps as follows:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
 mh = MethodHandles.foldArguments(mh, coll); //step 1
 }&lt;/pre&gt;&lt;/blockquote&gt;
 If the target method handle consumes no arguments besides than the result
 (if any) of the filter {@code coll}, then {@code collectArguments(mh, 0, coll)}
 is equivalent to {@code filterReturnValue(coll, mh)}.
 If the filter method handle {@code coll} consumes one argument and produces
 a non-void result, then {@code collectArguments(mh, N, coll)}
 is equivalent to {@code filterArguments(mh, N, coll)}.
 Other equivalences are possible but would require argument permutation.
@param {Object {MethodHandle}} target the method handle to invoke after filtering the subsequence of arguments
@param {Number} pos the position of the first adapter argument to pass to the filter,
            and/or the target argument which receives the result of the filter
@param {Object {MethodHandle}} filter method handle to call on the subsequence of arguments
@return {Object {java.lang.invoke.MethodHandle}} method handle which incorporates the specified argument subsequence filtering logic
@throws NullPointerException if either argument is null
@throws IllegalArgumentException if the return type of {@code filter}
          is non-void and is not the same as the {@code pos} argument of the target,
          or if {@code pos} is not between 0 and the target's arity, inclusive,
          or if the resulting method handle's type would have
          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
@see MethodHandles#foldArguments
@see MethodHandles#filterArguments
@see MethodHandles#filterReturnValue
*/
collectArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-filterReturnValue'>/**Adapts a target method handle by post-processing
</span> its return value (if any) with a filter (another method handle).
 The result of the filter is returned from the adapter.
 &lt;p&gt;
 If the target returns a value, the filter must accept that value as
 its only argument.
 If the target returns void, the filter must accept no arguments.
 &lt;p&gt;
 The return type of the filter
 replaces the return type of the target
 in the resulting adapted method handle.
 The argument type of the filter (if any) must be identical to the
 return type of the target.
 &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  &quot;concat&quot;, methodType(String.class, String.class));
MethodHandle length = lookup().findVirtual(String.class,
  &quot;length&quot;, methodType(int.class));
System.out.println((String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xy
MethodHandle f0 = filterReturnValue(cat, length);
System.out.println((int) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // 2
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt; Here is pseudocode for the resulting adapter:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 V target(A...);
 T filter(V);
 T adapter(A... a) {
   V v = target(a...);
   return filter(v);
 }
 // and if the target has a void return:
 void target2(A...);
 T filter2();
 T adapter2(A... a) {
   target2(a...);
   return filter2();
 }
 // and if the filter has a void return:
 V target3(A...);
 void filter3(V);
 void adapter3(A... a) {
   V v = target3(a...);
   filter3(v);
 }
 }&lt;/pre&gt;&lt;/blockquote&gt;
@param {Object {MethodHandle}} target the method handle to invoke before filtering the return value
@param {Object {MethodHandle}} filter method handle to call on the return value
@return {Object {java.lang.invoke.MethodHandle}} method handle which incorporates the specified return value filtering logic
@throws NullPointerException if either argument is null
@throws IllegalArgumentException if the argument list of {@code filter}
          does not match the return type of target as described above
*/
filterReturnValue : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-foldArguments'>/**Adapts a target method handle by pre-processing
</span> some of its arguments, and then calling the target with
 the result of the pre-processing, inserted into the original
 sequence of arguments.
 &lt;p&gt;
 The pre-processing is performed by {@code combiner}, a second method handle.
 Of the arguments passed to the adapter, the first {@code N} arguments
 are copied to the combiner, which is then called.
 (Here, {@code N} is defined as the parameter count of the combiner.)
 After this, control passes to the target, with any result
 from the combiner inserted before the original {@code N} incoming
 arguments.
 &lt;p&gt;
 If the combiner returns a value, the first parameter type of the target
 must be identical with the return type of the combiner, and the next
 {@code N} parameter types of the target must exactly match the parameters
 of the combiner.
 &lt;p&gt;
 If the combiner has a void return, no result will be inserted,
 and the first {@code N} parameter types of the target
 must exactly match the parameters of the combiner.
 &lt;p&gt;
 The resulting adapter is the same type as the target, except that the
 first parameter type is dropped,
 if it corresponds to the result of the combiner.
 &lt;p&gt;
 (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments
 that either the combiner or the target does not wish to receive.
 If some of the incoming arguments are destined only for the combiner,
 consider using {@link java.lang.invoke.MethodHandle#asCollector asCollector} instead, since those
 arguments will not need to be live on the stack on entry to the
 target.)
 &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
 &lt;blockquote&gt;&lt;pre&gt;{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
  &quot;println&quot;, methodType(void.class, String.class))
    .bindTo(System.out);
MethodHandle cat = lookup().findVirtual(String.class,
  &quot;concat&quot;, methodType(String.class, String.class));
assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
MethodHandle catTrace = foldArguments(cat, trace);
// also prints &quot;boo&quot;:
assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
 }&lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt; Here is pseudocode for the resulting adapter:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 // there are N arguments in A...
 T target(V, A[N]..., B...);
 V combiner(A...);
 T adapter(A... a, B... b) {
   V v = combiner(a...);
   return target(v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(A[N]..., B...);
 void combiner2(A...);
 T adapter2(A... a, B... b) {
   combiner2(a...);
   return target2(a..., b...);
 }
 }&lt;/pre&gt;&lt;/blockquote&gt;
@param {Object {MethodHandle}} target the method handle to invoke after arguments are combined
@param {Object {MethodHandle}} combiner method handle to call initially on the incoming arguments
@return {Object {java.lang.invoke.MethodHandle}} method handle which incorporates the specified argument folding logic
@throws NullPointerException if either argument is null
@throws IllegalArgumentException if {@code combiner}'s return type
          is non-void and not the same as the first argument type of
          the target, or if the initial {@code N} argument types
          of the target
          (skipping one matching the {@code combiner}'s return type)
          are not identical with the argument types of {@code combiner}
*/
foldArguments : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-guardWithTest'>/**Makes a method handle which adapts a target method handle,
</span> by guarding it with a test, a boolean-valued method handle.
 If the guard fails, a fallback handle is called instead.
 All three method handles must have the same corresponding
 argument and return types, except that the return type
 of the test must be boolean, and the test is allowed
 to have fewer arguments than the other two method handles.
 &lt;p&gt; Here is pseudocode for the resulting adapter:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 boolean test(A...);
 T target(A...,B...);
 T fallback(A...,B...);
 T adapter(A... a,B... b) {
   if (test(a...))
     return target(a..., b...);
   else
     return fallback(a..., b...);
 }
 }&lt;/pre&gt;&lt;/blockquote&gt;
 Note that the test arguments ({@code a...} in the pseudocode) cannot
 be modified by execution of the test, and so are passed unchanged
 from the caller to the target or fallback as appropriate.
@param {Object {MethodHandle}} test method handle used for test, must return boolean
@param {Object {MethodHandle}} target method handle to call if test passes
@param {Object {MethodHandle}} fallback method handle to call if test fails
@return {Object {java.lang.invoke.MethodHandle}} method handle which incorporates the specified if/then/else logic
@throws NullPointerException if any argument is null
@throws IllegalArgumentException if {@code test} does not return boolean,
          or if all three method types do not match (with the return
          type of {@code test} changed to match that of the target).
*/
guardWithTest : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-catchException'>/**Makes a method handle which adapts a target method handle,
</span> by running it inside an exception handler.
 If the target returns normally, the adapter returns that value.
 If an exception matching the specified type is thrown, the fallback
 handle is called instead on the exception, plus the original arguments.
 &lt;p&gt;
 The target and handler must have the same corresponding
 argument and return types, except that handler may omit trailing arguments
 (similarly to the predicate in {@link #guardWithTest guardWithTest}).
 Also, the handler must have an extra leading parameter of {@code exType} or a supertype.
 &lt;p&gt; Here is pseudocode for the resulting adapter:
 &lt;blockquote&gt;&lt;pre&gt;{@code
 T target(A..., B...);
 T handler(ExType, A...);
 T adapter(A... a, B... b) {
   try {
     return target(a..., b...);
   } catch (ExType ex) {
     return handler(ex, a...);
   }
 }
 }&lt;/pre&gt;&lt;/blockquote&gt;
 Note that the saved arguments ({@code a...} in the pseudocode) cannot
 be modified by execution of the target, and so are passed unchanged
 from the caller to the handler, if the handler is invoked.
 &lt;p&gt;
 The target and handler must return the same type, even if the handler
 always throws.  (This might happen, for instance, because the handler
 is simulating a {@code finally} clause).
 To create such a throwing handler, compose the handler creation logic
 with {@link #throwException throwException},
 in order to create a method handle of the correct return type.
@param {Object {MethodHandle}} target method handle to call
@param {Object {java.lang.Class}} exType the type of exception which the handler will catch
@param {Object {MethodHandle}} handler method handle to call if a matching exception is thrown
@return {Object {java.lang.invoke.MethodHandle}} method handle which incorporates the specified try/catch logic
@throws NullPointerException if any argument is null
@throws IllegalArgumentException if {@code handler} does not accept
          the given exception type, or if the method handle types do
          not match in their return types and their
          corresponding parameters
*/
catchException : function(  ) {},

<span id='java-lang-invoke-MethodHandles-method-throwException'>/**Produces a method handle which will throw exceptions of the given {@code exType}.
</span> The method handle will accept a single argument of {@code exType},
 and immediately throw it as an exception.
 The method type will nominally specify a return of {@code returnType}.
 The return type may be anything convenient:  It doesn't matter to the
 method handle's behavior, since it will never return normally.
@param {Object {java.lang.Class}} returnType the return type of the desired method handle
@param {Object {java.lang.Class}} exType the parameter type of the desired method handle
@return {Object {java.lang.invoke.MethodHandle}} method handle which can throw the given exceptions
@throws NullPointerException if either argument is null
*/
throwException : function(  ) {},


};</pre>
</body>
</html>
