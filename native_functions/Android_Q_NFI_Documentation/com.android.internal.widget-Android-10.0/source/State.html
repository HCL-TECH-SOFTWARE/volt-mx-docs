<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='com-android-internal-widget-RecyclerView-State'>/**@class com.android.internal.widget.RecyclerView.State
</span>@extends java.lang.Object

 &lt;p&gt;Contains useful information about the current RecyclerView state like target scroll
 position or view focus. State object can also keep arbitrary data, identified by resource
 ids.&lt;/p&gt;
 &lt;p&gt;Often times, RecyclerView components will need to pass information between each other.
 To provide a well defined data bus between components, RecyclerView passes the same State
 object to component callbacks and these components can use it to exchange data.&lt;/p&gt;
 &lt;p&gt;If you implement custom components, you can use State's put/get/remove methods to pass
 data between your components without needing to manage their lifecycles.&lt;/p&gt;
*/
var State = {

<span id='com-android-internal-widget-RecyclerView-State-method-isMeasuring'>/**Returns true if the RecyclerView is currently measuring the layout. This value is
</span> {@code true} only if the LayoutManager opted into the auto measure API and RecyclerView
 has non-exact measurement specs.
 &lt;p&gt;
 Note that if the LayoutManager supports predictive animations and it is calculating the
 pre-layout step, this value will be {@code false} even if the RecyclerView is in
 {@code onMeasure} call. This is because pre-layout means the previous state of the
 RecyclerView and measurements made for that state cannot change the RecyclerView's size.
 LayoutManager is always guaranteed to receive another call to
 {@link com.android.internal.widget.RecyclerView.LayoutManager#onLayoutChildren(Recycler, State)} when this happens.
@return {Boolean} True if the RecyclerView is currently calculating its bounds, false otherwise.
*/
isMeasuring : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-isPreLayout'>/**Returns true if
</span>@return {Boolean} 
*/
isPreLayout : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-willRunPredictiveAnimations'>/**Returns whether RecyclerView will run predictive animations in this layout pass
</span> or not.
@return {Boolean} true if RecyclerView is calculating predictive animations to be run at the end
         of the layout pass.
*/
willRunPredictiveAnimations : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-willRunSimpleAnimations'>/**Returns whether RecyclerView will run simple animations in this layout pass
</span> or not.
@return {Boolean} true if RecyclerView is calculating simple animations to be run at the end of
         the layout pass.
*/
willRunSimpleAnimations : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-remove'>/**Removes the mapping from the specified id, if there was any.
</span>@param {Number} resourceId Id of the resource you want to remove. It is suggested to use R.id.* to
                   preserve cross functionality and avoid conflicts.
*/
remove : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-get'>/**Gets the Object mapped from the specified id, or &lt;code&gt;null&lt;/code&gt;
</span> if no such data exists.
@param {Number} resourceId Id of the resource you want to remove. It is suggested to use R.id.*
                   to
                   preserve cross functionality and avoid conflicts.
*/
get : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-put'>/**Adds a mapping from the specified id to the specified value, replacing the previous
</span> mapping from the specified key if there was one.
@param {Number} resourceId Id of the resource you want to add. It is suggested to use R.id.* to
                   preserve cross functionality and avoid conflicts.
@param {Object {Object}} data       The data you want to associate with the resourceId.
*/
put : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-getTargetScrollPosition'>/**If scroll is triggered to make a certain item visible, this value will return the
</span> adapter index of that item.
@return {Number} Adapter index of the target item or
 {@link RecyclerView#NO_POSITION} if there is no target
 position.
*/
getTargetScrollPosition : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-hasTargetScrollPosition'>/**Returns if current scroll has a target position.
</span>@return {Boolean} true if scroll is being triggered to make a certain position visible
@see #getTargetScrollPosition()
*/
hasTargetScrollPosition : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-didStructureChange'>/**
</span>@return {Boolean} true if the structure of the data set has changed since the last call to
         onLayoutChildren, false otherwise
*/
didStructureChange : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-getItemCount'>/**Returns the total number of items that can be laid out. Note that this number is not
</span> necessarily equal to the number of items in the adapter, so you should always use this
 number for your position calculations and never access the adapter directly.
 &lt;p&gt;
 RecyclerView listens for Adapter's notify events and calculates the effects of adapter
 data changes on existing Views. These calculations are used to decide which animations
 should be run.
 &lt;p&gt;
 To support predictive animations, RecyclerView may rewrite or reorder Adapter changes to
 present the correct state to LayoutManager in pre-layout pass.
 &lt;p&gt;
 For example, a newly added item is not included in pre-layout item count because
 pre-layout reflects the contents of the adapter before the item is added. Behind the
 scenes, RecyclerView offsets {@link com.android.internal.widget.RecyclerView.Recycler#getViewForPosition(int)} calls such that
 LayoutManager does not know about the new item's existence in pre-layout. The item will
 be available in second layout pass and will be included in the item count. Similar
 adjustments are made for moved and removed items as well.
 &lt;p&gt;
 You can get the adapter's item count via {@link com.android.internal.widget.RecyclerView.LayoutManager#getItemCount()} method.
@return {Number} The number of items currently available
@see LayoutManager#getItemCount()
*/
getItemCount : function(  ) {},

<span id='com-android-internal-widget-RecyclerView-State-method-toString'>/**
</span>*/
toString : function(  ) {},


};</pre>
</body>
</html>
