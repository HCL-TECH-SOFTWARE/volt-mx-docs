Ext.data.JsonP.android_service_autofill_AutofillService({"tagname":"class","name":"android.service.autofill.AutofillService","autodetected":{},"files":[{"filename":"AutofillService.js","href":"AutofillService.html#android-service-autofill-AutofillService"}],"extends":"android.app.Service","members":[{"name":"SERVICE_INTERFACE","tagname":"property","owner":"android.service.autofill.AutofillService","id":"property-SERVICE_INTERFACE","meta":{}},{"name":"SERVICE_META_DATA","tagname":"property","owner":"android.service.autofill.AutofillService","id":"property-SERVICE_META_DATA","meta":{}},{"name":"getFillEventHistory","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-getFillEventHistory","meta":{}},{"name":"onBind","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-onBind","meta":{}},{"name":"onConnected","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-onConnected","meta":{}},{"name":"onCreate","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-onCreate","meta":{}},{"name":"onDisconnected","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-onDisconnected","meta":{}},{"name":"onFillRequest","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-onFillRequest","meta":{}},{"name":"onSaveRequest","tagname":"method","owner":"android.service.autofill.AutofillService","id":"method-onSaveRequest","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-android.service.autofill.AutofillService","short_doc":"An {@code AutofillService} is a service used to automatically fill the contents of the screen\n on behalf of a given u...","classIcon":"icon-class","superclasses":["android.app.Service"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>android.app.Service<div class='subclass '><strong>android.service.autofill.AutofillService</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/AutofillService.html#android-service-autofill-AutofillService' target='_blank'>AutofillService.js</a></div></pre><div class='doc-contents'><p>An {@code AutofillService} is a service used to automatically fill the contents of the screen\n on behalf of a given user - for more information about autofill, read\n <a href=\"{@docRoot}preview/features/autofill.html\">Autofill Framework</a>.</p>\n\n<p> <p>An {@code AutofillService} is only bound to the Android System for autofill purposes if:\n <ol>\n   <li>It requires the {@code android.permission.BIND_AUTOFILL_SERVICE} permission in its\n       manifest.\n   <li>The user explicitly enables it using Android Settings (the\n       Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE intent can be used to launch such\n       Settings screen).\n </li></li></ol></p>\n\n<p> <a name=\"BasicUsage\"></a>\n <h3>Basic usage</h3></p>\n\n<p> <p>The basic autofill process is defined by the workflow below:\n <ol>\n   <li>User focus an editable View.\n   <li>View calls AutofillManager.notifyViewEntered(android.view.View).\n   <li>A ViewStructure representing all views in the screen is created.\n   <li>The Android System binds to the service and calls <a href=\"#!/api/android.service.autofill.AutofillService-method-onConnected\" rel=\"android.service.autofill.AutofillService-method-onConnected\" class=\"docClass\">onConnected</a>().\n   <li>The service receives the view structure through the\n       CancellationSignal, android.service.autofill.FillCallback).\n   <li>The service replies through android.service.autofill.FillCallback.onSuccess(FillResponse).\n   <li>The Android System calls <a href=\"#!/api/android.service.autofill.AutofillService-method-onDisconnected\" rel=\"android.service.autofill.AutofillService-method-onDisconnected\" class=\"docClass\">onDisconnected</a>() and unbinds from the\n       {@code AutofillService}.\n   <li>The Android System displays an autofill UI with the options sent by the service.\n   <li>The user picks an option.\n   <li>The proper views are autofilled.\n </li></li></li></li></li></li></li></li></li></li></ol></p>\n\n<p> <p>This workflow was designed to minimize the time the Android System is bound to the service;\n for each call, it: binds to service, waits for the reply, and unbinds right away. Furthermore,\n those calls are considered stateless: if the service needs to keep state between calls, it must\n do its own state management (keeping in mind that the service's process might be killed by the\n Android System when unbound; for example, if the device is running low in memory).</p>\n\n<p> <p>Typically, the\n CancellationSignal, android.service.autofill.FillCallback) will:\n <ol>\n   <li>Parse the view structure looking for autofillable views (for example, using\n       android.app.assist.AssistStructure.ViewNode.getAutofillHints().\n   <li>Match the autofillable views with the user's data.\n   <li>Create a <a href=\"#!/api/android.service.autofill.Dataset\" rel=\"android.service.autofill.Dataset\" class=\"docClass\">android.service.autofill.Dataset</a> for each set of user's data that match those fields.\n   <li>Fill the dataset(s) with the proper AutofillIds and AutofillValues.\n   <li>Add the dataset(s) to the <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a> passed to\n       android.service.autofill.FillCallback.onSuccess(FillResponse).\n </li></li></li></li></li></ol></p>\n\n<p> <p>For example, for a login screen with username and password views where the user only has one\n account in the service, the response could be:</p>\n\n<p> <pre class=\"prettyprint\">\n new FillResponse.Builder()\n     .addDataset(new Dataset.Builder()\n         .setValue(id1, AutofillValue.forText(\"homer\"), createPresentation(\"homer\"))\n         .setValue(id2, AutofillValue.forText(\"D'OH!\"), createPresentation(\"password for homer\"))\n         .build())\n     .build();\n </pre></p>\n\n<p> <p>But if the user had 2 accounts instead, the response could be:</p>\n\n<p> <pre class=\"prettyprint\">\n new FillResponse.Builder()\n     .addDataset(new Dataset.Builder()\n         .setValue(id1, AutofillValue.forText(\"homer\"), createPresentation(\"homer\"))\n         .setValue(id2, AutofillValue.forText(\"D'OH!\"), createPresentation(\"password for homer\"))\n         .build())\n     .addDataset(new Dataset.Builder()\n         .setValue(id1, AutofillValue.forText(\"flanders\"), createPresentation(\"flanders\"))\n         .setValue(id2, AutofillValue.forText(\"OkelyDokelyDo\"), createPresentation(\"password for flanders\"))\n         .build())\n     .build();\n </pre></p>\n\n<p> <p>If the service does not find any autofillable view in the view structure, it should pass\n {@code null} to android.service.autofill.FillCallback.onSuccess(FillResponse); if the service encountered an error\n processing the request, it should call android.service.autofill.FillCallback.onFailure(CharSequence). For\n performance reasons, it's paramount that the service calls either\n android.service.autofill.FillCallback.onSuccess(FillResponse) or android.service.autofill.FillCallback.onFailure(CharSequence) for\n each CancellationSignal, android.service.autofill.FillCallback) received - if it\n doesn't, the request will eventually time out and be discarded by the Android System.</p>\n\n<p> <a name=\"SavingUserData\"></a>\n <h3>Saving user data</h3></p>\n\n<p> <p>If the service is also interested on saving the data filled by the user, it must set a\n <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> object in the <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a>. See <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> for more details and\n examples.</p>\n\n<p> <a name=\"UserAuthentication\"></a>\n <h3>User authentication</h3></p>\n\n<p> <p>The service can provide an extra degree of security by requiring the user to authenticate\n before an app can be autofilled. The authentication is typically required in 2 scenarios:\n <ul>\n   <li>To unlock the user data (for example, using a master password or fingerprint\n       authentication) - see\n android.content.IntentSender, android.widget.RemoteViews).\n   <li>To unlock a specific dataset (for example, by providing a CVC for a credit card) - see\n       android.service.autofill.Dataset.Builder.setAuthentication(android.content.IntentSender).\n </li></li></ul></p>\n\n<p> <p>When using authentication, it is recommended to encrypt only the sensitive data and leave\n labels unencrypted, so they can be used on presentation views. For example, if the user has a\n home and a work address, the {@code Home} and {@code Work} labels should be stored unencrypted\n (since they don't have any sensitive data) while the address data per se could be stored in an\n encrypted storage. Then when the user chooses the {@code Home} dataset, the platform starts\n the authentication flow, and the service can decrypt the sensitive data.</p>\n\n<p> <p>The authentication mechanism can also be used in scenarios where the service needs multiple\n steps to determine the datasets that can fill a screen. For example, when autofilling a financial\n app where the user has accounts for multiple banks, the workflow could be:</p>\n\n<p> <ol>\n   <li>The first <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a> contains datasets with the credentials for the financial\n       app, plus a \"fake\" dataset whose presentation says \"Tap here for banking apps credentials\".\n   <li>When the user selects the fake dataset, the service displays a dialog with available\n       banking apps.\n   <li>When the user select a banking app, the service replies with a new <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a>\n       containing the datasets for that bank.\n </li></li></li></ol></p>\n\n<p> <p>Another example of multiple-steps dataset selection is when the service stores the user\n credentials in \"vaults\": the first response would contain fake datasets with the vault names,\n and the subsequent response would contain the app credentials stored in that vault.</p>\n\n<p> <a name=\"DataPartioning\"></a>\n <h3>Data partitioning</h3></p>\n\n<p> <p>The autofillable views in a screen should be grouped in logical groups called \"partitions\".\n Typical partitions are:\n <ul>\n   <li>Credentials (username/email address, password).\n   <li>Address (street, city, state, zip code, etc).\n   <li>Payment info (credit card number, expiration date, and verification code).\n </li></li></li></ul>\n <p>For security reasons, when a screen has more than one partition, it's paramount that the\n contents of a dataset do not spawn multiple partitions, specially when one of the partitions\n contains data that is not specific to the application being autofilled. For example, a dataset\n should not contain fields for username, password, and credit card information. The reason for\n this rule is that a malicious app could draft a view structure where the credit card fields\n are not visible, so when the user selects a dataset from the username UI, the credit card info is\n released to the application without the user knowledge. Similarly, it's recommended to always\n protect a dataset that contains sensitive information by requiring dataset authentication\n (see android.service.autofill.Dataset.Builder.setAuthentication(android.content.IntentSender)), and to include\n info about the \"primary\" field of the partition in the custom presentation for \"secondary\"\n fields&mdash;that would prevent a malicious app from getting the \"primary\" fields without the\n user realizing they're being released (for example, a malicious app could have fields for a\n credit card number, verification code, and expiration date crafted in a way that just the latter\n is visible; by explicitly indicating the expiration date is related to a given credit card\n number, the service would be providing a visual clue for the users to check what would be\n released upon selecting that field).</p>\n\n<p> <p>When the service detects that a screen has multiple partitions, it should return a\n <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a> with just the datasets for the partition that originated the request (i.e.,\n the partition that has the android.app.assist.AssistStructure.ViewNode whose\n android.app.assist.AssistStructure.ViewNode.isFocused() returns {@code true}); then if\n the user selects a field from a different partition, the Android System will make another\n CancellationSignal, android.service.autofill.FillCallback) call for that partition,\n and so on.</p>\n\n<p> <p>Notice that when the user autofill a partition with the data provided by the service and the\n user did not change these fields, the autofilled value is sent back to the service in the\n subsequent calls (and can be obtained by calling\n android.app.assist.AssistStructure.ViewNode.getAutofillValue()). This is useful in the\n cases where the service must create datasets for a partition based on the choice made in a\n previous partition. For example, the 1st response for a screen that have credentials and address\n partitions could be:</p>\n\n<p> <pre class=\"prettyprint\">\n new FillResponse.Builder()\n     .addDataset(new Dataset.Builder() // partition 1 (credentials)\n         .setValue(id1, AutofillValue.forText(\"homer\"), createPresentation(\"homer\"))\n         .setValue(id2, AutofillValue.forText(\"D'OH!\"), createPresentation(\"password for homer\"))\n         .build())\n     .addDataset(new Dataset.Builder() // partition 1 (credentials)\n         .setValue(id1, AutofillValue.forText(\"flanders\"), createPresentation(\"flanders\"))\n         .setValue(id2, AutofillValue.forText(\"OkelyDokelyDo\"), createPresentation(\"password for flanders\"))\n         .build())\n     .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD,\n         new AutofillId[] { id1, id2 })\n             .build())\n     .build();\n </pre></p>\n\n<p> <p>Then if the user selected {@code flanders}, the service would get a new\n CancellationSignal, android.service.autofill.FillCallback) call, with the values of\n the fields {@code id1} and {@code id2} prepopulated, so the service could then fetch the address\n for the Flanders account and return the following <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a> for the address partition:</p>\n\n<p> <pre class=\"prettyprint\">\n new FillResponse.Builder()\n     .addDataset(new Dataset.Builder() // partition 2 (address)\n         .setValue(id3, AutofillValue.forText(\"744 Evergreen Terrace\"), createPresentation(\"744 Evergreen Terrace\")) // street\n         .setValue(id4, AutofillValue.forText(\"Springfield\"), createPresentation(\"Springfield\")) // city\n         .build())\n     .setSaveInfo(new SaveInfo.Builder(SaveInfo.SAVE_DATA_TYPE_PASSWORD | SaveInfo.SAVE_DATA_TYPE_ADDRESS,\n         new AutofillId[] { id1, id2 }) // username and password\n              .setOptionalIds(new AutofillId[] { id3, id4 }) // state and zipcode\n             .build())\n     .build();\n </pre></p>\n\n<p> <p>When the service returns multiple <a href=\"#!/api/android.service.autofill.FillResponse\" rel=\"android.service.autofill.FillResponse\" class=\"docClass\">android.service.autofill.FillResponse</a>, the last one overrides the previous;\n that's why the <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> in the 2nd request above has the info for both partitions.</p>\n\n<p> <a name=\"PackageVerification\"></a>\n <h3>Package verification</h3></p>\n\n<p> <p>When autofilling app-specific data (like username and password), the service must verify\n the authenticity of the request by obtaining all signing certificates of the app being\n autofilled, and only fulfilling the request when they match the values that were\n obtained when the data was first saved &mdash; such verification is necessary to avoid phishing\n attempts by apps that were sideloaded in the device with the same package name of another app.\n Here's an example on how to achieve that by hashing the signing certificates:</p>\n\n<p> <pre class=\"prettyprint\">\n private String getCertificatesHash(String packageName) throws Exception {\n   PackageManager pm = mContext.getPackageManager();\n   PackageInfo info = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);\n   ArrayList<String> hashes = new ArrayList&lt;>(info.signatures.length);\n   for (Signature sig : info.signatures) {\n     byte[] cert = sig.toByteArray();\n     MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n     md.update(cert);\n     hashes.add(toHexString(md.digest()));\n   }\n   Collections.sort(hashes);\n   StringBuilder hash = new StringBuilder();\n   for (int i = 0; i &lt; hashes.size(); i++) {\n     hash.append(hashes.get(i));\n   }\n   return hash.toString();\n }\n </String></pre></p>\n\n<p> <p>If the service did not store the signing certificates data the first time the data was saved\n &mdash; for example, because the data was created by a previous version of the app that did not\n use the Autofill Framework &mdash; the service should warn the user that the authenticity of the\n app cannot be confirmed (see an example on how to show such warning in the\n <a href=\"#WebSecurityDisclaimer\">Web security</a> section below), and if the user agrees,\n then the service could save the data from the signing ceriticates for future use.</p>\n\n<p> <a name=\"IgnoringViews\"></a>\n <h3>Ignoring views</h3></p>\n\n<p> <p>If the service find views that cannot be autofilled (for example, a text field representing\n the response to a Captcha challenge), it should mark those views as ignored by\n calling android.service.autofill.FillResponse.Builder.setIgnoredIds(AutofillId...) so the system does not trigger\n a new CancellationSignal, android.service.autofill.FillCallback) when these views are\n focused.</p>\n\n<p> <a name=\"WebSecurity\"></a>\n <h3>Web security</h3></p>\n\n<p> <p>When handling autofill requests that represent web pages (typically\n view structures whose root's android.app.assist.AssistStructure.ViewNode.getClassName()\n is a android.webkit.WebView), the service should take the following steps to verify if\n the structure can be autofilled with the data associated with the app requesting it:</p>\n\n<p> <ol>\n   <li>Use the android.app.assist.AssistStructure.ViewNode.getWebDomain() to get the\n       source of the document.\n   <li>Get the canonical domain using the\n       <a href=\"https://publicsuffix.org/\">Public Suffix List</a> (see example below).\n   <li>Use <a href=\"https://developers.google.com/digital-asset-links/\">Digital Asset Links</a>\n       to obtain the package name and certificate fingerprint of the package corresponding to\n       the canonical domain.\n   <li>Make sure the certificate fingerprint matches the value returned by Package Manager\n       (see \"Package verification\" section above).\n </li></li></li></li></ol></p>\n\n<p> <p>Here's an example on how to get the canonical domain using\n <a href=\"https://github.com/google/guava\">Guava</a>:</p>\n\n<p> <pre class=\"prettyprint\">\n private static String getCanonicalDomain(String domain) {\n   InternetDomainName idn = InternetDomainName.from(domain);\n   while (idn != null &amp;&amp; !idn.isTopPrivateDomain()) {\n     idn = idn.parent();\n   }\n   return idn == null ? null : idn.toString();\n }\n </pre></p>\n\n<p> <a name=\"WebSecurityDisclaimer\"></a>\n <p>If the association between the web domain and app package cannot be verified through the steps\n above, but the service thinks that it is appropriate to fill persisted credentials that are\n stored for the web domain, the service should warn the user about the potential data\n leakage first, and ask for the user to confirm. For example, the service could:</p>\n\n<p> <ol>\n   <li>Create a dataset that requires\n       authentication to\n       unlock.\n   <li>Include the web domain in the custom presentation for the\n       AutofillValue, android.widget.RemoteViews)\n       dataset value.\n   <li>When the user selects that dataset, show a disclaimer dialog explaining that the app is\n       requesting credentials for a web domain, but the service could not verify if the app owns\n       that domain. If the user agrees, then the service can unlock the dataset.\n   <li>Similarly, when adding a <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> object for the request, the service should\n       include the above disclaimer in the android.service.autofill.SaveInfo.Builder.setDescription(CharSequence).\n </li></li></li></li></ol></p>\n\n<p> <p>This same procedure could also be used when the autofillable data is contained inside an\n {@code IFRAME}, in which case the WebView generates a new autofill context when a node inside\n the {@code IFRAME} is focused, with the root node containing the {@code IFRAME}'s {@code src}\n attribute on android.app.assist.AssistStructure.ViewNode.getWebDomain(). A typical and\n legitimate use case for this scenario is a financial app that allows the user\n to login on different bank accounts. For example, a financial app {@code my_financial_app} could\n use a WebView that loads contents from {@code banklogin.my_financial_app.com}, which contains an\n {@code IFRAME} node whose {@code src} attribute is {@code login.some_bank.com}. When fulfilling\n that request, the service could add an\n authenticated dataset\n whose presentation displays \"Username for some_bank.com\" and\n \"Password for some_bank.com\". Then when the user taps one of these options, the service\n shows the disclaimer dialog explaining that selecting that option would release the\n {@code login.some_bank.com} credentials to the {@code my_financial_app}; if the user agrees,\n then the service returns an unlocked dataset with the {@code some_bank.com} credentials.</p>\n\n<p> <p><b>Note:</b> The autofill service could also whitelist well-known browser apps and skip the\n verifications above, as long as the service can verify the authenticity of the browser app by\n checking its signing certificate.</p>\n\n<p> <a name=\"MultipleStepsSave\"></a>\n <h3>Saving when data is split in multiple screens</h3></p>\n\n<p> Apps often split the user data in multiple screens in the same activity, specially in\n activities used to create a new user account. For example, the first screen asks for a username,\n and if the username is available, it moves to a second screen, which asks for a password.</p>\n\n<p> <p>It's tricky to handle save for autofill in these situations, because the autofill service must\n wait until the user enters both fields before the autofill save UI can be shown. But it can be\n done by following the steps below:</p>\n\n<p> <ol>\n <li>In the first\n CancellationSignal, android.service.autofill.FillCallback) fill request, the service\n adds a client state bundle in\n the response, containing the autofill ids of the partial fields present in the screen.\n <li>In the second\n CancellationSignal, android.service.autofill.FillCallback) fill request, the service\n retrieves the client state bundle, gets the autofill ids\n set in the previous request from the client state, and adds these ids and the\n <a href=\"#!/api/android.service.autofill.SaveInfo-property-FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE\" rel=\"android.service.autofill.SaveInfo-property-FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE\" class=\"docClass\">android.service.autofill.SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE</a> to the <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> used in the second\n response.\n <li>In the android.service.autofill.SaveCallback) save request, the service uses the\n proper <a href=\"#!/api/android.service.autofill.FillContext\" rel=\"android.service.autofill.FillContext\" class=\"docClass\">fill contexts</a> to get the value of each field (there is one fill\n context per fill request).\n </li></li></li></ol></p>\n\n<p> <p>For example, in an app that uses 2 steps for the username and password fields, the workflow\n would be:\n <pre class=\"prettyprint\">\n  // On first fill request\n  AutofillId usernameId = // parse from AssistStructure;\n  Bundle clientState = new Bundle();\n  clientState.putParcelable(\"usernameId\", usernameId);\n  fillCallback.onSuccess(\n    new FillResponse.Builder()\n        .setClientState(clientState)\n        .setSaveInfo(new SaveInfo\n             .Builder(SaveInfo.SAVE_DATA_TYPE_USERNAME, new AutofillId[] {usernameId})\n             .build())\n        .build());</pre></p>\n\n<p>  // On second fill request\n  Bundle clientState = fillRequest.getClientState();\n  AutofillId usernameId = clientState.getParcelable(\"usernameId\");\n  AutofillId passwordId = // parse from AssistStructure\n  clientState.putParcelable(\"passwordId\", passwordId);\n  fillCallback.onSuccess(\n    new FillResponse.Builder()\n        .setClientState(clientState)\n        .setSaveInfo(new SaveInfo\n             .Builder(SaveInfo.SAVE_DATA_TYPE_USERNAME | SaveInfo.SAVE_DATA_TYPE_PASSWORD,\n                      new AutofillId[] {usernameId, passwordId})\n             .setFlags(SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE)\n             .build())\n        .build());</p>\n\n<p>  // On save request\n  Bundle clientState = saveRequest.getClientState();\n  AutofillId usernameId = clientState.getParcelable(\"usernameId\");\n  AutofillId passwordId = clientState.getParcelable(\"passwordId\");\n  List<FillContext> fillContexts = saveRequest.getFillContexts();</FillContext></p>\n\n<p>  FillContext usernameContext = fillContexts.get(0);\n  ViewNode usernameNode = findNodeByAutofillId(usernameContext.getStructure(), usernameId);\n  AutofillValue username = usernameNode.getAutofillValue().getTextValue().toString();</p>\n\n<p>  FillContext passwordContext = fillContexts.get(1);\n  ViewNode passwordNode = findNodeByAutofillId(passwordContext.getStructure(), passwordId);\n  AutofillValue password = passwordNode.getAutofillValue().getTextValue().toString();</p>\n\n<p>  save(username, password);\n  </p>\n\n<p> <a name=\"Privacy\"></a>\n <h3>Privacy</h3></p>\n\n<p> <p>The CancellationSignal, android.service.autofill.FillCallback) method is called\n without the user content. The Android system strips some properties of the\n view nodes passed to this call, but not all\n of them. For example, the data provided in the android.view.ViewStructure.HtmlInfo\n objects set by android.webkit.WebView is never stripped out.</p>\n\n<p> <p>Because this data could contain PII (Personally Identifiable Information, such as username or\n email address), the service should only use it locally (i.e., in the app's process) for\n heuristics purposes, but it should not be sent to external servers.</p>\n\n<p> <a name=\"FieldClassification\"></a>\n <h3>Metrics and field classification&lt;/h3</h3></p>\n\n<p> <p>The service can call <a href=\"#!/api/android.service.autofill.AutofillService-method-getFillEventHistory\" rel=\"android.service.autofill.AutofillService-method-getFillEventHistory\" class=\"docClass\">getFillEventHistory</a>() to get metrics representing the user\n actions, and then use these metrics to improve its heuristics.</p>\n\n<p> <p>Prior to Android android.os.Build.VERSION_CODES.P, the metrics covered just the\n scenarios where the service knew how to autofill an activity, but Android\n android.os.Build.VERSION_CODES.P introduced a new mechanism called field classification,\n which allows the service to dinamically classify the meaning of fields based on the existing user\n data known by the service.</p>\n\n<p> <p>Typically, field classification can be used to detect fields that can be autofilled with\n user data that is not associated with a specific app&mdash;such as email and physical\n address. Once the service identifies that a such field was manually filled by the user, the\n service could use this signal to improve its heuristics on subsequent requests (for example, by\n infering which resource ids are associated with known fields).</p>\n\n<p> <p>The field classification workflow involves 4 steps:</p>\n\n<p> <ol>\n   <li>Set the user data through AutofillManager.setUserData(UserData). This data is\n   cached until the system restarts (or the service is disabled), so it doesn't need to be set for\n   all requests.\n   <li>Identify which fields should be analysed by calling\n   android.service.autofill.FillResponse.Builder.setFieldClassificationIds(AutofillId...).\n   <li>Verify the results through android.service.autofill.FillEventHistory.Event.getFieldsClassification().\n   <li>Use the results to dynamically create <a href=\"#!/api/android.service.autofill.Dataset\" rel=\"android.service.autofill.Dataset\" class=\"docClass\">android.service.autofill.Dataset</a> or <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> objects in\n   subsequent requests.\n </li></li></li></li></ol></p>\n\n<p> <p>The field classification is an expensive operation and should be used carefully, otherwise it\n can reach its rate limit and get blocked by the Android System. Ideally, it should be used just\n in cases where the service could not determine how an activity can be autofilled, but it has a\n strong suspicious that it could. For example, if an activity has four or more fields and one of\n them is a list, chances are that these are address fields (like address, city, state, and\n zip code).</p>\n\n<p> <a name=\"CompatibilityMode\"></a>\n <h3>Compatibility mode</h3></p>\n\n<p> <p>Apps that use standard Android widgets support autofill out-of-the-box and need to do\n very little to improve their user experience (annotating autofillable views and providing\n autofill hints). However, some apps (typically browsers) do their own rendering and the rendered\n content may contain semantic structure that needs to be surfaced to the autofill framework. The\n platform exposes APIs to achieve this, however it could take some time until these apps implement\n autofill support.</p>\n\n<p> <p>To enable autofill for such apps the platform provides a compatibility mode in which the\n platform would fall back to the accessibility APIs to generate the state reported to autofill\n services and fill data. This mode needs to be explicitly requested for a given package up\n to a specified max version code allowing clean migration path when the target app begins to\n support autofill natively. Note that enabling compatibility may degrade performance for the\n target package and should be used with caution. The platform supports whitelisting which packages\n can be targeted in compatibility mode to ensure this mode is used only when needed and as long\n as needed.</p>\n\n<p> <p>You can request compatibility mode for packages of interest in the meta-data resource\n associated with your service. Below is a sample service declaration:</p>\n\n<p> <pre> &lt;service android:name=\".MyAutofillService\"\n              android:permission=\"android.permission.BIND_AUTOFILL_SERVICE\"&gt;\n     &lt;intent-filter&gt;\n         &lt;action android:name=\"<a href=\"#!/api/android.service.autofill.AutofillService\" rel=\"android.service.autofill.AutofillService\" class=\"docClass\">android.service.autofill.AutofillService</a>\" /&gt;\n     &lt;/intent-filter&gt;\n     &lt;meta-data android:name=\"android.autofill\" android:resource=\"@xml/autofillservice\" /&gt;\n &lt;/service&gt;</pre></p>\n\n<p> <p>In the XML file you can specify one or more packages for which to enable compatibility\n mode. Below is a sample meta-data declaration:</p>\n\n<p> <pre> &lt;autofill-service xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n     &lt;compatibility-package android:name=\"foo.bar.baz\" android:maxLongVersionCode=\"1000000000\"/&gt;\n &lt;/autofill-service&gt;</pre></p>\n\n<p> <p>Notice that compatibility mode has limitations such as:\n <ul>\n <li>No manual autofill requests. Hence, the <a href=\"#!/api/android.service.autofill.FillRequest\" rel=\"android.service.autofill.FillRequest\" class=\"docClass\">android.service.autofill.FillRequest</a>\n flags never have the <a href=\"#!/api/android.service.autofill.FillRequest-property-FLAG_MANUAL_REQUEST\" rel=\"android.service.autofill.FillRequest-property-FLAG_MANUAL_REQUEST\" class=\"docClass\">android.service.autofill.FillRequest.FLAG_MANUAL_REQUEST</a> flag.\n <li>The value of password fields are most likely masked&mdash;for example, {@code ****} instead\n of {@code 1234}. Hence, you must be careful when using these values to avoid updating the user\n data with invalid input. For example, when you parse the <a href=\"#!/api/android.service.autofill.FillRequest\" rel=\"android.service.autofill.FillRequest\" class=\"docClass\">android.service.autofill.FillRequest</a> and detect a\n password field, you could check if its\n input type has password flags and if so, don't add it to the <a href=\"#!/api/android.service.autofill.SaveInfo\" rel=\"android.service.autofill.SaveInfo\" class=\"docClass\">android.service.autofill.SaveInfo</a> object.\n <li>The autofill context is not always committed when an HTML\n form is submitted. Hence, you must use other mechanisms to trigger save, such as setting the\n <a href=\"#!/api/android.service.autofill.SaveInfo-property-FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE\" rel=\"android.service.autofill.SaveInfo-property-FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE\" class=\"docClass\">android.service.autofill.SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE</a> flag on android.service.autofill.SaveInfo.Builder.setFlags(int)\n or using android.service.autofill.SaveInfo.Builder.setTriggerId(AutofillId).\n <li>Browsers often provide their own autofill management system. When both the browser and\n the platform render an autofill dialog at the same time, the result can be confusing to the user.\n Such browsers typically offer an option for users to disable autofill, so your service should\n also allow users to disable compatiblity mode for specific apps. That way, it is up to the user\n to decide which autofill mechanism&mdash;the browser's or the platform's&mdash;should be used.\n </li></li></li></li></ul></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-SERVICE_INTERFACE' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-property-SERVICE_INTERFACE' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-property-SERVICE_INTERFACE' class='name expandable'>SERVICE_INTERFACE</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The Intent that must be declared as handled by the service. ...</div><div class='long'><p>The Intent that must be declared as handled by the service.\nTo be supported, the service must also require the\nandroid.Manifest.permission.BIND_AUTOFILL_SERVICE permission so\nthat other applications can not abuse it.</p>\n<p>Defaults to: <code>&quot;android.service.autofill.AutofillService&quot;</code></p></div></div></div><div id='property-SERVICE_META_DATA' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-property-SERVICE_META_DATA' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-property-SERVICE_META_DATA' class='name expandable'>SERVICE_META_DATA</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Name under which a AutoFillService component publishes information about itself. ...</div><div class='long'><p>Name under which a AutoFillService component publishes information about itself.\nThis meta-data should reference an XML resource containing a\n<code>&lt;autofill-service&gt;</code> tag.\nThis is a a sample XML file configuring an AutoFillService:</p>\n\n<pre> &lt;autofill-service\n    android:settingsActivity=\"foo.bar.SettingsActivity\"\n    . . .\n/&gt;</pre>\n\n<p>Defaults to: <code>&quot;android.autofill&quot;</code></p></div></div></div></div></div><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-getFillEventHistory' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-getFillEventHistory' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-getFillEventHistory' class='name expandable'>getFillEventHistory</a>( <span class='pre'></span> ) : Object {android.service.autofill.FillEventHistory}<span class=\"signature\"></span></div><div class='description'><div class='short'>Gets the events that happened after the last\n android.os.CancellationSignal, FillCallback)\n call. ...</div><div class='long'><p>Gets the events that happened after the last\n android.os.CancellationSignal, FillCallback)\n call.</p>\n\n<p> <p>This method is typically used to keep track of previous user actions to optimize further\n requests. For example, the service might return email addresses in alphabetical order by\n default, but change that order based on the address the user picked on previous requests.</p>\n\n<p> <p>The history is not persisted over reboots, and it's cleared every time the service\n replies to a CancellationSignal, android.service.autofill.FillCallback) by calling\n android.service.autofill.FillCallback.onSuccess(FillResponse) or android.service.autofill.FillCallback.onFailure(CharSequence)\n (if the service doesn't call any of these methods, the history will clear out after some\n pre-defined time). Hence, the service should call <a href=\"#!/api/android.service.autofill.AutofillService-method-getFillEventHistory\" rel=\"android.service.autofill.AutofillService-method-getFillEventHistory\" class=\"docClass\">getFillEventHistory</a>() before\n finishing the <a href=\"#!/api/android.service.autofill.FillCallback\" rel=\"android.service.autofill.FillCallback\" class=\"docClass\">android.service.autofill.FillCallback</a>.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {android.service.autofill.FillEventHistory}</span><div class='sub-desc'><p>The history or {@code null} if there are no events.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>RuntimeException if the event history could not be retrieved.</p>\n</div></li></ul></div></div></div><div id='method-onBind' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-onBind' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-onBind' class='name expandable'>onBind</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div><div id='method-onConnected' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-onConnected' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-onConnected' class='name expandable'>onConnected</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Called when the Android system connects to service. ...</div><div class='long'><p>Called when the Android system connects to service.</p>\n\n<p> <p>You should generally do initialization here rather than in <a href=\"#!/api/android.service.autofill.AutofillService-method-onCreate\" rel=\"android.service.autofill.AutofillService-method-onCreate\" class=\"docClass\">onCreate</a>.</p>\n</div></div></div><div id='method-onCreate' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-onCreate' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-onCreate' class='name expandable'>onCreate</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div><div id='method-onDisconnected' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-onDisconnected' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-onDisconnected' class='name expandable'>onDisconnected</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Called when the Android system disconnects from the service. ...</div><div class='long'><p>Called when the Android system disconnects from the service.</p>\n\n<p> <p> At this point this service may no longer be an active <a href=\"#!/api/android.service.autofill.AutofillService\" rel=\"android.service.autofill.AutofillService\" class=\"docClass\">android.service.autofill.AutofillService</a>.\n It should not make calls on AutofillManager that requires the caller to be\n the current service.</p>\n</div></div></div><div id='method-onFillRequest' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-onFillRequest' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-onFillRequest' class='name expandable'>onFillRequest</a>( <span class='pre'>request, cancellationSignal, callback</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Called by the Android system do decide if a screen can be autofilled by the service. ...</div><div class='long'><p>Called by the Android system do decide if a screen can be autofilled by the service.</p>\n\n<p> <p>Service must call one of the <a href=\"#!/api/android.service.autofill.FillCallback\" rel=\"android.service.autofill.FillCallback\" class=\"docClass\">android.service.autofill.FillCallback</a> methods (like\n android.service.autofill.FillCallback.onSuccess(FillResponse)\n or android.service.autofill.FillCallback.onFailure(CharSequence))\n to notify the result of the request.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>request</span> : Object {FillRequest}<div class='sub-desc'><p>the request to handle.\n        See FillResponse for examples of multiple-sections requests.</p>\n</div></li><li><span class='pre'>cancellationSignal</span> : Object {CancellationSignal}<div class='sub-desc'><p>signal for observing cancellation requests. The system will use\n     this to notify you that the fill result is no longer needed and you should stop\n     handling this fill request in order to save resources.</p>\n</div></li><li><span class='pre'>callback</span> : Object {FillCallback}<div class='sub-desc'><p>object used to notify the result of the request.</p>\n</div></li></ul></div></div></div><div id='method-onSaveRequest' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.service.autofill.AutofillService'>android.service.autofill.AutofillService</span><br/><a href='source/AutofillService.html#android-service-autofill-AutofillService-method-onSaveRequest' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.service.autofill.AutofillService-method-onSaveRequest' class='name expandable'>onSaveRequest</a>( <span class='pre'>request, callback</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Called when the user requests the service to save the contents of a screen. ...</div><div class='long'><p>Called when the user requests the service to save the contents of a screen.</p>\n\n<p> <p>If the service could not handle the request right away&mdash;for example, because it must\n launch an activity asking the user to authenticate first or because the network is\n down&mdash;the service could keep the <a href=\"#!/api/android.service.autofill.SaveRequest\" rel=\"android.service.autofill.SaveRequest\" class=\"docClass\">request</a> and reuse it later,\n but the service <b>must always</b> call android.service.autofill.SaveCallback.onSuccess() or\n android.service.autofill.SaveCallback.onSuccess(android.content.IntentSender) right away.</p>\n\n<p> <p><b>Note:</b> To retrieve the actual value of fields input by the user, the service\n should call\n android.app.assist.AssistStructure.ViewNode.getAutofillValue(); if it calls\n android.app.assist.AssistStructure.ViewNode.getText() or other methods, there is no\n guarantee such method will return the most recent value of the field.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>request</span> : Object {SaveRequest}<div class='sub-desc'><p>the request to handle.\n        See FillResponse for examples of multiple-sections requests.</p>\n</div></li><li><span class='pre'>callback</span> : Object {SaveCallback}<div class='sub-desc'><p>object used to notify the result of the request.</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});