<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-security-cert-Certificate'>/**@class java.security.cert.Certificate
</span> implements java.io.Serializable

@extends java.lang.Object

 &lt;p&gt;Abstract class for managing a variety of identity certificates.
 An identity certificate is a binding of a principal to a public key which
 is vouched for by another principal.  (A principal represents
 an entity such as an individual user, a group, or a corporation.)
&lt;p&gt;
 This class is an abstraction for certificates that have different
 formats but important common uses.  For example, different types of
 certificates, such as X.509 and PGP, share general certificate
 functionality (like encoding and verifying) and
 some types of information (like a public key).
 &lt;p&gt;
 X.509, PGP, and SDSI certificates can all be implemented by
 subclassing the Certificate class, even though they contain different
 sets of information, and they store and retrieve the information in
 different ways.

 @see X509Certificate
 @see CertificateFactory

 @author Hemma Prafullchandra
*/
var Certificate = {

<span id='java-security-cert-Certificate-method-getType'>/**Returns the type of this certificate.
</span>@return {String} the type of this certificate.
*/
getType : function(  ) {},

<span id='java-security-cert-Certificate-method-equals'>/**Compares this certificate for equality with the specified
</span> object. If the {@code other} object is an
 {@code instanceof} {@code Certificate}, then
 its encoded form is retrieved and compared with the
 encoded form of this certificate.
@param {Object {Object}} other the object to test for equality with this certificate.
@return {Boolean} true iff the encoded forms of the two certificates
 match, false otherwise.
*/
equals : function(  ) {},

<span id='java-security-cert-Certificate-method-hashCode'>/**Returns a hashcode value for this certificate from its
</span> encoded form.
@return {Number} the hashcode value.
*/
hashCode : function(  ) {},

<span id='java-security-cert-Certificate-method-getEncoded'>/**Returns the encoded form of this certificate. It is
</span> assumed that each certificate type would have only a single
 form of encoding; for example, X.509 certificates would
 be encoded as ASN.1 DER.
@return {Number} the encoded form of this certificate
@exception CertificateEncodingException if an encoding error occurs.
*/
getEncoded : function(  ) {},

<span id='java-security-cert-Certificate-method-verify'>/**Verifies that this certificate was signed using the
</span> private key that corresponds to the specified public key.
@param {Object {PublicKey}} key the PublicKey used to carry out the verification.
@exception NoSuchAlgorithmException on unsupported signature
 algorithms.
@exception InvalidKeyException on incorrect key.
@exception NoSuchProviderException if there's no default provider.
@exception SignatureException on signature errors.
@exception CertificateException on encoding errors.
*/
verify : function(  ) {},

<span id='java-security-cert-Certificate-method-verify'>/**Verifies that this certificate was signed using the
</span> private key that corresponds to the specified public key.
 This method uses the signature verification engine
 supplied by the specified provider.
@param {Object {PublicKey}} key the PublicKey used to carry out the verification.
@param {String} sigProvider the name of the signature provider.
@exception NoSuchAlgorithmException on unsupported signature
 algorithms.
@exception InvalidKeyException on incorrect key.
@exception NoSuchProviderException on incorrect provider.
@exception SignatureException on signature errors.
@exception CertificateException on encoding errors.
*/
verify : function(  ) {},

<span id='java-security-cert-Certificate-method-verify'>/**Verifies that this certificate was signed using the
</span> private key that corresponds to the specified public key.
 This method uses the signature verification engine
 supplied by the specified provider. Note that the specified
 Provider object does not have to be registered in the provider list.

 &lt;p&gt; This method was added to version 1.8 of the Java Platform
 Standard Edition. In order to maintain backwards compatibility with
 existing service providers, this method cannot be {@code abstract}
 and by default throws an {@code UnsupportedOperationException}.
@param {Object {PublicKey}} key the PublicKey used to carry out the verification.
@param {Object {Provider}} sigProvider the signature provider.
@exception NoSuchAlgorithmException on unsupported signature
 algorithms.
@exception InvalidKeyException on incorrect key.
@exception SignatureException on signature errors.
@exception CertificateException on encoding errors.
@exception UnsupportedOperationException if the method is not supported
@since 1.8
*/
verify : function(  ) {},

<span id='java-security-cert-Certificate-method-toString'>/**Returns a string representation of this certificate.
</span>@return {String} a string representation of this certificate.
*/
toString : function(  ) {},

<span id='java-security-cert-Certificate-method-getPublicKey'>/**Gets the public key from this certificate.
</span>@return {Object {java.security.PublicKey}} the public key.
*/
getPublicKey : function(  ) {},


};</pre>
</body>
</html>
