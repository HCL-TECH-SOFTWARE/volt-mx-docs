<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-app-NotificationManager'>/**@class android.app.NotificationManager
</span>@extends java.lang.Object

 Class to notify the user of events that happen.  This is how you tell
 the user that something has happened in the background. {@more}

 Notifications can take different forms:
 &lt;ul&gt;
      &lt;li&gt;A persistent icon that goes in the status bar and is accessible
          through the launcher, (when the user selects it, a designated Intent
          can be launched),&lt;/li&gt;
      &lt;li&gt;Turning on or flashing LEDs on the device, or&lt;/li&gt;
      &lt;li&gt;Alerting the user by flashing the backlight, playing a sound,
          or vibrating.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;
 Each of the notify methods takes an int id parameter and optionally a
 {@link String} tag parameter, which may be {@code null}.  These parameters
 are used to form a pair (tag, id), or ({@code null}, id) if tag is
 unspecified.  This pair identifies this notification from your app to the
 system, so that pair should be unique within your app.  If you call one
 of the notify methods with a (tag, id) pair that is currently active and
 a new set of notification parameters, it will be updated.  For example,
 if you pass a new status bar icon, the old icon in the status bar will
 be replaced with the new one.  This is also the same tag and id you pass
 to the {@link #cancel}(int) or {@link #cancel(String, int)} method to clear
 this notification.

 &lt;div class=&quot;special reference&quot;&gt;
 &lt;h3&gt;Developer Guides&lt;/h3&gt;
 &lt;p&gt;For a guide to creating notifications, read the
 &lt;a href=&quot;{@docRoot}guide/topics/ui/notifiers/notifications.html&quot;&gt;Status Bar Notifications&lt;/a&gt;
 developer guide.&lt;/p&gt;
 &lt;/div&gt;

 @see android.app.Notification
*/
var NotificationManager = {

<span id='android-app-NotificationManager-property-ACTION_APP_BLOCK_STATE_CHANGED'>/** Intent that is broadcast when an application is blocked or unblocked.
</span>
 This broadcast is only sent to the app whose block state has changed.

 Input: nothing
 Output: {@link #EXTRA_BLOCKED_STATE}
*/
ACTION_APP_BLOCK_STATE_CHANGED : &quot;android.app.action.APP_BLOCK_STATE_CHANGED&quot;,
<span id='android-app-NotificationManager-property-ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED'>/** Intent that is broadcast when a {@link android.app.NotificationChannel} is blocked
</span> (when {@link android.app.NotificationChannel#getImportance()} is {@link #IMPORTANCE_NONE}) or unblocked
 (when {@link android.app.NotificationChannel#getImportance()} is anything other than
 {@link #IMPORTANCE_NONE}).

 This broadcast is only sent to the app that owns the channel that has changed.

 Input: nothing
 Output: {@link #EXTRA_NOTIFICATION_CHANNEL_ID}
 Output: {@link #EXTRA_BLOCKED_STATE}
*/
ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED : &quot;android.app.action.NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED&quot;,
<span id='android-app-NotificationManager-property-EXTRA_NOTIFICATION_CHANNEL_ID'>/** Extra for {@link #ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED} containing the id of the
</span> {@link android.app.NotificationChannel} which has a new blocked state.

 The value will be the {@link android.app.NotificationChannel#getId()} of the channel.
*/
EXTRA_NOTIFICATION_CHANNEL_ID : &quot;android.app.extra.NOTIFICATION_CHANNEL_ID&quot;,
<span id='android-app-NotificationManager-property-EXTRA_NOTIFICATION_CHANNEL_GROUP_ID'>/** Extra for {@link #ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED} containing the id
</span> of the {@link android.app.NotificationChannelGroup} which has a new blocked state.

 The value will be the {@link android.app.NotificationChannelGroup#getId()} of the group.
*/
EXTRA_NOTIFICATION_CHANNEL_GROUP_ID : &quot;android.app.extra.NOTIFICATION_CHANNEL_GROUP_ID&quot;,
<span id='android-app-NotificationManager-property-EXTRA_BLOCKED_STATE'>/** Extra for {@link #ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED} or
</span> {@link #ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED} containing the new blocked
 state as a boolean.

 The value will be {@code true} if this channel or group is now blocked and {@code false} if
 this channel or group is now unblocked.
*/
EXTRA_BLOCKED_STATE : &quot;android.app.extra.BLOCKED_STATE&quot;,
<span id='android-app-NotificationManager-property-ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED'>/** Intent that is broadcast when a {@link android.app.NotificationChannelGroup} is
</span> {@link android.app.NotificationChannelGroup#isBlocked() blocked} or unblocked.

 This broadcast is only sent to the app that owns the channel group that has changed.

 Input: nothing
 Output: {@link #EXTRA_NOTIFICATION_CHANNEL_GROUP_ID}
 Output: {@link #EXTRA_BLOCKED_STATE}
*/
ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED : &quot;android.app.action.NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED&quot;,
<span id='android-app-NotificationManager-property-ACTION_EFFECTS_SUPPRESSOR_CHANGED'>/** Intent that is broadcast when the state of {@link #getEffectsSuppressor}() changes.
</span> This broadcast is only sent to registered receivers.

 @hide
*/
ACTION_EFFECTS_SUPPRESSOR_CHANGED : &quot;android.os.action.ACTION_EFFECTS_SUPPRESSOR_CHANGED&quot;,
<span id='android-app-NotificationManager-property-ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED'>/** Intent that is broadcast when the state of {@link #isNotificationPolicyAccessGranted}()
</span> changes.

 This broadcast is only sent to registered receivers, and only to the apps that have changed.
*/
ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED : &quot;android.app.action.NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED&quot;,
<span id='android-app-NotificationManager-property-ACTION_NOTIFICATION_POLICY_CHANGED'>/** Intent that is broadcast when the state of getNotificationPolicy() changes.
</span> This broadcast is only sent to registered receivers.
*/
ACTION_NOTIFICATION_POLICY_CHANGED : &quot;android.app.action.NOTIFICATION_POLICY_CHANGED&quot;,
<span id='android-app-NotificationManager-property-ACTION_INTERRUPTION_FILTER_CHANGED'>/** Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.
</span> This broadcast is only sent to registered receivers.
*/
ACTION_INTERRUPTION_FILTER_CHANGED : &quot;android.app.action.INTERRUPTION_FILTER_CHANGED&quot;,
<span id='android-app-NotificationManager-property-ACTION_INTERRUPTION_FILTER_CHANGED_INTERNAL'>/** Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.
</span> @hide
*/
ACTION_INTERRUPTION_FILTER_CHANGED_INTERNAL : &quot;android.app.action.INTERRUPTION_FILTER_CHANGED_INTERNAL&quot;,
<span id='android-app-NotificationManager-property-INTERRUPTION_FILTER_ALL'>/** {@link #getCurrentInterruptionFilter() Interruption filter} constant -
</span>     Normal interruption filter - no notifications are suppressed.
*/
INTERRUPTION_FILTER_ALL : &quot;1&quot;,
<span id='android-app-NotificationManager-property-INTERRUPTION_FILTER_PRIORITY'>/** {@link #getCurrentInterruptionFilter() Interruption filter} constant -
</span>     Priority interruption filter - all notifications are suppressed except those that match
     the priority criteria. Some audio streams are muted. See
     {@link android.app.NotificationManager.Policy#priorityCallSenders}, {@link android.app.NotificationManager.Policy#priorityCategories},
     {@link android.app.NotificationManager.Policy#priorityMessageSenders} to define or query this criteria. Users can
     additionally specify packages that can bypass this interruption filter.
*/
INTERRUPTION_FILTER_PRIORITY : &quot;2&quot;,
<span id='android-app-NotificationManager-property-INTERRUPTION_FILTER_NONE'>/** {@link #getCurrentInterruptionFilter() Interruption filter} constant -
</span>     No interruptions filter - all notifications are suppressed and all audio streams (except
     those used for phone calls) and vibrations are muted.
*/
INTERRUPTION_FILTER_NONE : &quot;3&quot;,
<span id='android-app-NotificationManager-property-INTERRUPTION_FILTER_ALARMS'>/** {@link #getCurrentInterruptionFilter() Interruption filter} constant -
</span>     Alarms only interruption filter - all notifications except those of category
     {@link android.app.Notification#CATEGORY_ALARM} are suppressed. Some audio streams are muted.
*/
INTERRUPTION_FILTER_ALARMS : &quot;4&quot;,
<span id='android-app-NotificationManager-property-INTERRUPTION_FILTER_UNKNOWN'>/**{@link #getCurrentInterruptionFilter() Interruption filter} constant - returned when
</span> the value is unavailable for any reason.
*/
INTERRUPTION_FILTER_UNKNOWN : &quot;0&quot;,
<span id='android-app-NotificationManager-property-ACTION_AUTOMATIC_ZEN_RULE'>/** Activity Action: Launch an Automatic Zen Rule configuration screen
</span> &lt;p&gt;
 Input: Optionally, {@link #EXTRA_AUTOMATIC_RULE_ID}, if the configuration screen for an
 existing rule should be displayed. If the rule id is missing or null, apps should display
 a configuration screen where users can create a new instance of the rule.
 &lt;p&gt;
 Output: Nothing
 &lt;p&gt;
     You can have multiple activities handling this intent, if you support multiple
     {@link android.app.AutomaticZenRule rules}. In order for the system to properly display all of your
     rule types so that users can create new instances or configure existing ones, you need
     to add some extra metadata ({@link #META_DATA_AUTOMATIC_RULE_TYPE})
     to your activity tag in your manifest. If you'd like to limit the number of rules a user
     can create from this flow, you can additionally optionally include
     {@link #META_DATA_RULE_INSTANCE_LIMIT}.

     For example,
     &amp;lt;meta-data
         android:name=&quot;android.app.zen.automatic.ruleType&quot;
         android:value=&quot;@string/my_condition_rule&quot;&gt;
     &amp;lt;/meta-data&gt;
     &amp;lt;meta-data
         android:name=&quot;android.app.zen.automatic.ruleInstanceLimit&quot;
         android:value=&quot;1&quot;&gt;
     &amp;lt;/meta-data&gt;
 &lt;/p&gt;
 &lt;/p&gt;

 @see {@link #addAutomaticZenRule}(AutomaticZenRule)
*/
ACTION_AUTOMATIC_ZEN_RULE : &quot;android.app.action.AUTOMATIC_ZEN_RULE&quot;,
<span id='android-app-NotificationManager-property-EXTRA_AUTOMATIC_RULE_ID'>/** Used as an optional string extra on {@link #ACTION_AUTOMATIC_ZEN_RULE} intents. If
</span> provided, contains the id of the {@link android.app.AutomaticZenRule} (as returned from
 {@link android.app.NotificationManager#addAutomaticZenRule(AutomaticZenRule)}) for which configuration
 settings should be displayed.
*/
EXTRA_AUTOMATIC_RULE_ID : &quot;android.app.extra.AUTOMATIC_RULE_ID&quot;,
<span id='android-app-NotificationManager-property-META_DATA_AUTOMATIC_RULE_TYPE'>/** A required {@code meta-data} tag for activities that handle
</span> {@link #ACTION_AUTOMATIC_ZEN_RULE}.

 This tag should contain a localized name of the type of the zen rule provided by the
 activity.
*/
META_DATA_AUTOMATIC_RULE_TYPE : &quot;android.service.zen.automatic.ruleType&quot;,
<span id='android-app-NotificationManager-property-META_DATA_RULE_INSTANCE_LIMIT'>/** An optional {@code meta-data} tag for activities that handle
</span> {@link #ACTION_AUTOMATIC_ZEN_RULE}.

 This tag should contain the maximum number of rule instances that
 can be created for this rule type. Omit or enter a value &lt;= 0 to allow unlimited instances.
*/
META_DATA_RULE_INSTANCE_LIMIT : &quot;android.service.zen.automatic.ruleInstanceLimit&quot;,
<span id='android-app-NotificationManager-property-VISIBILITY_NO_OVERRIDE'>/**Value signifying that the user has not expressed a per-app visibility override value.
</span> @hide */
VISIBILITY_NO_OVERRIDE : &quot;-1000&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_UNSPECIFIED'>/** Value signifying that the user has not expressed an importance.
</span>
 This value is for persisting preferences, and should never be associated with
 an actual notification.
*/
IMPORTANCE_UNSPECIFIED : &quot;-1000&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_NONE'>/** A notification with no importance: does not show in the shade.
</span>*/
IMPORTANCE_NONE : &quot;0&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_MIN'>/** Min notification importance: only shows in the shade, below the fold.  This should
</span> not be used with {@link Service#startForeground(int, android.app.Notification) Service.startForeground}
 since a foreground service is supposed to be something the user cares about so it does
 not make semantic sense to mark its notification as minimum importance.  If you do this
 as of Android version {@link android.os.Build.VERSION_CODES#O}, the system will show
 a higher-priority notification about your app running in the background.
*/
IMPORTANCE_MIN : &quot;1&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_LOW'>/** Low notification importance: Shows in the shade, and potentially in the status bar
</span> (see {@link #shouldHideSilentStatusBarIcons}()), but is not audibly intrusive.
*/
IMPORTANCE_LOW : &quot;2&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_DEFAULT'>/** Default notification importance: shows everywhere, makes noise, but does not visually
</span> intrude.
*/
IMPORTANCE_DEFAULT : &quot;3&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_HIGH'>/** Higher notification importance: shows everywhere, makes noise and peeks. May use full screen
</span> intents.
*/
IMPORTANCE_HIGH : &quot;4&quot;,
<span id='android-app-NotificationManager-property-IMPORTANCE_MAX'>/** Unused.
</span>*/
IMPORTANCE_MAX : &quot;5&quot;,
<span id='android-app-NotificationManager-method-getService'>/**
</span>@hide 
*/
getService : function(  ) {},

<span id='android-app-NotificationManager-method-from'>/**{@hide}
</span>*/
from : function(  ) {},

<span id='android-app-NotificationManager-method-notify'>/**Post a notification to be shown in the status bar. If a notification with
</span> the same id has already been posted by your application and has not yet been canceled, it
 will be replaced by the updated information.
@param {Number} id An identifier for this notification unique within your
        application.
@param {Object {Notification}} notification A {@link Notification} object describing what to show the user. Must not
        be null.
*/
notify : function(  ) {},

<span id='android-app-NotificationManager-method-notify'>/**Posts a notification to be shown in the status bar. If a notification with
</span> the same tag and id has already been posted by your application and has not yet been
 canceled, it will be replaced by the updated information.

 All {@link android.service.notification.NotificationListenerService listener services} will
 be granted {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} access to any {@link Uri uris}
 provided on this notification or the
 {@link android.app.NotificationChannel} this notification is posted to using
 {@link Context#grantUriPermission(String, Uri, int)}. Permission will be revoked when the
 notification is canceled, or you can revoke permissions with
 {@link Context#revokeUriPermission(Uri, int)}.
@param {String} tag A string identifier for this notification.  May be {@code null}.
@param {Number} id An identifier for this notification.  The pair (tag, id) must be unique
        within your application.
@param {Object {Notification}} notification A {@link Notification} object describing what to
        show the user. Must not be null.
*/
notify : function(  ) {},

<span id='android-app-NotificationManager-method-notifyAsPackage'>/**Posts a notification as a specified package to be shown in the status bar. If a notification
</span> with the same tag and id has already been posted for that package and has not yet been
 canceled, it will be replaced by the updated information.

 All {@link android.service.notification.NotificationListenerService listener services} will
 be granted {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} access to any {@link Uri uris}
 provided on this notification or the
 {@link android.app.NotificationChannel} this notification is posted to using
 {@link Context#grantUriPermission(String, Uri, int)}. Permission will be revoked when the
 notification is canceled, or you can revoke permissions with
 {@link Context#revokeUriPermission(Uri, int)}.
@param {String} targetPackage The package to post the notification as. The package must have granted
                      you access to post notifications on their behalf with
                      {@link #setNotificationDelegate(String)}.
@param {String} tag A string identifier for this notification.  May be {@code null}.
@param {Number} id An identifier for this notification.  The pair (tag, id) must be unique
        within your application.
@param {Object {Notification}} notification A {@link Notification} object describing what to
        show the user. Must not be null.
*/
notifyAsPackage : function(  ) {},

<span id='android-app-NotificationManager-method-notifyAsUser'>/**
</span>@hide 
*/
notifyAsUser : function(  ) {},

<span id='android-app-NotificationManager-method-cancel'>/**Cancel a previously shown notification.  If it's transient, the view
</span> will be hidden.  If it's persistent, it will be removed from the status
 bar.
*/
cancel : function(  ) {},

<span id='android-app-NotificationManager-method-cancel'>/**Cancel a previously shown notification.  If it's transient, the view
</span> will be hidden.  If it's persistent, it will be removed from the status
 bar.
*/
cancel : function(  ) {},

<span id='android-app-NotificationManager-method-cancelAsUser'>/**
</span>@hide 
*/
cancelAsUser : function(  ) {},

<span id='android-app-NotificationManager-method-cancelAll'>/**Cancel all previously shown notifications. See {@link #cancel} for the
</span> detailed behavior.
*/
cancelAll : function(  ) {},

<span id='android-app-NotificationManager-method-setNotificationDelegate'>/**Allows a package to post notifications on your behalf using
</span> {@link #notifyAsPackage(String, String, int, android.app.Notification)}.

 This can be used to allow persistent processes to post notifications based on messages
 received on your behalf from the cloud, without your process having to wake up.

 You can check if you have an allowed delegate with {@link #getNotificationDelegate}() and
 revoke your delegate by passing null to this method.
@param {String} delegate Package name of the app which can send notifications on your behalf.
*/
setNotificationDelegate : function(  ) {},

<span id='android-app-NotificationManager-method-getNotificationDelegate'>/**Returns the {@link #setNotificationDelegate(String) delegate} that can post notifications on
</span> your behalf, if there currently is one.
*/
getNotificationDelegate : function(  ) {},

<span id='android-app-NotificationManager-method-canNotifyAsPackage'>/**Returns whether you are allowed to post notifications on behalf of a given package, with
</span> {@link #notifyAsPackage(String, String, int, android.app.Notification)}.

 See {@link #setNotificationDelegate}(String).
*/
canNotifyAsPackage : function(  ) {},

<span id='android-app-NotificationManager-method-createNotificationChannelGroup'>/**Creates a group container for {@link android.app.NotificationChannel} objects.
</span>
 This can be used to rename an existing group.
 &lt;p&gt;
     Group information is only used for presentation, not for behavior. Groups are optional
     for channels, and you can have a mix of channels that belong to groups and channels
     that do not.
 &lt;/p&gt;
 &lt;p&gt;
     For example, if your application supports multiple accounts, and those accounts will
     have similar channels, you can create a group for each account with account specific
     labels instead of appending account information to each channel's label.
 &lt;/p&gt;
@param {Object {NotificationChannelGroup}} group The group to create
*/
createNotificationChannelGroup : function(  ) {},

<span id='android-app-NotificationManager-method-createNotificationChannelGroups'>/**Creates multiple notification channel groups.
</span>@param {Object {java.util.List}} groups The list of groups to create
*/
createNotificationChannelGroups : function(  ) {},

<span id='android-app-NotificationManager-method-createNotificationChannel'>/**Creates a notification channel that notifications can be posted to.
</span>
 This can also be used to restore a deleted channel and to update an existing channel's
 name, description, group, and/or importance.

 &lt;p&gt;The name and description should only be changed if the locale changes
 or in response to the user renaming this channel. For example, if a user has a channel
 named 'John Doe' that represents messages from a 'John Doe', and 'John Doe' changes his name
 to 'John Smith,' the channel can be renamed to match.

 &lt;p&gt;The importance of an existing channel will only be changed if the new importance is lower
 than the current value and the user has not altered any settings on this channel.

 &lt;p&gt;The group an existing channel will only be changed if the channel does not already
 belong to a group.

 All other fields are ignored for channels that already exist.
@param {Object {NotificationChannel}} channel  the channel to create.  Note that the created channel may differ from this
                 value. If the provided channel is malformed, a RemoteException will be
                 thrown.
*/
createNotificationChannel : function(  ) {},

<span id='android-app-NotificationManager-method-createNotificationChannels'>/**Creates multiple notification channels that different notifications can be posted to. See
</span> {@link #createNotificationChannel}(NotificationChannel).
@param {Object {java.util.List}} channels the list of channels to attempt to create.
*/
createNotificationChannels : function(  ) {},

<span id='android-app-NotificationManager-method-getNotificationChannel'>/**Returns the notification channel settings for a given channel id.
</span>
 &lt;p&gt;The channel must belong to your package, or to a package you are an approved notification
 delegate for (see {@link #canNotifyAsPackage}(String)), or it will not be returned. To query
 a channel as a notification delegate, call this method from a context created for that
 package (see {@link Context#createPackageContext(String, int)}).&lt;/p&gt;
*/
getNotificationChannel : function(  ) {},

<span id='android-app-NotificationManager-method-getNotificationChannels'>/**Returns all notification channels belonging to the calling package.
</span>
 &lt;p&gt;Approved notification delegates (see {@link #canNotifyAsPackage}(String)) can query
 notification channels belonging to packages they are the delegate for. To do so, call this
 method from a context created for that package (see
 {@link Context#createPackageContext(String, int)}).&lt;/p&gt;
*/
getNotificationChannels : function(  ) {},

<span id='android-app-NotificationManager-method-deleteNotificationChannel'>/**Deletes the given notification channel.
</span>
 &lt;p&gt;If you {@link #createNotificationChannel(NotificationChannel) create} a new channel with
 this same id, the deleted channel will be un-deleted with all of the same settings it
 had before it was deleted.
*/
deleteNotificationChannel : function(  ) {},

<span id='android-app-NotificationManager-method-getNotificationChannelGroup'>/**Returns the notification channel group settings for a given channel group id.
</span>
 The channel group must belong to your package, or null will be returned.
*/
getNotificationChannelGroup : function(  ) {},

<span id='android-app-NotificationManager-method-getNotificationChannelGroups'>/**Returns all notification channel groups belonging to the calling app.
</span>*/
getNotificationChannelGroups : function(  ) {},

<span id='android-app-NotificationManager-method-deleteNotificationChannelGroup'>/**Deletes the given notification channel group, and all notification channels that
</span> belong to it.
*/
deleteNotificationChannelGroup : function(  ) {},

<span id='android-app-NotificationManager-method-getEffectsSuppressor'>/**
</span>@hide 
*/
getEffectsSuppressor : function(  ) {},

<span id='android-app-NotificationManager-method-matchesCallFilter'>/**
</span>@hide 
*/
matchesCallFilter : function(  ) {},

<span id='android-app-NotificationManager-method-isSystemConditionProviderEnabled'>/**
</span>@hide 
*/
isSystemConditionProviderEnabled : function(  ) {},

<span id='android-app-NotificationManager-method-setZenMode'>/**
</span>@hide 
*/
setZenMode : function(  ) {},

<span id='android-app-NotificationManager-method-getZenMode'>/**
</span>@hide 
*/
getZenMode : function(  ) {},

<span id='android-app-NotificationManager-method-getZenModeConfig'>/**
</span>@hide 
*/
getZenModeConfig : function(  ) {},

<span id='android-app-NotificationManager-method-getConsolidatedNotificationPolicy'>/**
</span>@hide 
*/
getConsolidatedNotificationPolicy : function(  ) {},

<span id='android-app-NotificationManager-method-getRuleInstanceCount'>/**
</span>@hide 
*/
getRuleInstanceCount : function(  ) {},

<span id='android-app-NotificationManager-method-getAutomaticZenRules'>/**Returns AutomaticZenRules owned by the caller.
</span>
 &lt;p&gt;
 Throws a SecurityException if policy access is granted to this package.
 See {@link #isNotificationPolicyAccessGranted}.
*/
getAutomaticZenRules : function(  ) {},

<span id='android-app-NotificationManager-method-getAutomaticZenRule'>/**Returns the AutomaticZenRule with the given id, if it exists and the caller has access.
</span>
 &lt;p&gt;
 Throws a SecurityException if policy access is granted to this package.
 See {@link #isNotificationPolicyAccessGranted}.

 &lt;p&gt;
 Returns null if there are no zen rules that match the given id, or if the calling package
 doesn't own the matching rule. See {@link android.app.AutomaticZenRule#getOwner}.
*/
getAutomaticZenRule : function(  ) {},

<span id='android-app-NotificationManager-method-addAutomaticZenRule'>/**Creates the given zen rule.
</span>
 &lt;p&gt;
 Throws a SecurityException if policy access is granted to this package.
 See {@link #isNotificationPolicyAccessGranted}.
@param {Object {AutomaticZenRule}} automaticZenRule the rule to create.
@return {String} The id of the newly created rule; null if the rule could not be created.
*/
addAutomaticZenRule : function(  ) {},

<span id='android-app-NotificationManager-method-updateAutomaticZenRule'>/**Updates the given zen rule.
</span>
 &lt;p&gt;
 Throws a SecurityException if policy access is granted to this package.
 See {@link #isNotificationPolicyAccessGranted}.

 &lt;p&gt;
 Callers can only update rules that they own. See {@link android.app.AutomaticZenRule#getOwner}.
@param {String} id The id of the rule to update
@param {Object {AutomaticZenRule}} automaticZenRule the rule to update.
@return {Boolean} Whether the rule was successfully updated.
*/
updateAutomaticZenRule : function(  ) {},

<span id='android-app-NotificationManager-method-setAutomaticZenRuleState'>/**Informs the notification manager that the state of an {@link android.app.AutomaticZenRule} has changed.
</span> Use this method to put the system into Do Not Disturb mode or request that it exits Do Not
 Disturb mode. The calling app must own the provided {@link android.app.AutomaticZenRule}.
 &lt;p&gt;
     This method can be used in conjunction with or as a replacement to
     {@link android.service.notification.ConditionProviderService#notifyCondition(Condition)}.
 &lt;/p&gt;
@param {String} id The id of the rule whose state should change
@param {Object {Condition}} condition The new state of this rule
*/
setAutomaticZenRuleState : function(  ) {},

<span id='android-app-NotificationManager-method-removeAutomaticZenRule'>/**Deletes the automatic zen rule with the given id.
</span>
 &lt;p&gt;
 Throws a SecurityException if policy access is granted to this package.
 See {@link #isNotificationPolicyAccessGranted}.

 &lt;p&gt;
 Callers can only delete rules that they own. See {@link android.app.AutomaticZenRule#getOwner}.
@param {String} id the id of the rule to delete.
@return {Boolean} Whether the rule was successfully deleted.
*/
removeAutomaticZenRule : function(  ) {},

<span id='android-app-NotificationManager-method-removeAutomaticZenRules'>/**Deletes all automatic zen rules owned by the given package.
</span>@hide 
*/
removeAutomaticZenRules : function(  ) {},

<span id='android-app-NotificationManager-method-getImportance'>/**Returns the user specified importance for notifications from the calling
</span> package.
*/
getImportance : function(  ) {},

<span id='android-app-NotificationManager-method-areNotificationsEnabled'>/**Returns whether notifications from the calling package are blocked.
</span>*/
areNotificationsEnabled : function(  ) {},

<span id='android-app-NotificationManager-method-areBubblesAllowed'>/**Sets whether notifications posted by this app can appear outside of the
</span> notification shade, floating over other apps' content.

 &lt;p&gt;This value will be ignored for notifications that are posted to channels that do not
 allow bubbles ({@link android.app.NotificationChannel#canBubble()}.
@see Notification#getBubbleMetadata()
*/
areBubblesAllowed : function(  ) {},

<span id='android-app-NotificationManager-method-areNotificationsPaused'>/**Returns whether notifications from this package are temporarily hidden. This
</span> could be done because the package was marked as distracting to the user via
 {@code PackageManager#setDistractingPackageRestrictions(String[], int)} or because the
 package is {@code PackageManager#setPackagesSuspended(String[], boolean, PersistableBundle,
 PersistableBundle, SuspendDialogInfo) suspended}.
*/
areNotificationsPaused : function(  ) {},

<span id='android-app-NotificationManager-method-isNotificationPolicyAccessGranted'>/**Checks the ability to modify notification do not disturb policy for the calling package.
</span>
 &lt;p&gt;
 Returns true if the calling package can modify notification policy.

 &lt;p&gt;
 Apps can request policy access by sending the user to the activity that matches the system
 intent action {@link android.provider.Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS}.

 &lt;p&gt;
 Use {@link #ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED} to listen for
 user grant or denial of this access.
*/
isNotificationPolicyAccessGranted : function(  ) {},

<span id='android-app-NotificationManager-method-isNotificationListenerAccessGranted'>/**Checks whether the user has approved a given
</span> {@link android.service.notification.NotificationListenerService}.

 &lt;p&gt;
 The listener service must belong to the calling app.

 &lt;p&gt;
 Apps can request notification listener access by sending the user to the activity that
 matches the system intent action
 {@link android.provider.Settings#ACTION_NOTIFICATION_LISTENER_SETTINGS}.
*/
isNotificationListenerAccessGranted : function(  ) {},

<span id='android-app-NotificationManager-method-isNotificationAssistantAccessGranted'>/**Checks whether the user has approved a given
</span> {@link android.service.notification.NotificationAssistantService}.

 &lt;p&gt;
 The assistant service must belong to the calling app.

 &lt;p&gt;
 Apps can request notification assistant access by sending the user to the activity that
 matches the system intent action
 TODO: STOPSHIP: Add correct intent
 {@link android.provider.Settings#ACTION_MANAGE_DEFAULT_APPS_SETTINGS}.
@hide 
*/
isNotificationAssistantAccessGranted : function(  ) {},

<span id='android-app-NotificationManager-method-shouldHideSilentStatusBarIcons'>/**Returns whether the user wants silent notifications (see {@link #IMPORTANCE_LOW} to appear
</span> in the status bar.

 &lt;p&gt;Only available for {@link #isNotificationListenerAccessGranted(ComponentName) notification
 listeners}.
*/
shouldHideSilentStatusBarIcons : function(  ) {},

<span id='android-app-NotificationManager-method-getAllowedAssistantAdjustments'>/**Returns the list of {@link android.service.notification.Adjustment adjustment keys} that can
</span> be modified by the current {@link android.service.notification.NotificationAssistantService}.

 &lt;p&gt;Only callable by the current
 {@link android.service.notification.NotificationAssistantService}.
 See {@link #isNotificationAssistantAccessGranted}(ComponentName)&lt;/p&gt;
@hide 
*/
getAllowedAssistantAdjustments : function(  ) {},

<span id='android-app-NotificationManager-method-allowAssistantAdjustment'>/**
</span>@hide 
*/
allowAssistantAdjustment : function(  ) {},

<span id='android-app-NotificationManager-method-disallowAssistantAdjustment'>/**
</span>@hide 
*/
disallowAssistantAdjustment : function(  ) {},

<span id='android-app-NotificationManager-method-isNotificationPolicyAccessGrantedForPackage'>/**
</span>@hide 
*/
isNotificationPolicyAccessGrantedForPackage : function(  ) {},

<span id='android-app-NotificationManager-method-getEnabledNotificationListenerPackages'>/**
</span>@hide 
*/
getEnabledNotificationListenerPackages : function(  ) {},

<span id='android-app-NotificationManager-method-getNotificationPolicy'>/**Gets the current user-specified default notification policy.
</span>
 &lt;p&gt;
*/
getNotificationPolicy : function(  ) {},

<span id='android-app-NotificationManager-method-setNotificationPolicy'>/**Sets the current notification policy.
</span>
 &lt;p&gt;
 Only available if policy access is granted to this package.
 See {@link #isNotificationPolicyAccessGranted}.
@param {Object {NotificationManager.Policy}} policy The new desired policy.
*/
setNotificationPolicy : function(  ) {},

<span id='android-app-NotificationManager-method-setNotificationPolicyAccessGranted'>/**
</span>@hide 
*/
setNotificationPolicyAccessGranted : function(  ) {},

<span id='android-app-NotificationManager-method-setNotificationListenerAccessGranted'>/**
</span>@hide 
*/
setNotificationListenerAccessGranted : function(  ) {},

<span id='android-app-NotificationManager-method-setNotificationListenerAccessGrantedForUser'>/**
</span>@hide 
*/
setNotificationListenerAccessGrantedForUser : function(  ) {},

<span id='android-app-NotificationManager-method-setNotificationAssistantAccessGranted'>/**Grants/revokes Notification Assistant access to {@code assistant} for current user.
</span> To grant access for a particular user, obtain this service by using the {@link Context}
 provided by {@link Context#createPackageContextAsUser}
@param {Object {ComponentName}} assistant Name of component to grant/revoke access or {@code null} to revoke access to
                  current assistant
@param {Boolean} granted Grant/revoke access
@hide 
*/
setNotificationAssistantAccessGranted : function(  ) {},

<span id='android-app-NotificationManager-method-getEnabledNotificationListeners'>/**
</span>@hide 
*/
getEnabledNotificationListeners : function(  ) {},

<span id='android-app-NotificationManager-method-getAllowedNotificationAssistant'>/**
</span>@hide 
*/
getAllowedNotificationAssistant : function(  ) {},

<span id='android-app-NotificationManager-method-getActiveNotifications'>/**Recover a list of active notifications: ones that have been posted by the calling app that
</span> have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.

 &lt;p&gt;&lt;Each notification is embedded in a {@link StatusBarNotification} object, including the
 original &lt;code&gt;tag&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; supplied to
 {@link #notify(String, int, android.app.Notification) notify()}
 (via {@link StatusBarNotification#getTag() getTag()} and
 {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 {@link android.app.Notification} object (via {@link StatusBarNotification#getNotification()}).
 &lt;/p&gt;
 &lt;p&gt;From {@link Build.VERSION_CODES#Q}, will also return notifications you've posted as an
 app's notification delegate via
 {@link android.app.NotificationManager#notifyAsPackage(String, String, int, android.app.Notification)}.
 &lt;/p&gt;
@return {Object {android.service.notification.StatusBarNotification}} An array of {@link StatusBarNotification}.
*/
getActiveNotifications : function(  ) {},

<span id='android-app-NotificationManager-method-getCurrentInterruptionFilter'>/**Gets the current notification interruption filter.
</span> &lt;p&gt;
 The interruption filter defines which notifications are allowed to
 interrupt the user (e.g. via sound &amp;amp; vibration) and is applied
 globally.
*/
getCurrentInterruptionFilter : function(  ) {},

<span id='android-app-NotificationManager-method-setInterruptionFilter'>/**Sets the current notification interruption filter.
</span> &lt;p&gt;
 The interruption filter defines which notifications are allowed to
 interrupt the user (e.g. via sound &amp;amp; vibration) and is applied
 globally.
 &lt;p&gt;
 Only available if policy access is granted to this package. See
 {@link #isNotificationPolicyAccessGranted}.
*/
setInterruptionFilter : function(  ) {},

<span id='android-app-NotificationManager-method-zenModeToInterruptionFilter'>/**
</span>@hide 
*/
zenModeToInterruptionFilter : function(  ) {},

<span id='android-app-NotificationManager-method-zenModeFromInterruptionFilter'>/**
</span>@hide 
*/
zenModeFromInterruptionFilter : function(  ) {},


};</pre>
</body>
</html>
