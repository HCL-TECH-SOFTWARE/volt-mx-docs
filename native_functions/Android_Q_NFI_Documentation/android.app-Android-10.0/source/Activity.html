<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-app-Activity'>/**@class android.app.Activity
</span> implements android.view.LayoutInflater.Factory2

 implements android.view.Window.Callback

 implements android.view.KeyEvent.Callback

 implements android.view.View.OnCreateContextMenuListener

 implements android.content.ComponentCallbacks2

 implements android.view.Window.OnWindowDismissedCallback

 implements android.view.Window.WindowControllerCallback

 implements android.view.autofill.AutofillManager.AutofillClient

 implements android.view.contentcapture.ContentCaptureManager.ContentCaptureClient

@extends android.view.ContextThemeWrapper

 An activity is a single, focused thing that the user can do.  Almost all
 activities interact with the user, so the Activity class takes care of
 creating a window for you in which you can place your UI with
 {@link #setContentView}.  While activities are often presented to the user
 as full-screen windows, they can also be used in other ways: as floating
 windows (via a theme with {@link android.R.attr#windowIsFloating} set),
 &lt;a href=&quot;https://developer.android.com/guide/topics/ui/multi-window&quot;&gt;
 Multi-Window mode&lt;/a&gt; or embedded into other windows.

 There are two methods almost all subclasses of Activity will implement:

 &lt;ul&gt;
     &lt;li&gt; {@link #onCreate} is where you initialize your activity.  Most
     importantly, here you will usually call {@link #setContentView}(int)
     with a layout resource defining your UI, and using {@link #findViewById}
     to retrieve the widgets in that UI that you need to interact with
     programmatically.

     &lt;li&gt; {@link #onPause} is where you deal with the user pausing active
     interaction with the activity. Any changes made by the user should at
     this point be committed (usually to the
     {@link android.content.ContentProvider} holding the data). In this
     state the activity is still visible on screen.
 &lt;/ul&gt;

 &lt;p&gt;To be of use with {@link android.content.Context#startActivity Context.startActivity()}, all
 activity classes must have a corresponding
 {@link android.R.styleable#AndroidManifestActivity &amp;lt;activity&amp;gt;}
 declaration in their package's &lt;code&gt;AndroidManifest.xml&lt;/code&gt;.&lt;/p&gt;

 &lt;p&gt;Topics covered here:
 &lt;ol&gt;
 &lt;li&gt;&lt;a href=&quot;#Fragments&quot;&gt;Fragments&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#ActivityLifecycle&quot;&gt;Activity Lifecycle&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#ConfigurationChanges&quot;&gt;Configuration Changes&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#StartingActivities&quot;&gt;Starting Activities and Getting Results&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#SavingPersistentState&quot;&gt;Saving Persistent State&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#Permissions&quot;&gt;Permissions&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#ProcessLifecycle&quot;&gt;Process Lifecycle&lt;/a&gt;
 &lt;/ol&gt;

 &lt;div class=&quot;special reference&quot;&gt;
 &lt;h3&gt;Developer Guides&lt;/h3&gt;
 &lt;p&gt;The Activity class is an important part of an application's overall lifecycle,
 and the way activities are launched and put together is a fundamental
 part of the platform's application model. For a detailed perspective on the structure of an
 Android application and how activities behave, please read the
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals.html&quot;&gt;Application Fundamentals&lt;/a&gt; and
 &lt;a href=&quot;{@docRoot}guide/components/tasks-and-back-stack.html&quot;&gt;Tasks and Back Stack&lt;/a&gt;
 developer guides.&lt;/p&gt;

 &lt;p&gt;You can also find a detailed discussion about how to create activities in the
 &lt;a href=&quot;{@docRoot}guide/components/activities.html&quot;&gt;Activities&lt;/a&gt;
 developer guide.&lt;/p&gt;
 &lt;/div&gt;

 &lt;a name=&quot;Fragments&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Fragments&lt;/h3&gt;

 &lt;p&gt;The {@link android.support.v4.app.FragmentActivity} subclass
 can make use of the {@link android.support.v4.app.Fragment} class to better
 modularize their code, build more sophisticated user interfaces for larger
 screens, and help scale their application between small and large screens.&lt;/p&gt;

 &lt;p&gt;For more information about using fragments, read the
 &lt;a href=&quot;{@docRoot}guide/components/fragments.html&quot;&gt;Fragments&lt;/a&gt; developer guide.&lt;/p&gt;

 &lt;a name=&quot;ActivityLifecycle&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Activity Lifecycle&lt;/h3&gt;

 &lt;p&gt;Activities in the system are managed as
 &lt;a href=&quot;https://developer.android.com/guide/components/activities/tasks-and-back-stack&quot;&gt;
 activity stacks&lt;/a&gt;. When a new activity is started, it is usually placed on the top of the
 current stack and becomes the running activity -- the previous activity always remains
 below it in the stack, and will not come to the foreground again until
 the new activity exits. There can be one or multiple activity stacks visible
 on screen.&lt;/p&gt;

 &lt;p&gt;An activity has essentially four states:&lt;/p&gt;
 &lt;ul&gt;
     &lt;li&gt;If an activity is in the foreground of the screen (at the highest position of the topmost
         stack), it is &lt;em&gt;active&lt;/em&gt; or &lt;em&gt;running&lt;/em&gt;. This is usually the activity that the
         user is currently interacting with.&lt;/li&gt;
     &lt;li&gt;If an activity has lost focus but is still presented to the user, it is &lt;em&gt;visible&lt;/em&gt;.
         It is possible if a new non-full-sized or transparent activity has focus on top of your
         activity, another activity has higher position in multi-window mode, or the activity
         itself is not focusable in current windowing mode. Such activity is completely alive (it
         maintains all state and member information and remains attached to the window manager).
     &lt;li&gt;If an activity is completely obscured by another activity,
         it is &lt;em&gt;stopped&lt;/em&gt; or &lt;em&gt;hidden&lt;/em&gt;. It still retains all state and member
         information, however, it is no longer visible to the user so its window is hidden
         and it will often be killed by the system when memory is needed elsewhere.&lt;/li&gt;
     &lt;li&gt;The system can drop the activity from memory by either asking it to finish,
         or simply killing its process, making it &lt;em&gt;destroyed&lt;/em&gt;. When it is displayed again
         to the user, it must be completely restarted and restored to its previous state.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;The following diagram shows the important state paths of an Activity.
 The square rectangles represent callback methods you can implement to
 perform operations when the Activity moves between states.  The colored
 ovals are major states the Activity can be in.&lt;/p&gt;

 &lt;p&gt;&lt;img src=&quot;../../../images/activity_lifecycle.png&quot;
      alt=&quot;State diagram for an Android Activity Lifecycle.&quot; border=&quot;0&quot; /&gt;&lt;/p&gt;

 &lt;p&gt;There are three key loops you may be interested in monitoring within your
 activity:

 &lt;ul&gt;
 &lt;li&gt;The &lt;b&gt;entire lifetime&lt;/b&gt; of an activity happens between the first call
 to {@link android.app.Activity#onCreate} through to a single final call
 to {@link android.app.Activity#onDestroy}.  An activity will do all setup
 of &quot;global&quot; state in onCreate(), and release all remaining resources in
 onDestroy().  For example, if it has a thread running in the background
 to download data from the network, it may create that thread in onCreate()
 and then stop the thread in onDestroy().

 &lt;li&gt;The &lt;b&gt;visible lifetime&lt;/b&gt; of an activity happens between a call to
 {@link android.app.Activity#onStart} until a corresponding call to
 {@link android.app.Activity#onStop}.  During this time the user can see the
 activity on-screen, though it may not be in the foreground and interacting
 with the user.  Between these two methods you can maintain resources that
 are needed to show the activity to the user.  For example, you can register
 a {@link android.content.BroadcastReceiver} in onStart() to monitor for changes
 that impact your UI, and unregister it in onStop() when the user no
 longer sees what you are displaying.  The onStart() and onStop() methods
 can be called multiple times, as the activity becomes visible and hidden
 to the user.

 &lt;li&gt;The &lt;b&gt;foreground lifetime&lt;/b&gt; of an activity happens between a call to
 {@link android.app.Activity#onResume} until a corresponding call to
 {@link android.app.Activity#onPause}.  During this time the activity is
 in visible, active and interacting with the user.  An activity
 can frequently go between the resumed and paused states -- for example when
 the device goes to sleep, when an activity result is delivered, when a new
 intent is delivered -- so the code in these methods should be fairly
 lightweight.
 &lt;/ul&gt;

 &lt;p&gt;The entire lifecycle of an activity is defined by the following
 Activity methods.  All of these are hooks that you can override
 to do appropriate work when the activity changes state.  All
 activities will implement {@link android.app.Activity#onCreate}
 to do their initial setup; many will also implement
 {@link android.app.Activity#onPause} to commit changes to data and
 prepare to pause interacting with the user, and {@link android.app.Activity#onStop}
 to handle no longer being visible on screen. You should always
 call up to your superclass when implementing these methods.&lt;/p&gt;

 &lt;/p&gt;
 &lt;pre class=&quot;prettyprint&quot;&gt;
 public class Activity extends ApplicationContext {
     protected void onCreate(Bundle savedInstanceState);

     protected void onStart();

     protected void onRestart();

     protected void onResume();

     protected void onPause();

     protected void onStop();

     protected void onDestroy();
 }
 &lt;/pre&gt;

 &lt;p&gt;In general the movement through an activity's lifecycle looks like
 this:&lt;/p&gt;

 &lt;table border=&quot;2&quot; width=&quot;85%&quot; align=&quot;center&quot; frame=&quot;hsides&quot; rules=&quot;rows&quot;&gt;
     &lt;colgroup align=&quot;left&quot; span=&quot;3&quot; /&gt;
     &lt;colgroup align=&quot;left&quot; /&gt;
     &lt;colgroup align=&quot;center&quot; /&gt;
     &lt;colgroup align=&quot;center&quot; /&gt;

     &lt;thead&gt;
     &lt;tr&gt;&lt;th colspan=&quot;3&quot;&gt;Method&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;th&gt;Killable?&lt;/th&gt; &lt;th&gt;Next&lt;/th&gt;&lt;/tr&gt;
     &lt;/thead&gt;

     &lt;tbody&gt;
     &lt;tr&gt;&lt;td colspan=&quot;3&quot; align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onCreate onCreate()}&lt;/td&gt;
         &lt;td&gt;Called when the activity is first created.
             This is where you should do all of your normal static set up:
             create views, bind data to lists, etc.  This method also
             provides you with a Bundle containing the activity's previously
             frozen state, if there was one.
             &lt;p&gt;Always followed by &lt;code&gt;onStart()&lt;/code&gt;.&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;code&gt;onStart()&lt;/code&gt;&lt;/td&gt;
     &lt;/tr&gt;

     &lt;tr&gt;&lt;td rowspan=&quot;5&quot; style=&quot;border-left: none; border-right: none;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
         &lt;td colspan=&quot;2&quot; align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onRestart onRestart()}&lt;/td&gt;
         &lt;td&gt;Called after your activity has been stopped, prior to it being
             started again.
             &lt;p&gt;Always followed by &lt;code&gt;onStart()&lt;/code&gt;&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;code&gt;onStart()&lt;/code&gt;&lt;/td&gt;
     &lt;/tr&gt;

     &lt;tr&gt;&lt;td colspan=&quot;2&quot; align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onStart onStart()}&lt;/td&gt;
         &lt;td&gt;Called when the activity is becoming visible to the user.
             &lt;p&gt;Followed by &lt;code&gt;onResume()&lt;/code&gt; if the activity comes
             to the foreground, or &lt;code&gt;onStop()&lt;/code&gt; if it becomes hidden.&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;code&gt;onResume()&lt;/code&gt; or &lt;code&gt;onStop()&lt;/code&gt;&lt;/td&gt;
     &lt;/tr&gt;

     &lt;tr&gt;&lt;td rowspan=&quot;2&quot; style=&quot;border-left: none;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
         &lt;td align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onResume onResume()}&lt;/td&gt;
         &lt;td&gt;Called when the activity will start
             interacting with the user.  At this point your activity is at
             the top of its activity stack, with user input going to it.
             &lt;p&gt;Always followed by &lt;code&gt;onPause()&lt;/code&gt;.&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;code&gt;onPause()&lt;/code&gt;&lt;/td&gt;
     &lt;/tr&gt;

     &lt;tr&gt;&lt;td align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onPause onPause()}&lt;/td&gt;
         &lt;td&gt;Called when the activity loses foreground state, is no longer focusable or before
             transition to stopped/hidden or destroyed state. The activity is still visible to
             user, so it's recommended to keep it visually active and continue updating the UI.
             Implementations of this method must be very quick because
             the next activity will not be resumed until this method returns.
             &lt;p&gt;Followed by either &lt;code&gt;onResume()&lt;/code&gt; if the activity
             returns back to the front, or &lt;code&gt;onStop()&lt;/code&gt; if it becomes
             invisible to the user.&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;font color=&quot;#800000&quot;&gt;&lt;strong&gt;Pre-{@link android.os.Build.VERSION_CODES#HONEYCOMB}&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;code&gt;onResume()&lt;/code&gt; or&lt;br&gt;
                 &lt;code&gt;onStop()&lt;/code&gt;&lt;/td&gt;
     &lt;/tr&gt;

     &lt;tr&gt;&lt;td colspan=&quot;2&quot; align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onStop onStop()}&lt;/td&gt;
         &lt;td&gt;Called when the activity is no longer visible to the user.  This may happen either
             because a new activity is being started on top, an existing one is being brought in
             front of this one, or this one is being destroyed. This is typically used to stop
             animations and refreshing the UI, etc.
             &lt;p&gt;Followed by either &lt;code&gt;onRestart()&lt;/code&gt; if
             this activity is coming back to interact with the user, or
             &lt;code&gt;onDestroy()&lt;/code&gt; if this activity is going away.&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;font color=&quot;#800000&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;code&gt;onRestart()&lt;/code&gt; or&lt;br&gt;
                 &lt;code&gt;onDestroy()&lt;/code&gt;&lt;/td&gt;
     &lt;/tr&gt;

     &lt;tr&gt;&lt;td colspan=&quot;3&quot; align=&quot;left&quot; border=&quot;0&quot;&gt;{@link android.app.Activity#onDestroy onDestroy()}&lt;/td&gt;
         &lt;td&gt;The final call you receive before your
             activity is destroyed.  This can happen either because the
             activity is finishing (someone called {@link android.app.Activity#finish} on
             it), or because the system is temporarily destroying this
             instance of the activity to save space.  You can distinguish
             between these two scenarios with the {@link android.app.Activity#isFinishing} method.&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;font color=&quot;#800000&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;
         &lt;td align=&quot;center&quot;&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/td&gt;
     &lt;/tr&gt;
     &lt;/tbody&gt;
 &lt;/table&gt;

 &lt;p&gt;Note the &quot;Killable&quot; column in the above table -- for those methods that
 are marked as being killable, after that method returns the process hosting the
 activity may be killed by the system &lt;em&gt;at any time&lt;/em&gt; without another line
 of its code being executed.  Because of this, you should use the
 {@link #onPause} method to write any persistent data (such as user edits)
 to storage.  In addition, the method
 {@link #onSaveInstanceState}(Bundle) is called before placing the activity
 in such a background state, allowing you to save away any dynamic instance
 state in your activity into the given Bundle, to be later received in
 {@link #onCreate} if the activity needs to be re-created.
 See the &lt;a href=&quot;#ProcessLifecycle&quot;&gt;Process Lifecycle&lt;/a&gt;
 section for more information on how the lifecycle of a process is tied
 to the activities it is hosting.  Note that it is important to save
 persistent data in {@link #onPause} instead of {@link #onSaveInstanceState}
 because the latter is not part of the lifecycle callbacks, so will not
 be called in every situation as described in its documentation.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;Be aware that these semantics will change slightly between
 applications targeting platforms starting with {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 vs. those targeting prior platforms.  Starting with Honeycomb, an application
 is not in the killable state until its {@link #onStop} has returned.  This
 impacts when {@link #onSaveInstanceState}(Bundle) may be called (it may be
 safely called after {@link #onPause}()) and allows an application to safely
 wait until {@link #onStop}() to save persistent state.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For applications targeting platforms starting with
 {@link android.os.Build.VERSION_CODES#P} {@link #onSaveInstanceState}(Bundle)
 will always be called after {@link #onStop}, so an application may safely
 perform fragment transactions in {@link #onStop} and will be able to save
 persistent state later.&lt;/p&gt;

 &lt;p&gt;For those methods that are not marked as being killable, the activity's
 process will not be killed by the system starting from the time the method
 is called and continuing after it returns.  Thus an activity is in the killable
 state, for example, between after &lt;code&gt;onStop()&lt;/code&gt; to the start of
 &lt;code&gt;onResume()&lt;/code&gt;. Keep in mind that under extreme memory pressure the
 system can kill the application process at any time.&lt;/p&gt;

 &lt;a name=&quot;ConfigurationChanges&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Configuration Changes&lt;/h3&gt;

 &lt;p&gt;If the configuration of the device (as defined by the
 {@link Configuration Resources.Configuration} class) changes,
 then anything displaying a user interface will need to update to match that
 configuration.  Because Activity is the primary mechanism for interacting
 with the user, it includes special support for handling configuration
 changes.&lt;/p&gt;

 &lt;p&gt;Unless you specify otherwise, a configuration change (such as a change
 in screen orientation, language, input devices, etc) will cause your
 current activity to be &lt;em&gt;destroyed&lt;/em&gt;, going through the normal activity
 lifecycle process of {@link #onPause},
 {@link #onStop}, and {@link #onDestroy} as appropriate.  If the activity
 had been in the foreground or visible to the user, once {@link #onDestroy} is
 called in that instance then a new instance of the activity will be
 created, with whatever savedInstanceState the previous instance had generated
 from {@link #onSaveInstanceState}.&lt;/p&gt;

 &lt;p&gt;This is done because any application resource,
 including layout files, can change based on any configuration value.  Thus
 the only safe way to handle a configuration change is to re-retrieve all
 resources, including layouts, drawables, and strings.  Because activities
 must already know how to save their state and re-create themselves from
 that state, this is a convenient way to have an activity restart itself
 with a new configuration.&lt;/p&gt;

 &lt;p&gt;In some special cases, you may want to bypass restarting of your
 activity based on one or more types of configuration changes.  This is
 done with the {@link android.R.attr#configChanges android:configChanges}
 attribute in its manifest.  For any types of configuration changes you say
 that you handle there, you will receive a call to your current activity's
 {@link #onConfigurationChanged} method instead of being restarted.  If
 a configuration change involves any that you do not handle, however, the
 activity will still be restarted and {@link #onConfigurationChanged}
 will not be called.&lt;/p&gt;

 &lt;a name=&quot;StartingActivities&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Starting Activities and Getting Results&lt;/h3&gt;

 &lt;p&gt;The {@link android.app.Activity#startActivity}
 method is used to start a
 new activity, which will be placed at the top of the activity stack.  It
 takes a single argument, an {@link android.content.Intent Intent},
 which describes the activity
 to be executed.&lt;/p&gt;

 &lt;p&gt;Sometimes you want to get a result back from an activity when it
 ends.  For example, you may start an activity that lets the user pick
 a person in a list of contacts; when it ends, it returns the person
 that was selected.  To do this, you call the
 {@link android.app.Activity#startActivityForResult(Intent, int)}
 version with a second integer parameter identifying the call.  The result
 will come back through your {@link android.app.Activity#onActivityResult}
 method.&lt;/p&gt;

 &lt;p&gt;When an activity exits, it can call
 {@link android.app.Activity#setResult(int)}
 to return data back to its parent.  It must always supply a result code,
 which can be the standard results RESULT_CANCELED, RESULT_OK, or any
 custom values starting at RESULT_FIRST_USER.  In addition, it can optionally
 return back an Intent containing any additional data it wants.  All of this
 information appears back on the
 parent's &lt;code&gt;Activity.onActivityResult()&lt;/code&gt;, along with the integer
 identifier it originally supplied.&lt;/p&gt;

 &lt;p&gt;If a child activity fails for any reason (such as crashing), the parent
 activity will receive a result with the code RESULT_CANCELED.&lt;/p&gt;

 &lt;pre class=&quot;prettyprint&quot;&gt;
 public class MyActivity extends Activity {
     ...

     static final int PICK_CONTACT_REQUEST = 0;

     public boolean onKeyDown(int keyCode, KeyEvent event) {
         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
             // When the user center presses, let them pick a contact.
             startActivityForResult(
                 new Intent(Intent.ACTION_PICK,
                 new Uri(&quot;content://contacts&quot;)),
                 PICK_CONTACT_REQUEST);
            return true;
         }
         return false;
     }

     protected void onActivityResult(int requestCode, int resultCode,
             Intent data) {
         if (requestCode == PICK_CONTACT_REQUEST) {
             if (resultCode == RESULT_OK) {
                 // A contact was picked.  Here we will just display it
                 // to the user.
                 startActivity(new Intent(Intent.ACTION_VIEW, data));
             }
         }
     }
 }
 &lt;/pre&gt;

 &lt;a name=&quot;SavingPersistentState&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Saving Persistent State&lt;/h3&gt;

 &lt;p&gt;There are generally two kinds of persistent state that an activity
 will deal with: shared document-like data (typically stored in a SQLite
 database using a {@linkplain android.content.ContentProvider content provider})
 and internal state such as user preferences.&lt;/p&gt;

 &lt;p&gt;For content provider data, we suggest that activities use an
 &quot;edit in place&quot; user model.  That is, any edits a user makes are effectively
 made immediately without requiring an additional confirmation step.
 Supporting this model is generally a simple matter of following two rules:&lt;/p&gt;

 &lt;ul&gt;
     &lt;li&gt; &lt;p&gt;When creating a new document, the backing database entry or file for
             it is created immediately.  For example, if the user chooses to write
             a new email, a new entry for that email is created as soon as they
             start entering data, so that if they go to any other activity after
             that point this email will now appear in the list of drafts.&lt;/p&gt;
     &lt;li&gt; &lt;p&gt;When an activity's &lt;code&gt;onPause()&lt;/code&gt; method is called, it should
             commit to the backing content provider or file any changes the user
             has made.  This ensures that those changes will be seen by any other
             activity that is about to run.  You will probably want to commit
             your data even more aggressively at key times during your
             activity's lifecycle: for example before starting a new
             activity, before finishing your own activity, when the user
             switches between input fields, etc.&lt;/p&gt;
 &lt;/ul&gt;

 &lt;p&gt;This model is designed to prevent data loss when a user is navigating
 between activities, and allows the system to safely kill an activity (because
 system resources are needed somewhere else) at any time after it has been
 stopped (or paused on platform versions before {@link android.os.Build.VERSION_CODES#HONEYCOMB}).
 Note this implies that the user pressing BACK from your activity does &lt;em&gt;not&lt;/em&gt;
 mean &quot;cancel&quot; -- it means to leave the activity with its current contents
 saved away.  Canceling edits in an activity must be provided through
 some other mechanism, such as an explicit &quot;revert&quot; or &quot;undo&quot; option.&lt;/p&gt;

 &lt;p&gt;See the {@linkplain android.content.ContentProvider content package} for
 more information about content providers.  These are a key aspect of how
 different activities invoke and propagate data between themselves.&lt;/p&gt;

 &lt;p&gt;The Activity class also provides an API for managing internal persistent state
 associated with an activity.  This can be used, for example, to remember
 the user's preferred initial display in a calendar (day view or week view)
 or the user's default home page in a web browser.&lt;/p&gt;

 &lt;p&gt;Activity persistent state is managed
 with the method {@link #getPreferences},
 allowing you to retrieve and
 modify a set of name/value pairs associated with the activity.  To use
 preferences that are shared across multiple application components
 (activities, receivers, services, providers), you can use the underlying
 {@link Context#getSharedPreferences Context.getSharedPreferences()} method
 to retrieve a preferences
 object stored under a specific name.
 (Note that it is not possible to share settings data across application
 packages -- for that you will need a content provider.)&lt;/p&gt;

 &lt;p&gt;Here is an excerpt from a calendar activity that stores the user's
 preferred view mode in its persistent settings:&lt;/p&gt;

 &lt;pre class=&quot;prettyprint&quot;&gt;
 public class CalendarActivity extends Activity {
     ...

     static final int DAY_VIEW_MODE = 0;
     static final int WEEK_VIEW_MODE = 1;

     private SharedPreferences mPrefs;
     private int mCurViewMode;

     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

         SharedPreferences mPrefs = getSharedPreferences();
         mCurViewMode = mPrefs.getInt(&quot;view_mode&quot;, DAY_VIEW_MODE);
     }

     protected void onPause() {
         super.onPause();

         SharedPreferences.Editor ed = mPrefs.edit();
         ed.putInt(&quot;view_mode&quot;, mCurViewMode);
         ed.commit();
     }
 }
 &lt;/pre&gt;

 &lt;a name=&quot;Permissions&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Permissions&lt;/h3&gt;

 &lt;p&gt;The ability to start a particular Activity can be enforced when it is
 declared in its
 manifest's {@link android.R.styleable#AndroidManifestActivity &amp;lt;activity&amp;gt;}
 tag.  By doing so, other applications will need to declare a corresponding
 {@link android.R.styleable#AndroidManifestUsesPermission &amp;lt;uses-permission&amp;gt;}
 element in their own manifest to be able to start that activity.

 &lt;p&gt;When starting an Activity you can set {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
 Intent.FLAG_GRANT_READ_URI_PERMISSION} and/or {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
 Intent.FLAG_GRANT_WRITE_URI_PERMISSION} on the Intent.  This will grant the
 Activity access to the specific URIs in the Intent.  Access will remain
 until the Activity has finished (it will remain across the hosting
 process being killed and other temporary destruction).  As of
 {@link android.os.Build.VERSION_CODES#GINGERBREAD}, if the Activity
 was already created and a new Intent is being delivered to
 {@link #onNewIntent}(Intent), any newly granted URI permissions will be added
 to the existing ones it holds.

 &lt;p&gt;See the &lt;a href=&quot;{@docRoot}guide/topics/security/security.html&quot;&gt;Security and Permissions&lt;/a&gt;
 document for more information on permissions and security in general.

 &lt;a name=&quot;ProcessLifecycle&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Process Lifecycle&lt;/h3&gt;

 &lt;p&gt;The Android system attempts to keep an application process around for as
 long as possible, but eventually will need to remove old processes when
 memory runs low. As described in &lt;a href=&quot;#ActivityLifecycle&quot;&gt;Activity
 Lifecycle&lt;/a&gt;, the decision about which process to remove is intimately
 tied to the state of the user's interaction with it. In general, there
 are four states a process can be in based on the activities running in it,
 listed here in order of importance. The system will kill less important
 processes (the last ones) before it resorts to killing more important
 processes (the first ones).

 &lt;ol&gt;
 &lt;li&gt; &lt;p&gt;The &lt;b&gt;foreground activity&lt;/b&gt; (the activity at the top of the screen
 that the user is currently interacting with) is considered the most important.
 Its process will only be killed as a last resort, if it uses more memory
 than is available on the device.  Generally at this point the device has
 reached a memory paging state, so this is required in order to keep the user
 interface responsive.
 &lt;li&gt; &lt;p&gt;A &lt;b&gt;visible activity&lt;/b&gt; (an activity that is visible to the user
 but not in the foreground, such as one sitting behind a foreground dialog
 or next to other activities in multi-window mode)
 is considered extremely important and will not be killed unless that is
 required to keep the foreground activity running.
 &lt;li&gt; &lt;p&gt;A &lt;b&gt;background activity&lt;/b&gt; (an activity that is not visible to
 the user and has been stopped) is no longer critical, so the system may
 safely kill its process to reclaim memory for other foreground or
 visible processes.  If its process needs to be killed, when the user navigates
 back to the activity (making it visible on the screen again), its
 {@link #onCreate} method will be called with the savedInstanceState it had previously
 supplied in {@link #onSaveInstanceState} so that it can restart itself in the same
 state as the user last left it.
 &lt;li&gt; &lt;p&gt;An &lt;b&gt;empty process&lt;/b&gt; is one hosting no activities or other
 application components (such as {@link android.app.Service} or
 {@link android.content.BroadcastReceiver} classes).  These are killed very
 quickly by the system as memory becomes low.  For this reason, any
 background operation you do outside of an activity must be executed in the
 context of an activity BroadcastReceiver or Service to ensure that the system
 knows it needs to keep your process around.
 &lt;/ol&gt;

 &lt;p&gt;Sometimes an Activity may need to do a long-running operation that exists
 independently of the activity lifecycle itself.  An example may be a camera
 application that allows you to upload a picture to a web site.  The upload
 may take a long time, and the application should allow the user to leave
 the application while it is executing.  To accomplish this, your Activity
 should start a {@link android.app.Service} in which the upload takes place.  This allows
 the system to properly prioritize your process (considering it to be more
 important than other non-visible applications) for the duration of the
 upload, independent of whether the original activity is paused, stopped,
 or finished.
*/
var Activity = {

<span id='android-app-Activity-property-RESULT_CANCELED'>/**Standard activity result: operation canceled. */
</span>RESULT_CANCELED : &quot;0&quot;,
<span id='android-app-Activity-property-RESULT_OK'>/**Standard activity result: operation succeeded. */
</span>RESULT_OK : &quot;-1&quot;,
<span id='android-app-Activity-property-RESULT_FIRST_USER'>/**Start of user-defined activity results. */
</span>RESULT_FIRST_USER : &quot;1&quot;,
<span id='android-app-Activity-property-DONT_FINISH_TASK_WITH_ACTIVITY'>/**@hide Task isn't finished when activity is finished */
</span>DONT_FINISH_TASK_WITH_ACTIVITY : &quot;0&quot;,
<span id='android-app-Activity-property-FINISH_TASK_WITH_ROOT_ACTIVITY'>/** @hide Task is finished if the finishing activity is the root of the task. To preserve the
</span> past behavior the task is also removed from recents.
*/
FINISH_TASK_WITH_ROOT_ACTIVITY : &quot;1&quot;,
<span id='android-app-Activity-property-FINISH_TASK_WITH_ACTIVITY'>/** @hide Task is finished along with the finishing activity, but it is not removed from
</span> recents.
*/
FINISH_TASK_WITH_ACTIVITY : &quot;2&quot;,
<span id='android-app-Activity-property-DEFAULT_KEYS_DISABLE'>/** Use with {@link #setDefaultKeyMode} to turn off default handling of
</span> keys.

 @see #setDefaultKeyMode
*/
DEFAULT_KEYS_DISABLE : &quot;0&quot;,
<span id='android-app-Activity-property-DEFAULT_KEYS_DIALER'>/** Use with {@link #setDefaultKeyMode} to launch the dialer during default
</span> key handling.

 @see #setDefaultKeyMode
*/
DEFAULT_KEYS_DIALER : &quot;1&quot;,
<span id='android-app-Activity-property-DEFAULT_KEYS_SHORTCUT'>/** Use with {@link #setDefaultKeyMode} to execute a menu shortcut in
</span> default key handling.

 &lt;p&gt;That is, the user does not need to hold down the menu key to execute menu shortcuts.

 @see #setDefaultKeyMode
*/
DEFAULT_KEYS_SHORTCUT : &quot;2&quot;,
<span id='android-app-Activity-property-DEFAULT_KEYS_SEARCH_LOCAL'>/** Use with {@link #setDefaultKeyMode} to specify that unhandled keystrokes
</span> will start an application-defined search.  (If the application or activity does not
 actually define a search, the keys will be ignored.)

 &lt;p&gt;See {@link android.app.SearchManager android.app.SearchManager} for more details.

 @see #setDefaultKeyMode
*/
DEFAULT_KEYS_SEARCH_LOCAL : &quot;3&quot;,
<span id='android-app-Activity-property-DEFAULT_KEYS_SEARCH_GLOBAL'>/** Use with {@link #setDefaultKeyMode} to specify that unhandled keystrokes
</span> will start a global search (typically web search, but some platforms may define alternate
 methods for global search)

 &lt;p&gt;See {@link android.app.SearchManager android.app.SearchManager} for more details.

 @see #setDefaultKeyMode
*/
DEFAULT_KEYS_SEARCH_GLOBAL : &quot;4&quot;,
<span id='android-app-Activity-method-getIntent'>/**Return the intent that started this activity.
</span>*/
getIntent : function(  ) {},

<span id='android-app-Activity-method-setIntent'>/**Change the intent returned by {@link #getIntent}.  This holds a
</span> reference to the given intent; it does not copy it.  Often used in
 conjunction with {@link #onNewIntent}.
@param {Object {Intent}} newIntent The new Intent object to return from getIntent
@see #getIntent
@see #onNewIntent
*/
setIntent : function(  ) {},

<span id='android-app-Activity-method-getApplication'>/**Return the application that owns this activity.
</span>*/
getApplication : function(  ) {},

<span id='android-app-Activity-method-isChild'>/**Is this activity embedded inside of another activity?
</span>*/
isChild : function(  ) {},

<span id='android-app-Activity-method-getParent'>/**Return the parent activity if this view is an embedded child.
</span>*/
getParent : function(  ) {},

<span id='android-app-Activity-method-getWindowManager'>/**Retrieve the window manager for showing custom windows.
</span>*/
getWindowManager : function(  ) {},

<span id='android-app-Activity-method-getWindow'>/**Retrieve the current {@link android.view.Window} for the activity.
</span> This can be used to directly access parts of the Window API that
 are not available through Activity/Screen.
@return {Object {android.view.Window}} Window The current window, or null if the activity is not
         visual.
*/
getWindow : function(  ) {},

<span id='android-app-Activity-method-getLoaderManager'>/**Return the LoaderManager for this activity, creating it if needed.
</span>@deprecated Use {@link android.support.v4.app.FragmentActivity#getSupportLoaderManager()}
*/
getLoaderManager : function(  ) {},

<span id='android-app-Activity-method-getCurrentFocus'>/**Calls {@link android.view.Window#getCurrentFocus} on the
</span> Window of this Activity to return the currently focused view.
@return {Object {android.view.View}} View The current View with focus or null.
@see #getWindow
@see android.view.Window#getCurrentFocus
*/
getCurrentFocus : function(  ) {},

<span id='android-app-Activity-method-getAutofillClient'>/**
</span>@hide 
*/
getAutofillClient : function(  ) {},

<span id='android-app-Activity-method-getContentCaptureClient'>/**
</span>@hide 
*/
getContentCaptureClient : function(  ) {},

<span id='android-app-Activity-method-registerActivityLifecycleCallbacks'>/**Register an {@link android.app.Application.ActivityLifecycleCallbacks} instance that receives
</span> lifecycle callbacks for only this Activity.
 &lt;p&gt;
 In relation to any
 {@link android.app.Application#registerActivityLifecycleCallbacks android.app.Application registered callbacks},
 the callbacks registered here will always occur nested within those callbacks. This means:
 &lt;ul&gt;
     &lt;li&gt;Pre events will first be sent to Application registered callbacks, then to callbacks
     registered here.&lt;/li&gt;
     &lt;li&gt;{@link android.app.Application.ActivityLifecycleCallbacks#onActivityCreated(Activity, Bundle)},
     {@link android.app.Application.ActivityLifecycleCallbacks#onActivityStarted(Activity)}, and
     {@link android.app.Application.ActivityLifecycleCallbacks#onActivityResumed(Activity)} will
     be sent first to Application registered callbacks, then to callbacks registered here.
     For all other events, callbacks registered here will be sent first.&lt;/li&gt;
     &lt;li&gt;Post events will first be sent to callbacks registered here, then to
     Application registered callbacks.&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 If multiple callbacks are registered here, they receive events in a first in (up through
 {@link android.app.Application.ActivityLifecycleCallbacks#onActivityPostResumed}, last out
 ordering.
 &lt;p&gt;
 It is strongly recommended to register this in the constructor of your Activity to ensure
 you get all available callbacks. As this callback is associated with only this Activity,
 it is not usually necessary to {@link #unregisterActivityLifecycleCallbacks unregister} it
 unless you specifically do not want to receive further lifecycle callbacks.
@param {Object {Application.ActivityLifecycleCallbacks}} callback The callback instance to register
*/
registerActivityLifecycleCallbacks : function(  ) {},

<span id='android-app-Activity-method-unregisterActivityLifecycleCallbacks'>/**Unregister an {@link android.app.Application.ActivityLifecycleCallbacks} previously registered
</span> with {@link #registerActivityLifecycleCallbacks}. It will not receive any further
 callbacks.
@param {Object {Application.ActivityLifecycleCallbacks}} callback The callback instance to unregister
@see #registerActivityLifecycleCallbacks
*/
unregisterActivityLifecycleCallbacks : function(  ) {},

<span id='android-app-Activity-method-onCreate'>/**Same as {@link #onCreate(android.os.Bundle)} but called for those activities created with
</span> the attribute {@link android.R.attr#persistableMode} set to
 &lt;code&gt;persistAcrossReboots&lt;/code&gt;.
@param {Object {Bundle}} savedInstanceState if the activity is being re-initialized after
     previously being shut down then this Bundle contains the data it most
     recently supplied in {@link #onSaveInstanceState}.
     &lt;b&gt;&lt;i&gt;Note: Otherwise it is null.&lt;/i&gt;&lt;/b&gt;
@param {Object {PersistableBundle}} persistentState if the activity is being re-initialized after
     previously being shut down or powered off then this Bundle contains the data it most
     recently supplied to outPersistentState in {@link #onSaveInstanceState}.
     &lt;b&gt;&lt;i&gt;Note: Otherwise it is null.&lt;/i&gt;&lt;/b&gt;
@see #onCreate(android.os.Bundle)
@see #onStart
@see #onSaveInstanceState
@see #onRestoreInstanceState
@see #onPostCreate
*/
onCreate : function(  ) {},

<span id='android-app-Activity-method-onRestoreInstanceState'>/**This is the same as {@link #onRestoreInstanceState}(Bundle) but is called for activities
</span> created with the attribute {@link android.R.attr#persistableMode} set to
 &lt;code&gt;persistAcrossReboots&lt;/code&gt;. The {@link android.os.PersistableBundle} passed
 came from the restored PersistableBundle first
 saved in {@link #onSaveInstanceState(Bundle, PersistableBundle)}.

 &lt;p&gt;This method is called between {@link #onStart} and
 {@link #onPostCreate}.

 &lt;p&gt;If this method is called {@link #onRestoreInstanceState}(Bundle) will not be called.

 &lt;p&gt;At least one of {@code savedInstanceState} or {@code persistentState} will not be null.
@param {Object {Bundle}} savedInstanceState the data most recently supplied in {@link #onSaveInstanceState}
     or null.
@param {Object {PersistableBundle}} persistentState the data most recently supplied in {@link #onSaveInstanceState}
     or null.
@see #onRestoreInstanceState(Bundle)
@see #onCreate
@see #onPostCreate
@see #onResume
@see #onSaveInstanceState
*/
onRestoreInstanceState : function(  ) {},

<span id='android-app-Activity-method-onPostCreate'>/**This is the same as {@link #onPostCreate}(Bundle) but is called for activities
</span> created with the attribute {@link android.R.attr#persistableMode} set to
 &lt;code&gt;persistAcrossReboots&lt;/code&gt;.
@param {Object {Bundle}} savedInstanceState The data most recently supplied in {@link #onSaveInstanceState}
@param {Object {PersistableBundle}} persistentState The data caming from the PersistableBundle first
 saved in {@link #onSaveInstanceState(Bundle, PersistableBundle)}.
@see #onCreate
*/
onPostCreate : function(  ) {},

<span id='android-app-Activity-method-onStateNotSaved'>/**Called when an {@link #onResume} is coming up, prior to other pre-resume callbacks
</span> such as {@link #onNewIntent} and {@link #onActivityResult}.  This is primarily intended
 to give the activity a hint that its state is no longer saved -- it will generally
 be called after {@link #onSaveInstanceState} and prior to the activity being
 resumed/started again.
@deprecated starting with {@link android.os.Build.VERSION_CODES#P} onSaveInstanceState is
 called after {@link #onStop}, so this hint isn't accurate anymore: you should consider your
 state not saved in between {@code onStart} and {@code onStop} callbacks inclusively.
*/
onStateNotSaved : function(  ) {},

<span id='android-app-Activity-method-onTopResumedActivityChanged'>/**Called when activity gets or loses the top resumed position in the system.
</span>
 &lt;p&gt;Starting with {@link android.os.Build.VERSION_CODES#Q} multiple activities can be resumed
 at the same time in multi-window and multi-display modes. This callback should be used
 instead of {@link #onResume}() as an indication that the activity can try to open
 exclusive-access devices like camera.&lt;/p&gt;

 &lt;p&gt;It will always be delivered after the activity was resumed and before it is paused. In
 some cases it might be skipped and activity can go straight from {@link #onResume}() to
 {@link #onPause}() without receiving the top resumed state.&lt;/p&gt;
@param {Boolean} isTopResumedActivity {@code true} if it's the topmost resumed activity in the system,
                             {@code false} otherwise. A call with this as {@code true} will
                             always be followed by another one with {@code false}.
@see #onResume()
@see #onPause()
@see #onWindowFocusChanged(boolean)
*/
onTopResumedActivityChanged : function(  ) {},

<span id='android-app-Activity-method-getNextAutofillId'>/**Gets the next autofill ID.
</span>
 &lt;p&gt;All IDs will be bigger than {@link View#LAST_APP_AUTOFILL_ID}. All IDs returned
 will be unique.
@return {Number} A ID that is unique in the activity

 {@hide}
*/
getNextAutofillId : function(  ) {},

<span id='android-app-Activity-method-autofillClientGetNextAutofillId'>/**
</span>@hide 
*/
autofillClientGetNextAutofillId : function(  ) {},

<span id='android-app-Activity-method-isVoiceInteraction'>/**Check whether this activity is running as part of a voice interaction with the user.
</span> If true, it should perform its interaction with the user through the
 {@link android.app.VoiceInteractor} returned by {@link #getVoiceInteractor}.
*/
isVoiceInteraction : function(  ) {},

<span id='android-app-Activity-method-isVoiceInteractionRoot'>/**Like {@link #isVoiceInteraction}, but only returns true if this is also the root
</span> of a voice interaction.  That is, returns true if this activity was directly
 started by the voice interaction service as the initiation of a voice interaction.
 Otherwise, for example if it was started by another activity while under voice
 interaction, returns false.
*/
isVoiceInteractionRoot : function(  ) {},

<span id='android-app-Activity-method-getVoiceInteractor'>/**Retrieve the active {@link android.app.VoiceInteractor} that the user is going through to
</span> interact with this activity.
*/
getVoiceInteractor : function(  ) {},

<span id='android-app-Activity-method-isLocalVoiceInteractionSupported'>/**Queries whether the currently enabled voice interaction service supports returning
</span> a voice interactor for use by the activity. This is valid only for the duration of the
 activity.
@return {Boolean} whether the current voice interaction service supports local voice interaction
*/
isLocalVoiceInteractionSupported : function(  ) {},

<span id='android-app-Activity-method-startLocalVoiceInteraction'>/**Starts a local voice interaction session. When ready,
</span> {@link #onLocalVoiceInteractionStarted}() is called. You can pass a bundle of private options
 to the registered voice interaction service.
@param {Object {Bundle}} privateOptions a Bundle of private arguments to the current voice interaction service
*/
startLocalVoiceInteraction : function(  ) {},

<span id='android-app-Activity-method-onLocalVoiceInteractionStarted'>/**Callback to indicate that {@link #startLocalVoiceInteraction}(Bundle) has resulted in a
</span> voice interaction session being started. You can now retrieve a voice interactor using
 {@link #getVoiceInteractor}().
*/
onLocalVoiceInteractionStarted : function(  ) {},

<span id='android-app-Activity-method-onLocalVoiceInteractionStopped'>/**Callback to indicate that the local voice interaction has stopped either
</span> because it was requested through a call to {@link #stopLocalVoiceInteraction}()
 or because it was canceled by the user. The previously acquired {@link android.app.VoiceInteractor}
 is no longer valid after this.
*/
onLocalVoiceInteractionStopped : function(  ) {},

<span id='android-app-Activity-method-stopLocalVoiceInteraction'>/**Request to terminate the current voice interaction that was previously started
</span> using {@link #startLocalVoiceInteraction}(Bundle). When the interaction is
 terminated, {@link #onLocalVoiceInteractionStopped}() will be called.
*/
stopLocalVoiceInteraction : function(  ) {},

<span id='android-app-Activity-method-onSaveInstanceState'>/**This is the same as {@link #onSaveInstanceState} but is called for activities
</span> created with the attribute {@link android.R.attr#persistableMode} set to
 &lt;code&gt;persistAcrossReboots&lt;/code&gt;. The {@link android.os.PersistableBundle} passed
 in will be saved and presented in {@link #onCreate(Bundle, PersistableBundle)}
 the first time that this activity is restarted following the next device reboot.
@param {Object {Bundle}} outState Bundle in which to place your saved state.
@param {Object {PersistableBundle}} outPersistentState State which will be saved across reboots.
@see #onSaveInstanceState(Bundle)
@see #onCreate
@see #onRestoreInstanceState(Bundle, PersistableBundle)
@see #onPause
*/
onSaveInstanceState : function(  ) {},

<span id='android-app-Activity-method-onCreateThumbnail'>/**
</span>@deprecated Method doesn't do anything and will be removed in the future.
*/
onCreateThumbnail : function(  ) {},

<span id='android-app-Activity-method-onCreateDescription'>/**Generate a new description for this activity.  This method is called
</span> before stopping the activity and can, if desired, return some textual
 description of its current state to be displayed to the user.

 &lt;p&gt;The default implementation returns null, which will cause you to
 inherit the description from the previous activity.  If all activities
 return null, generally the label of the top activity will be used as the
 description.
@return {Object {java.lang.CharSequence}} A description of what the user is doing.  It should be short and
         sweet (only a few words).
@see #onSaveInstanceState
@see #onStop
*/
onCreateDescription : function(  ) {},

<span id='android-app-Activity-method-onProvideAssistData'>/**This is called when the user is requesting an assist, to build a full
</span> {@link Intent#ACTION_ASSIST} Intent with all of the context of the current
 application.  You can override this method to place into the bundle anything
 you would like to appear in the {@link Intent#EXTRA_ASSIST_CONTEXT} part
 of the assist Intent.

 &lt;p&gt;This function will be called after any global assist callbacks that had
 been registered with {@link android.app.Application#registerOnProvideAssistDataListener
 android.app.Application.registerOnProvideAssistDataListener}.
*/
onProvideAssistData : function(  ) {},

<span id='android-app-Activity-method-onProvideAssistContent'>/**This is called when the user is requesting an assist, to provide references
</span> to content related to the current activity.  Before being called, the
 {@code outContent} Intent is filled with the base Intent of the activity (the Intent
 returned by {@link #getIntent}()).  The Intent's extras are stripped of any types
 that are not valid for {@link PersistableBundle} or non-framework Parcelables, and
 the flags {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION} and
 {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} are cleared from the Intent.

 &lt;p&gt;Custom implementation may adjust the content intent to better reflect the top-level
 context of the activity, and fill in its ClipData with additional content of
 interest that the user is currently viewing.  For example, an image gallery application
 that has launched in to an activity allowing the user to swipe through pictures should
 modify the intent to reference the current image they are looking it; such an
 application when showing a list of pictures should add a ClipData that has
 references to all of the pictures currently visible on screen.&lt;/p&gt;
@param {Object {AssistContent}} outContent The assist content to return.
*/
onProvideAssistContent : function(  ) {},

<span id='android-app-Activity-method-onGetDirectActions'>/**Returns the list of direct actions supported by the app.
</span>
 &lt;p&gt;You should return the list of actions that could be executed in the
 current context, which is in the current state of the app. If the actions
 that could be executed by the app changes you should report that via
 calling {@link android.app.VoiceInteractor#notifyDirectActionsChanged()}.

 &lt;p&gt;To get the voice interactor you need to call {@link #getVoiceInteractor}()
 which would return non &lt;code&gt;null&lt;/code&gt; only if there is an ongoing voice
 interaction session. You an also detect when the voice interactor is no
 longer valid because the voice interaction session that is backing is finished
 by calling {@link android.app.VoiceInteractor#registerOnDestroyedCallback(Executor, Runnable)}.

 &lt;p&gt;This method will be called only after {@link #onStart}() is being called and
 before {@link #onStop}() is being called.

 &lt;p&gt;You should pass to the callback the currently supported direct actions which
 cannot be &lt;code&gt;null&lt;/code&gt; or contain &lt;code&gt;null&lt;/code&gt; elements.

 &lt;p&gt;You should return the action list as soon as possible to ensure the consumer,
 for example the assistant, is as responsive as possible which would improve user
 experience of your app.
@param {Object {CancellationSignal}} cancellationSignal A signal to cancel the operation in progress.
@param {Object {java.util.function.Consumer}} callback The callback to send the action list. The actions list cannot
     contain &lt;code&gt;null&lt;/code&gt; elements. You can call this on any thread.
*/
onGetDirectActions : function(  ) {},

<span id='android-app-Activity-method-onPerformDirectAction'>/**This is called to perform an action previously defined by the app.
</span> Apps also have access to {@link #getVoiceInteractor}() to follow up on the action.
@param {String} actionId The ID for the action you previously reported via
     {@link #onGetDirectActions(CancellationSignal, Consumer)}.
@param {Object {Bundle}} arguments Any additional arguments provided by the caller that are
     specific to the given action.
@param {Object {CancellationSignal}} cancellationSignal A signal to cancel the operation in progress.
@param {Object {java.util.function.Consumer}} resultListener The callback to provide the result back to the caller.
     You can call this on any thread. The result bundle is action specific.
@see #onGetDirectActions(CancellationSignal, Consumer)
*/
onPerformDirectAction : function(  ) {},

<span id='android-app-Activity-method-requestShowKeyboardShortcuts'>/**Request the Keyboard Shortcuts screen to show up. This will trigger
</span> {@link #onProvideKeyboardShortcuts} to retrieve the shortcuts for the foreground activity.
*/
requestShowKeyboardShortcuts : function(  ) {},

<span id='android-app-Activity-method-dismissKeyboardShortcutsHelper'>/**Dismiss the Keyboard Shortcuts screen.
</span>*/
dismissKeyboardShortcutsHelper : function(  ) {},

<span id='android-app-Activity-method-onProvideKeyboardShortcuts'>/**
</span>*/
onProvideKeyboardShortcuts : function(  ) {},

<span id='android-app-Activity-method-showAssist'>/**Ask to have the current assistant shown to the user.  This only works if the calling
</span> activity is the current foreground activity.  It is the same as calling
 {@link android.service.voice.VoiceInteractionService#showSession
 VoiceInteractionService.showSession} and requesting all of the possible context.
 The receiver will always see
 {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
@return {Boolean} Returns true if the assistant was successfully invoked, else false.  For example
 false will be returned if the caller is not the current top activity.
*/
showAssist : function(  ) {},

<span id='android-app-Activity-method-reportFullyDrawn'>/**Report to the system that your app is now fully drawn, purely for diagnostic
</span> purposes (calling it does not impact the visible behavior of the activity).
 This is only used to help instrument application launch times, so that the
 app can report when it is fully in a usable state; without this, the only thing
 the system itself can determine is the point at which the activity's window
 is &lt;em&gt;first&lt;/em&gt; drawn and displayed.  To participate in app launch time
 measurement, you should always call this method after first launch (when
 {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 entirely drawn your UI and populated with all of the significant data.  You
 can safely call this method any time after first launch as well, in which case
 it will simply be ignored.
*/
reportFullyDrawn : function(  ) {},

<span id='android-app-Activity-method-onMultiWindowModeChanged'>/**Called by the system when the activity changes from fullscreen mode to multi-window mode and
</span> visa-versa. This method provides the same configuration that will be sent in the following
 {@link #onConfigurationChanged}(Configuration) call after the activity enters this mode.
@param {Boolean} isInMultiWindowMode True if the activity is in multi-window mode.
@param {Object {Configuration}} newConfig The new configuration of the activity with the state
                  {@param isInMultiWindowMode}.
@param newConfig The new configuration of the activity with the state
                  {@param isInMultiWindowMode}.
*/
onMultiWindowModeChanged : function(  ) {},

<span id='android-app-Activity-method-onMultiWindowModeChanged'>/**Called by the system when the activity changes from fullscreen mode to multi-window mode and
</span> visa-versa.
@param {Boolean} isInMultiWindowMode True if the activity is in multi-window mode.
@param isInMultiWindowMode True if the activity is in multi-window mode.
@deprecated Use {@link #onMultiWindowModeChanged(boolean, Configuration)} instead.
*/
onMultiWindowModeChanged : function(  ) {},

<span id='android-app-Activity-method-isInMultiWindowMode'>/**Returns true if the activity is currently in multi-window mode.
</span>@see android.R.attr#resizeableActivity
@return {Boolean} True if the activity is in multi-window mode.
*/
isInMultiWindowMode : function(  ) {},

<span id='android-app-Activity-method-onPictureInPictureModeChanged'>/**Called by the system when the activity changes to and from picture-in-picture mode. This
</span> method provides the same configuration that will be sent in the following
 {@link #onConfigurationChanged}(Configuration) call after the activity enters this mode.
@param {Boolean} isInPictureInPictureMode True if the activity is in picture-in-picture mode.
@param {Object {Configuration}} newConfig The new configuration of the activity with the state
                  {@param isInPictureInPictureMode}.
@param newConfig The new configuration of the activity with the state
                  {@param isInPictureInPictureMode}.
*/
onPictureInPictureModeChanged : function(  ) {},

<span id='android-app-Activity-method-onPictureInPictureModeChanged'>/**Called by the system when the activity changes to and from picture-in-picture mode.
</span>@param {Boolean} isInPictureInPictureMode True if the activity is in picture-in-picture mode.
@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
@deprecated Use {@link #onPictureInPictureModeChanged(boolean, Configuration)} instead.
*/
onPictureInPictureModeChanged : function(  ) {},

<span id='android-app-Activity-method-isInPictureInPictureMode'>/**Returns true if the activity is currently in picture-in-picture mode.
</span>@see android.R.attr#supportsPictureInPicture
@return {Boolean} True if the activity is in picture-in-picture mode.
*/
isInPictureInPictureMode : function(  ) {},

<span id='android-app-Activity-method-enterPictureInPictureMode'>/**Puts the activity in picture-in-picture mode if possible in the current system state. Any
</span> prior calls to {@link #setPictureInPictureParams}(PictureInPictureParams) will still apply
 when entering picture-in-picture through this call.
@see #enterPictureInPictureMode(PictureInPictureParams)
@see android.R.attr#supportsPictureInPicture
*/
enterPictureInPictureMode : function(  ) {},

<span id='android-app-Activity-method-enterPictureInPictureMode'>/**
</span>@removed 
*/
enterPictureInPictureMode : function(  ) {},

<span id='android-app-Activity-method-enterPictureInPictureMode'>/**Puts the activity in picture-in-picture mode if possible in the current system state. The
</span> set parameters in {@param params} will be combined with the parameters from prior calls to
 {@link #setPictureInPictureParams}(PictureInPictureParams).

 The system may disallow entering picture-in-picture in various cases, including when the
 activity is not visible, if the screen is locked or if the user has an activity pinned.
@param {Object {PictureInPictureParams}} params non-null parameters to be combined with previously set parameters when entering
 picture-in-picture.
@see PictureInPictureParams
@param params non-null parameters to be combined with previously set parameters when entering
 picture-in-picture.
@return {Boolean} true if the system successfully put this activity into picture-in-picture mode or was
 already in picture-in-picture mode (see {@link #isInPictureInPictureMode()}). If the device
 does not support picture-in-picture, return false.
*/
enterPictureInPictureMode : function(  ) {},

<span id='android-app-Activity-method-setPictureInPictureArgs'>/**
</span>@removed 
*/
setPictureInPictureArgs : function(  ) {},

<span id='android-app-Activity-method-setPictureInPictureParams'>/**Updates the properties of the picture-in-picture activity, or sets it to be used later when
</span> {@link #enterPictureInPictureMode}() is called.
@param {Object {PictureInPictureParams}} params the new parameters for the picture-in-picture.
*/
setPictureInPictureParams : function(  ) {},

<span id='android-app-Activity-method-getMaxNumPictureInPictureActions'>/**Return the number of actions that will be displayed in the picture-in-picture UI when the
</span> user interacts with the activity currently in picture-in-picture mode. This number may change
 if the global configuration changes (ie. if the device is plugged into an external display),
 but will always be larger than three.
*/
getMaxNumPictureInPictureActions : function(  ) {},

<span id='android-app-Activity-method-onMovedToDisplay'>/**Called by the system when the activity is moved from one display to another without
</span> recreation. This means that this activity is declared to handle all changes to configuration
 that happened when it was switched to another display, so it wasn't destroyed and created
 again.

 &lt;p&gt;This call will be followed by {@link #onConfigurationChanged}(Configuration) if the
 applied configuration actually changed. It is up to app developer to choose whether to handle
 the change in this method or in the following {@link #onConfigurationChanged}(Configuration)
 call.

 &lt;p&gt;Use this callback to track changes to the displays if some activity functionality relies
 on an association with some display properties.
@param {Number} displayId The id of the display to which activity was moved.
@param {Object {Configuration}} config Configuration of the activity resources on new display after move.
@see #onConfigurationChanged(Configuration)
@see View#onMovedToDisplay(int, Configuration)
@hide 
*/
onMovedToDisplay : function(  ) {},

<span id='android-app-Activity-method-onConfigurationChanged'>/**Called by the system when the device configuration changes while your
</span> activity is running.  Note that this will &lt;em&gt;only&lt;/em&gt; be called if
 you have selected configurations you would like to handle with the
 {@link android.R.attr#configChanges} attribute in your manifest.  If
 any configuration change occurs that is not selected to be reported
 by that attribute, then instead of reporting it the system will stop
 and restart the activity (to have it launched with the new
 configuration).

 &lt;p&gt;At the time that this function has been called, your Resources
 object will have been updated to return resource values matching the
 new configuration.
@param {Object {Configuration}} newConfig The new device configuration.
*/
onConfigurationChanged : function(  ) {},

<span id='android-app-Activity-method-getChangingConfigurations'>/**If this activity is being destroyed because it can not handle a
</span> configuration parameter being changed (and thus its
 {@link #onConfigurationChanged}(Configuration) method is
 &lt;em&gt;not&lt;/em&gt; being called), then you can use this method to discover
 the set of changes that have occurred while in the process of being
 destroyed.  Note that there is no guarantee that these will be
 accurate (other changes could have happened at any time), so you should
 only use this as an optimization hint.
@return {Number} Returns a bit field of the configuration parameters that are
 changing, as defined by the {@link android.content.res.Configuration}
 class.
*/
getChangingConfigurations : function(  ) {},

<span id='android-app-Activity-method-getLastNonConfigurationInstance'>/**Retrieve the non-configuration instance data that was previously
</span> returned by {@link #onRetainNonConfigurationInstance}().  This will
 be available from the initial {@link #onCreate} and
 {@link #onStart} calls to the new instance, allowing you to extract
 any useful dynamic state from the previous instance.

 &lt;p&gt;Note that the data you retrieve here should &lt;em&gt;only&lt;/em&gt; be used
 as an optimization for handling configuration changes.  You should always
 be able to handle getting a null pointer back, and an activity must
 still be able to restore itself to its previous state (through the
 normal {@link #onSaveInstanceState}(Bundle) mechanism) even if this
 function returns null.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; For most cases you should use the {@link android.app.Fragment} API
 {@link android.app.Fragment#setRetainInstance(boolean)} instead; this is also
 available on older platforms through the Android support libraries.
@return {Object {java.lang.Object}} the object previously returned by {@link #onRetainNonConfigurationInstance()}
*/
getLastNonConfigurationInstance : function(  ) {},

<span id='android-app-Activity-method-onRetainNonConfigurationInstance'>/**Called by the system, as part of destroying an
</span> activity due to a configuration change, when it is known that a new
 instance will immediately be created for the new configuration.  You
 can return any object you like here, including the activity instance
 itself, which can later be retrieved by calling
 {@link #getLastNonConfigurationInstance}() in the new activity
 instance.

 &lt;em&gt;If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 or later, consider instead using a {@link android.app.Fragment} with
 {@link android.app.Fragment#setRetainInstance(boolean)
 android.app.Fragment.setRetainInstance(boolean}.&lt;/em&gt;

 &lt;p&gt;This function is called purely as an optimization, and you must
 not rely on it being called.  When it is called, a number of guarantees
 will be made to help optimize configuration switching:
 &lt;ul&gt;
 &lt;li&gt; The function will be called between {@link #onStop} and
 {@link #onDestroy}.
 &lt;li&gt; A new instance of the activity will &lt;em&gt;always&lt;/em&gt; be immediately
 created after this one's {@link #onDestroy}() is called.  In particular,
 &lt;em&gt;no&lt;/em&gt; messages will be dispatched during this time (when the returned
 object does not have an activity to be associated with).
 &lt;li&gt; The object you return here will &lt;em&gt;always&lt;/em&gt; be available from
 the {@link #getLastNonConfigurationInstance}() method of the following
 activity instance as described there.
 &lt;/ul&gt;

 &lt;p&gt;These guarantees are designed so that an activity can use this API
 to propagate extensive state from the old to new activity instance, from
 loaded bitmaps, to network connections, to evenly actively running
 threads.  Note that you should &lt;em&gt;not&lt;/em&gt; propagate any data that
 may change based on the configuration, including any data loaded from
 resources such as strings, layouts, or drawables.

 &lt;p&gt;The guarantee of no message handling during the switch to the next
 activity simplifies use with active objects.  For example if your retained
 state is an {@link android.os.AsyncTask} you are guaranteed that its
 call back functions (like {@link android.os.AsyncTask#onPostExecute}) will
 not be called from the call here until you execute the next instance's
 {@link #onCreate}(Bundle).  (Note however that there is of course no such
 guarantee for {@link android.os.AsyncTask#doInBackground} since that is
 running in a separate thread.)

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; For most cases you should use the {@link android.app.Fragment} API
 {@link android.app.Fragment#setRetainInstance(boolean)} instead; this is also
 available on older platforms through the Android support libraries.
@return {Object {java.lang.Object}} any Object holding the desired state to propagate to the
         next activity instance
*/
onRetainNonConfigurationInstance : function(  ) {},

<span id='android-app-Activity-method-onLowMemory'>/**
</span>*/
onLowMemory : function(  ) {},

<span id='android-app-Activity-method-onTrimMemory'>/**
</span>*/
onTrimMemory : function(  ) {},

<span id='android-app-Activity-method-getFragmentManager'>/**Return the FragmentManager for interacting with fragments associated
</span> with this activity.
@deprecated Use {@link android.support.v4.app.FragmentActivity#getSupportFragmentManager()}
*/
getFragmentManager : function(  ) {},

<span id='android-app-Activity-method-onAttachFragment'>/**Called when a Fragment is being attached to this activity, immediately
</span> after the call to its {@link android.app.Fragment#onAttach android.app.Fragment.onAttach()}
 method and before {@link android.app.Fragment#onCreate android.app.Fragment.onCreate()}.
@deprecated Use {@link
 android.support.v4.app.FragmentActivity#onAttachFragment(android.support.v4.app.Fragment)}
*/
onAttachFragment : function(  ) {},

<span id='android-app-Activity-method-managedQuery'>/**Wrapper around
</span> {@link ContentResolver#query(android.net.Uri , String[], String, String[], String)}
 that gives the resulting {@link Cursor} to call
 {@link #startManagingCursor} so that the activity will manage its
 lifecycle for you.

 &lt;em&gt;If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 or later, consider instead using {@link android.app.LoaderManager} instead, available
 via {@link #getLoaderManager}().&lt;/em&gt;

 &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Do not call {@link Cursor#close()} on a cursor obtained using
 this method, because the activity will do that for you at the appropriate time. However, if
 you call {@link #stopManagingCursor} on a cursor from a managed query, the system &lt;em&gt;will
 not&lt;/em&gt; automatically close the cursor and, in that case, you must call
 {@link Cursor#close()}.&lt;/p&gt;
@param {Object {Uri}} uri The URI of the content provider to query.
@param {Object {java.lang.String[]}} projection List of columns to return.
@param {String} selection SQL WHERE clause.
@param {String} sortOrder SQL ORDER BY clause.
@return {Object {android.database.Cursor}} The Cursor that was returned by query().
@see ContentResolver#query(android.net.Uri , String[], String, String[], String)
@see #startManagingCursor
@hide 
@deprecated Use {@link CursorLoader} instead.
*/
managedQuery : function(  ) {},

<span id='android-app-Activity-method-managedQuery'>/**Wrapper around
</span> {@link ContentResolver#query(android.net.Uri , String[], String, String[], String)}
 that gives the resulting {@link Cursor} to call
 {@link #startManagingCursor} so that the activity will manage its
 lifecycle for you.

 &lt;em&gt;If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 or later, consider instead using {@link android.app.LoaderManager} instead, available
 via {@link #getLoaderManager}().&lt;/em&gt;

 &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Do not call {@link Cursor#close()} on a cursor obtained using
 this method, because the activity will do that for you at the appropriate time. However, if
 you call {@link #stopManagingCursor} on a cursor from a managed query, the system &lt;em&gt;will
 not&lt;/em&gt; automatically close the cursor and, in that case, you must call
 {@link Cursor#close()}.&lt;/p&gt;
@param {Object {Uri}} uri The URI of the content provider to query.
@param {Object {java.lang.String[]}} projection List of columns to return.
@param {String} selection SQL WHERE clause.
@param {Object {java.lang.String[]}} selectionArgs The arguments to selection, if any ?s are pesent
@param {String} sortOrder SQL ORDER BY clause.
@return {Object {android.database.Cursor}} The Cursor that was returned by query().
@see ContentResolver#query(android.net.Uri , String[], String, String[], String)
@see #startManagingCursor
@deprecated Use {@link CursorLoader} instead.
*/
managedQuery : function(  ) {},

<span id='android-app-Activity-method-startManagingCursor'>/**This method allows the activity to take care of managing the given
</span> {@link Cursor}'s lifecycle for you based on the activity's lifecycle.
 That is, when the activity is stopped it will automatically call
 {@link Cursor#deactivate} on the given Cursor, and when it is later restarted
 it will call {@link Cursor#requery} for you.  When the activity is
 destroyed, all managed Cursors will be closed automatically.

 &lt;em&gt;If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 or later, consider instead using {@link android.app.LoaderManager} instead, available
 via {@link #getLoaderManager}().&lt;/em&gt;

 &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Do not call {@link Cursor#close()} on cursor obtained from
 {@link #managedQuery}, because the activity will do that for you at the appropriate time.
 However, if you call {@link #stopManagingCursor} on a cursor from a managed query, the system
 &lt;em&gt;will not&lt;/em&gt; automatically close the cursor and, in that case, you must call
 {@link Cursor#close()}.&lt;/p&gt;
@param {Object {Cursor}} c The Cursor to be managed.
@see #managedQuery(android.net.Uri , String[], String, String[], String)
@see #stopManagingCursor
@deprecated Use the new {@link android.content.CursorLoader} class with
 {@link LoaderManager} instead; this is also
 available on older platforms through the Android compatibility package.
*/
startManagingCursor : function(  ) {},

<span id='android-app-Activity-method-stopManagingCursor'>/**Given a Cursor that was previously given to
</span> {@link #startManagingCursor}, stop the activity's management of that
 cursor.

 &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; After calling this method on a cursor from a managed query,
 the system &lt;em&gt;will not&lt;/em&gt; automatically close the cursor and you must call
 {@link Cursor#close()}.&lt;/p&gt;
@param {Object {Cursor}} c The Cursor that was being managed.
@see #startManagingCursor
@deprecated Use the new {@link android.content.CursorLoader} class with
 {@link LoaderManager} instead; this is also
 available on older platforms through the Android compatibility package.
*/
stopManagingCursor : function(  ) {},

<span id='android-app-Activity-method-setPersistent'>/**
</span>@deprecated As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}
 this is a no-op.
@hide 
*/
setPersistent : function(  ) {},

<span id='android-app-Activity-method-findViewById'>/**Finds a view that was identified by the {@code android:id} XML attribute
</span> that was processed in {@link #onCreate}.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support --
 the resulting view is automatically cast to the target class type. If
 the target class type is unconstrained, an explicit cast may be
 necessary.
@param {Number} id the ID to search for
@return {Object {android.view.View}} a view with given ID if found, or {@code null} otherwise
@see View#findViewById(int)
@see Activity#requireViewById(int)
*/
findViewById : function(  ) {},

<span id='android-app-Activity-method-requireViewById'>/**Finds a view that was  identified by the {@code android:id} XML attribute that was processed
</span> in {@link #onCreate}, or throws an IllegalArgumentException if the ID is invalid, or there is
 no matching view in the hierarchy.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support --
 the resulting view is automatically cast to the target class type. If
 the target class type is unconstrained, an explicit cast may be
 necessary.
@param {Number} id the ID to search for
@return {Object {android.view.View}} a view with given ID
@see View#requireViewById(int)
@see Activity#findViewById(int)
*/
requireViewById : function(  ) {},

<span id='android-app-Activity-method-getActionBar'>/**Retrieve a reference to this activity's ActionBar.
</span>@return {Object {android.app.ActionBar}} The Activity's ActionBar, or null if it does not have one.
*/
getActionBar : function(  ) {},

<span id='android-app-Activity-method-setActionBar'>/**Set a {@link android.widget.Toolbar Toolbar} to act as the {@link android.app.ActionBar} for this
</span> Activity window.

 &lt;p&gt;When set to a non-null value the {@link #getActionBar}() method will return
 an {@link android.app.ActionBar} object that can be used to control the given toolbar as if it were
 a traditional window decor action bar. The toolbar's menu will be populated with the
 Activity's options menu and the navigation button will be wired through the standard
 {@link android.R.id#home home} menu select action.&lt;/p&gt;

 &lt;p&gt;In order to use a Toolbar within the Activity's window content the application
 must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.&lt;/p&gt;
@param {Object {Toolbar}} toolbar Toolbar to set as the Activity's action bar, or {@code null} to clear it
*/
setActionBar : function(  ) {},

<span id='android-app-Activity-method-setContentView'>/**Set the activity content from a layout resource.  The resource will be
</span> inflated, adding all top-level views to the activity.
@param {Number} layoutResID Resource ID to be inflated.
@see #setContentView(android.view.View)
@see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
*/
setContentView : function(  ) {},

<span id='android-app-Activity-method-setContentView'>/**Set the activity content to an explicit view.  This view is placed
</span> directly into the activity's view hierarchy.  It can itself be a complex
 view hierarchy.  When calling this method, the layout parameters of the
 specified view are ignored.  Both the width and the height of the view are
 set by default to {@link ViewGroup.LayoutParams#MATCH_PARENT}. To use
 your own layout parameters, invoke
 {@link #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)}
 instead.
@param {Object {View}} view The desired content to display.
@see #setContentView(int)
@see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
*/
setContentView : function(  ) {},

<span id='android-app-Activity-method-setContentView'>/**Set the activity content to an explicit view.  This view is placed
</span> directly into the activity's view hierarchy.  It can itself be a complex
 view hierarchy.
@param {Object {View}} view The desired content to display.
@param {Object {ViewGroup.LayoutParams}} params Layout parameters for the view.
@see #setContentView(android.view.View)
@see #setContentView(int)
*/
setContentView : function(  ) {},

<span id='android-app-Activity-method-addContentView'>/**Add an additional content view to the activity.  Added after any existing
</span> ones in the activity -- existing views are NOT removed.
@param {Object {View}} view The desired content to display.
@param {Object {ViewGroup.LayoutParams}} params Layout parameters for the view.
*/
addContentView : function(  ) {},

<span id='android-app-Activity-method-getContentTransitionManager'>/**Retrieve the {@link android.app.FragmentTransaction.TransitionManager} responsible for default transitions in this window.
</span> Requires {@link Window#FEATURE_CONTENT_TRANSITIONS}.

 &lt;p&gt;This method will return non-null after content has been initialized (e.g. by using
 {@link #setContentView}) if {@link Window#FEATURE_CONTENT_TRANSITIONS} has been granted.&lt;/p&gt;
@return {Object {android.transition.TransitionManager}} This window's content TransitionManager or null if none is set.
*/
getContentTransitionManager : function(  ) {},

<span id='android-app-Activity-method-setContentTransitionManager'>/**Set the {@link android.app.FragmentTransaction.TransitionManager} to use for default transitions in this window.
</span> Requires {@link Window#FEATURE_CONTENT_TRANSITIONS}.
@param {Object {TransitionManager}} tm The TransitionManager to use for scene changes.
*/
setContentTransitionManager : function(  ) {},

<span id='android-app-Activity-method-getContentScene'>/**Retrieve the {@link Scene} representing this window's current content.
</span> Requires {@link Window#FEATURE_CONTENT_TRANSITIONS}.

 &lt;p&gt;This method will return null if the current content is not represented by a Scene.&lt;/p&gt;
@return {Object {android.transition.Scene}} Current Scene being shown or null
*/
getContentScene : function(  ) {},

<span id='android-app-Activity-method-setFinishOnTouchOutside'>/**Sets whether this activity is finished when touched outside its window's
</span> bounds.
*/
setFinishOnTouchOutside : function(  ) {},

<span id='android-app-Activity-method-setDefaultKeyMode'>/**Select the default key handling for this activity.  This controls what
</span> will happen to key events that are not otherwise handled.  The default
 mode ({@link #DEFAULT_KEYS_DISABLE}) will simply drop them on the
 floor. Other modes allow you to launch the dialer
 ({@link #DEFAULT_KEYS_DIALER}), execute a shortcut in your options
 menu without requiring the menu key be held down
 ({@link #DEFAULT_KEYS_SHORTCUT}), or launch a search ({@link #DEFAULT_KEYS_SEARCH_LOCAL}
 and {@link #DEFAULT_KEYS_SEARCH_GLOBAL}).

 &lt;p&gt;Note that the mode selected here does not impact the default
 handling of system keys, such as the &quot;back&quot; and &quot;menu&quot; keys, and your
 activity and its views always get a first chance to receive and handle
 all application keys.
@param {Number} mode The desired default key mode constant.
@see #onKeyDown
*/
setDefaultKeyMode : function(  ) {},

<span id='android-app-Activity-method-onKeyDown'>/**Called when a key was pressed down and not handled by any of the views
</span> inside of the activity. So, for example, key presses while the cursor
 is inside a TextView will not trigger the event (unless it is a navigation
 to another object) because TextView handles its own key presses.

 &lt;p&gt;If the focused view didn't want this event, this method is called.

 &lt;p&gt;The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 by calling {@link #onBackPressed}(), though the behavior varies based
 on the application compatibility mode: for
 {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 it will set up the dispatch to call {@link #onKeyUp} where the action
 will be performed; for earlier applications, it will perform the
 action immediately in on-down, as those versions of the platform
 behaved.

 &lt;p&gt;Other additional default key handling may be performed
 if configured with {@link #setDefaultKeyMode}.
@return {Boolean} Return &lt;code&gt;true&lt;/code&gt; to prevent this event from being propagated
 further, or &lt;code&gt;false&lt;/code&gt; to indicate that you have not handled
 this event and it should continue to be propagated.
@see #onKeyUp
@see android.view.KeyEvent
*/
onKeyDown : function(  ) {},

<span id='android-app-Activity-method-onKeyLongPress'>/**Default implementation of {@link KeyEvent.Callback#onKeyLongPress(int, KeyEvent)
</span> KeyEvent.Callback.onKeyLongPress()}: always returns false (doesn't handle
 the event).

 To receive this callback, you must return true from onKeyDown for the current
 event stream.
@see KeyEvent.Callback#onKeyLongPress()
@see KeyEvent.Callback#onKeyLongPress(int, KeyEvent)
*/
onKeyLongPress : function(  ) {},

<span id='android-app-Activity-method-onKeyUp'>/**Called when a key was released and not handled by any of the views
</span> inside of the activity. So, for example, key presses while the cursor
 is inside a TextView will not trigger the event (unless it is a navigation
 to another object) because TextView handles its own key presses.

 &lt;p&gt;The default implementation handles KEYCODE_BACK to stop the activity
 and go back.
@return {Boolean} Return &lt;code&gt;true&lt;/code&gt; to prevent this event from being propagated
 further, or &lt;code&gt;false&lt;/code&gt; to indicate that you have not handled
 this event and it should continue to be propagated.
@see #onKeyDown
@see KeyEvent
*/
onKeyUp : function(  ) {},

<span id='android-app-Activity-method-onKeyMultiple'>/**Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
</span> KeyEvent.Callback.onKeyMultiple()}: always returns false (doesn't handle
 the event).
*/
onKeyMultiple : function(  ) {},

<span id='android-app-Activity-method-onBackPressed'>/**Called when the activity has detected the user's press of the back
</span> key.  The default implementation simply finishes the current activity,
 but you can override this to do whatever you want.
*/
onBackPressed : function(  ) {},

<span id='android-app-Activity-method-onKeyShortcut'>/**Called when a key shortcut event is not handled by any of the views in the Activity.
</span> Override this method to implement global key shortcuts for the Activity.
 Key shortcuts can also be implemented by setting the
 {@link MenuItem#setShortcut(char, char) shortcut} property of menu items.
@param {Number} keyCode The value in event.getKeyCode().
@param {Object {KeyEvent}} event Description of the key event.
@return {Boolean} True if the key shortcut was handled.
*/
onKeyShortcut : function(  ) {},

<span id='android-app-Activity-method-onTouchEvent'>/**Called when a touch screen event was not handled by any of the views
</span> under it.  This is most useful to process touch events that happen
 outside of your window bounds, where there is no view to receive it.
@param {Object {MotionEvent}} event The touch screen event being processed.
@return {Boolean} Return true if you have consumed the event, false if you haven't.
 The default implementation always returns false.
*/
onTouchEvent : function(  ) {},

<span id='android-app-Activity-method-onTrackballEvent'>/**Called when the trackball was moved and not handled by any of the
</span> views inside of the activity.  So, for example, if the trackball moves
 while focus is on a button, you will receive a call here because
 buttons do not normally do anything with trackball events.  The call
 here happens &lt;em&gt;before&lt;/em&gt; trackball movements are converted to
 DPAD key events, which then get sent back to the view hierarchy, and
 will be processed at the point for things like focus navigation.
@param {Object {MotionEvent}} event The trackball event being processed.
@return {Boolean} Return true if you have consumed the event, false if you haven't.
 The default implementation always returns false.
*/
onTrackballEvent : function(  ) {},

<span id='android-app-Activity-method-onGenericMotionEvent'>/**Called when a generic motion event was not handled by any of the
</span> views inside of the activity.
 &lt;p&gt;
 Generic motion events describe joystick movements, mouse hovers, track pad
 touches, scroll wheel movements and other input events.  The
 {@link MotionEvent#getSource() source} of the motion event specifies
 the class of input that was received.  Implementations of this method
 must examine the bits in the source before processing the event.
 The following code example shows how this is done.
 &lt;/p&gt;&lt;p&gt;
 Generic motion events with source class
 {@link android.view.InputDevice#SOURCE_CLASS_POINTER}
 are delivered to the view under the pointer.  All other generic motion events are
 delivered to the focused view.
 &lt;/p&gt;&lt;p&gt;
 See {@link View#onGenericMotionEvent(MotionEvent)} for an example of how to
 handle this event.
 &lt;/p&gt;
@param {Object {MotionEvent}} event The generic motion event being processed.
@return {Boolean} Return true if you have consumed the event, false if you haven't.
 The default implementation always returns false.
*/
onGenericMotionEvent : function(  ) {},

<span id='android-app-Activity-method-onUserInteraction'>/**Called whenever a key, touch, or trackball event is dispatched to the
</span> activity.  Implement this method if you wish to know that the user has
 interacted with the device in some way while your activity is running.
 This callback and {@link #onUserLeaveHint} are intended to help
 activities manage status bar notifications intelligently; specifically,
 for helping activities determine the proper time to cancel a notification.

 &lt;p&gt;All calls to your activity's {@link #onUserLeaveHint} callback will
 be accompanied by calls to {@link #onUserInteraction}.  This
 ensures that your activity will be told of relevant user activity such
 as pulling down the notification pane and touching an item there.

 &lt;p&gt;Note that this callback will be invoked for the touch down action
 that begins a touch gesture, but may not be invoked for the touch-moved
 and touch-up actions that follow.
@see #onUserLeaveHint()
*/
onUserInteraction : function(  ) {},

<span id='android-app-Activity-method-onWindowAttributesChanged'>/**
</span>*/
onWindowAttributesChanged : function(  ) {},

<span id='android-app-Activity-method-onContentChanged'>/**
</span>*/
onContentChanged : function(  ) {},

<span id='android-app-Activity-method-onWindowFocusChanged'>/**Called when the current {@link Window} of the activity gains or loses
</span> focus. This is the best indicator of whether this activity is the entity
 with which the user actively interacts. The default implementation
 clears the key tracking state, so should always be called.

 &lt;p&gt;Note that this provides information about global focus state, which
 is managed independently of activity lifecycle.  As such, while focus
 changes will generally have some relation to lifecycle changes (an
 activity that is stopped will not generally get window focus), you
 should not rely on any particular order between the callbacks here and
 those in the other lifecycle methods such as {@link #onResume}.

 &lt;p&gt;As a general rule, however, a foreground activity will have window
 focus...  unless it has displayed other dialogs or popups that take
 input focus, in which case the activity itself will not have focus
 when the other windows have it.  Likewise, the system may display
 system-level windows (such as the status bar notification panel or
 a system alert) which will temporarily take window input focus without
 pausing the foreground activity.

 &lt;p&gt;Starting with {@link android.os.Build.VERSION_CODES#Q} there can be
 multiple resumed activities at the same time in multi-window mode, so
 resumed state does not guarantee window focus even if there are no
 overlays above.

 &lt;p&gt;If the intent is to know when an activity is the topmost active, the
 one the user interacted with last among all activities but not including
 non-activity windows like dialogs and popups, then
 {@link #onTopResumedActivityChanged}(boolean) should be used. On platform
 versions prior to {@link android.os.Build.VERSION_CODES#Q},
 {@link #onResume} is the best indicator.
@param {Boolean} hasFocus Whether the window of this activity has focus.
@see #hasWindowFocus()
@see #onResume
@see View#onWindowFocusChanged(boolean)
@see #onTopResumedActivityChanged(boolean)
*/
onWindowFocusChanged : function(  ) {},

<span id='android-app-Activity-method-onAttachedToWindow'>/**Called when the main window associated with the activity has been
</span> attached to the window manager.
 See {@link View#onAttachedToWindow() View.onAttachedToWindow()}
 for more information.
@see View#onAttachedToWindow
*/
onAttachedToWindow : function(  ) {},

<span id='android-app-Activity-method-onDetachedFromWindow'>/**Called when the main window associated with the activity has been
</span> detached from the window manager.
 See {@link View#onDetachedFromWindow() View.onDetachedFromWindow()}
 for more information.
@see View#onDetachedFromWindow
*/
onDetachedFromWindow : function(  ) {},

<span id='android-app-Activity-method-hasWindowFocus'>/**Returns true if this activity's &lt;em&gt;main&lt;/em&gt; window currently has window focus.
</span> Note that this is not the same as the view itself having focus.
@return {Boolean} True if this activity's main window currently has window focus.
@see #onWindowAttributesChanged(android.view.WindowManager.LayoutParams)
*/
hasWindowFocus : function(  ) {},

<span id='android-app-Activity-method-onWindowDismissed'>/**Called when the main window associated with the activity has been dismissed.
</span>@hide 
*/
onWindowDismissed : function(  ) {},

<span id='android-app-Activity-method-toggleFreeformWindowingMode'>/**Moves the activity between {@link android.app.WindowConfiguration.WindowConfiguration#WINDOWING_MODE_FREEFORM} windowing mode
</span> and {@link android.app.WindowConfiguration.WindowConfiguration#WINDOWING_MODE_FULLSCREEN}.
@hide 
*/
toggleFreeformWindowingMode : function(  ) {},

<span id='android-app-Activity-method-enterPictureInPictureModeIfPossible'>/**Puts the activity in picture-in-picture mode if the activity supports.
</span>@see android.R.attr#supportsPictureInPicture
@hide 
*/
enterPictureInPictureModeIfPossible : function(  ) {},

<span id='android-app-Activity-method-dispatchKeyEvent'>/**Called to process key events.  You can override this to intercept all
</span> key events before they are dispatched to the window.  Be sure to call
 this implementation for key events that should be handled normally.
@param {Object {KeyEvent}} event The key event.
@return {Boolean} boolean Return true if this event was consumed.
*/
dispatchKeyEvent : function(  ) {},

<span id='android-app-Activity-method-dispatchKeyShortcutEvent'>/**Called to process a key shortcut event.
</span> You can override this to intercept all key shortcut events before they are
 dispatched to the window.  Be sure to call this implementation for key shortcut
 events that should be handled normally.
@param {Object {KeyEvent}} event The key shortcut event.
@return {Boolean} True if this event was consumed.
*/
dispatchKeyShortcutEvent : function(  ) {},

<span id='android-app-Activity-method-dispatchTouchEvent'>/**Called to process touch screen events.  You can override this to
</span> intercept all touch screen events before they are dispatched to the
 window.  Be sure to call this implementation for touch screen events
 that should be handled normally.
@param {Object {MotionEvent}} ev The touch screen event.
@return {Boolean} boolean Return true if this event was consumed.
*/
dispatchTouchEvent : function(  ) {},

<span id='android-app-Activity-method-dispatchTrackballEvent'>/**Called to process trackball events.  You can override this to
</span> intercept all trackball events before they are dispatched to the
 window.  Be sure to call this implementation for trackball events
 that should be handled normally.
@param {Object {MotionEvent}} ev The trackball event.
@return {Boolean} boolean Return true if this event was consumed.
*/
dispatchTrackballEvent : function(  ) {},

<span id='android-app-Activity-method-dispatchGenericMotionEvent'>/**Called to process generic motion events.  You can override this to
</span> intercept all generic motion events before they are dispatched to the
 window.  Be sure to call this implementation for generic motion events
 that should be handled normally.
@param {Object {MotionEvent}} ev The generic motion event.
@return {Boolean} boolean Return true if this event was consumed.
*/
dispatchGenericMotionEvent : function(  ) {},

<span id='android-app-Activity-method-dispatchPopulateAccessibilityEvent'>/**
</span>*/
dispatchPopulateAccessibilityEvent : function(  ) {},

<span id='android-app-Activity-method-onCreatePanelView'>/**Default implementation of
</span> {@link android.view.Window.Callback#onCreatePanelView}
 for activities. This
 simply returns null so that all panel sub-windows will have the default
 menu behavior.
*/
onCreatePanelView : function(  ) {},

<span id='android-app-Activity-method-onCreatePanelMenu'>/**Default implementation of
</span> {@link android.view.Window.Callback#onCreatePanelMenu}
 for activities.  This calls through to the new
 {@link #onCreateOptionsMenu} method for the
 {@link android.view.Window#FEATURE_OPTIONS_PANEL} panel,
 so that subclasses of Activity don't need to deal with feature codes.
*/
onCreatePanelMenu : function(  ) {},

<span id='android-app-Activity-method-onPreparePanel'>/**Default implementation of
</span> {@link android.view.Window.Callback#onPreparePanel}
 for activities.  This
 calls through to the new {@link #onPrepareOptionsMenu} method for the
 {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 panel, so that subclasses of
 Activity don't need to deal with feature codes.
*/
onPreparePanel : function(  ) {},

<span id='android-app-Activity-method-onMenuOpened'>/**{@inheritDoc}
</span>@return {Boolean} The default implementation returns true.
*/
onMenuOpened : function(  ) {},

<span id='android-app-Activity-method-onMenuItemSelected'>/**Default implementation of
</span> {@link android.view.Window.Callback#onMenuItemSelected}
 for activities.  This calls through to the new
 {@link #onOptionsItemSelected} method for the
 {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 panel, so that subclasses of
 Activity don't need to deal with feature codes.
*/
onMenuItemSelected : function(  ) {},

<span id='android-app-Activity-method-onPanelClosed'>/**Default implementation of
</span> {@link android.view.Window.Callback#onPanelClosed(int, Menu)} for
 activities. This calls through to {@link #onOptionsMenuClosed}(Menu)
 method for the {@link android.view.Window#FEATURE_OPTIONS_PANEL} panel,
 so that subclasses of Activity don't need to deal with feature codes.
 For context menus ({@link Window#FEATURE_CONTEXT_MENU}), the
 {@link #onContextMenuClosed}(Menu) will be called.
*/
onPanelClosed : function(  ) {},

<span id='android-app-Activity-method-invalidateOptionsMenu'>/**Declare that the options menu has changed, so should be recreated.
</span> The {@link #onCreateOptionsMenu}(Menu) method will be called the next
 time it needs to be displayed.
*/
invalidateOptionsMenu : function(  ) {},

<span id='android-app-Activity-method-onCreateOptionsMenu'>/**Initialize the contents of the Activity's standard options menu.  You
</span> should place your menu items in to &lt;var&gt;menu&lt;/var&gt;.

 &lt;p&gt;This is only called once, the first time the options menu is
 displayed.  To update the menu every time it is displayed, see
 {@link #onPrepareOptionsMenu}.

 &lt;p&gt;The default implementation populates the menu with standard system
 menu items.  These are placed in the {@link Menu#CATEGORY_SYSTEM} group so that
 they will be correctly ordered with application-defined menu items.
 Deriving classes should always call through to the base implementation.

 &lt;p&gt;You can safely hold on to &lt;var&gt;menu&lt;/var&gt; (and any items created
 from it), making modifications to it as desired, until the next
 time onCreateOptionsMenu() is called.

 &lt;p&gt;When you add items to the menu, you can implement the Activity's
 {@link #onOptionsItemSelected} method to handle them there.
@param {Object {Menu}} menu The options menu in which you place your items.
@return {Boolean} You must return true for the menu to be displayed;
         if you return false it will not be shown.
@see #onPrepareOptionsMenu
@see #onOptionsItemSelected
*/
onCreateOptionsMenu : function(  ) {},

<span id='android-app-Activity-method-onPrepareOptionsMenu'>/**Prepare the Screen's standard options menu to be displayed.  This is
</span> called right before the menu is shown, every time it is shown.  You can
 use this method to efficiently enable/disable items or otherwise
 dynamically modify the contents.

 &lt;p&gt;The default implementation updates the system menu items based on the
 activity's state.  Deriving classes should always call through to the
 base class implementation.
@param {Object {Menu}} menu The options menu as last shown or first initialized by
             onCreateOptionsMenu().
@return {Boolean} You must return true for the menu to be displayed;
         if you return false it will not be shown.
@see #onCreateOptionsMenu
*/
onPrepareOptionsMenu : function(  ) {},

<span id='android-app-Activity-method-onOptionsItemSelected'>/**This hook is called whenever an item in your options menu is selected.
</span> The default implementation simply returns false to have the normal
 processing happen (calling the item's Runnable or sending a message to
 its Handler as appropriate).  You can use this method for any items
 for which you would like to do processing without those other
 facilities.

 &lt;p&gt;Derived classes should call through to the base class for it to
 perform the default menu handling.&lt;/p&gt;
@param {Object {MenuItem}} item The menu item that was selected.
@return {Boolean} boolean Return false to allow normal menu processing to
         proceed, true to consume it here.
@see #onCreateOptionsMenu
*/
onOptionsItemSelected : function(  ) {},

<span id='android-app-Activity-method-onNavigateUp'>/**This method is called whenever the user chooses to navigate Up within your application's
</span> activity hierarchy from the action bar.

 &lt;p&gt;If the attribute {@link android.R.attr#parentActivityName parentActivityName}
 was specified in the manifest for this activity or an activity-alias to it,
 default Up navigation will be handled automatically. If any activity
 along the parent chain requires extra Intent arguments, the Activity subclass
 should override the method {@link #onPrepareNavigateUpTaskStack}(TaskStackBuilder)
 to supply those arguments.&lt;/p&gt;

 &lt;p&gt;See &lt;a href=&quot;{@docRoot}guide/components/tasks-and-back-stack.html&quot;&gt;Tasks and Back Stack&lt;/a&gt;
 from the developer guide and &lt;a href=&quot;{@docRoot}design/patterns/navigation.html&quot;&gt;Navigation&lt;/a&gt;
 from the design guide for more information about navigating within your app.&lt;/p&gt;

 &lt;p&gt;See the {@link android.app.TaskStackBuilder} class and the Activity methods
 {@link #getParentActivityIntent}(), {@link #shouldUpRecreateTask}(Intent), and
 {@link #navigateUpTo}(Intent) for help implementing custom Up navigation.
 The AppNavigation sample application in the Android SDK is also available for reference.&lt;/p&gt;
@return {Boolean} true if Up navigation completed successfully and this Activity was finished,
         false otherwise.
*/
onNavigateUp : function(  ) {},

<span id='android-app-Activity-method-onNavigateUpFromChild'>/**This is called when a child activity of this one attempts to navigate up.
</span> The default implementation simply calls onNavigateUp() on this activity (the parent).
@param {Object {Activity}} child The activity making the call.
*/
onNavigateUpFromChild : function(  ) {},

<span id='android-app-Activity-method-onCreateNavigateUpTaskStack'>/**Define the synthetic task stack that will be generated during Up navigation from
</span> a different task.

 &lt;p&gt;The default implementation of this method adds the parent chain of this activity
 as specified in the manifest to the supplied {@link android.app.TaskStackBuilder}. Applications
 may choose to override this method to construct the desired task stack in a different
 way.&lt;/p&gt;

 &lt;p&gt;This method will be invoked by the default implementation of {@link #onNavigateUp}()
 if {@link #shouldUpRecreateTask}(Intent) returns true when supplied with the intent
 returned by {@link #getParentActivityIntent}().&lt;/p&gt;

 &lt;p&gt;Applications that wish to supply extra Intent parameters to the parent stack defined
 by the manifest should override {@link #onPrepareNavigateUpTaskStack}(TaskStackBuilder).&lt;/p&gt;
@param {Object {TaskStackBuilder}} builder An empty TaskStackBuilder - the application should add intents representing
                the desired task stack
*/
onCreateNavigateUpTaskStack : function(  ) {},

<span id='android-app-Activity-method-onPrepareNavigateUpTaskStack'>/**Prepare the synthetic task stack that will be generated during Up navigation
</span> from a different task.

 &lt;p&gt;This method receives the {@link android.app.TaskStackBuilder} with the constructed series of
 Intents as generated by {@link #onCreateNavigateUpTaskStack}(TaskStackBuilder).
 If any extra data should be added to these intents before launching the new task,
 the application should override this method and add that data here.&lt;/p&gt;
@param {Object {TaskStackBuilder}} builder A TaskStackBuilder that has been populated with Intents by
                onCreateNavigateUpTaskStack.
*/
onPrepareNavigateUpTaskStack : function(  ) {},

<span id='android-app-Activity-method-onOptionsMenuClosed'>/**This hook is called whenever the options menu is being closed (either by the user canceling
</span> the menu with the back/menu button, or when an item is selected).
@param {Object {Menu}} menu The options menu as last shown or first initialized by
             onCreateOptionsMenu().
*/
onOptionsMenuClosed : function(  ) {},

<span id='android-app-Activity-method-openOptionsMenu'>/**Programmatically opens the options menu. If the options menu is already
</span> open, this method does nothing.
*/
openOptionsMenu : function(  ) {},

<span id='android-app-Activity-method-closeOptionsMenu'>/**Progammatically closes the options menu. If the options menu is already
</span> closed, this method does nothing.
*/
closeOptionsMenu : function(  ) {},

<span id='android-app-Activity-method-onCreateContextMenu'>/**Called when a context menu for the {@code view} is about to be shown.
</span> Unlike {@link #onCreateOptionsMenu}(Menu), this will be called every
 time the context menu is about to be shown and should be populated for
 the view (or item inside the view for {@link AdapterView} subclasses,
 this can be found in the {@code menuInfo})).
 &lt;p&gt;
 Use {@link #onContextItemSelected(android.view.MenuItem)} to know when an
 item has been selected.
 &lt;p&gt;
 It is not safe to hold onto the context menu after this method returns.
*/
onCreateContextMenu : function(  ) {},

<span id='android-app-Activity-method-registerForContextMenu'>/**Registers a context menu to be shown for the given view (multiple views
</span> can show the context menu). This method will set the
 {@link OnCreateContextMenuListener} on the view to this activity, so
 {@link #onCreateContextMenu(ContextMenu, View, ContextMenuInfo)} will be
 called when it is time to show the context menu.
@param {Object {View}} view The view that should show a context menu.
@param view The view that should show a context menu.
*/
registerForContextMenu : function(  ) {},

<span id='android-app-Activity-method-unregisterForContextMenu'>/**Prevents a context menu to be shown for the given view. This method will remove the
</span> {@link OnCreateContextMenuListener} on the view.
@param {Object {View}} view The view that should stop showing a context menu.
@param view The view that should stop showing a context menu.
*/
unregisterForContextMenu : function(  ) {},

<span id='android-app-Activity-method-openContextMenu'>/**Programmatically opens the context menu for a particular {@code view}.
</span> The {@code view} should have been added via
 {@link #registerForContextMenu}(View).
@param {Object {View}} view The view to show the context menu for.
*/
openContextMenu : function(  ) {},

<span id='android-app-Activity-method-closeContextMenu'>/**Programmatically closes the most recently opened context menu, if showing.
</span>*/
closeContextMenu : function(  ) {},

<span id='android-app-Activity-method-onContextItemSelected'>/**This hook is called whenever an item in a context menu is selected. The
</span> default implementation simply returns false to have the normal processing
 happen (calling the item's Runnable or sending a message to its Handler
 as appropriate). You can use this method for any items for which you
 would like to do processing without those other facilities.
 &lt;p&gt;
 Use {@link MenuItem#getMenuInfo()} to get extra information set by the
 View that added this menu item.
 &lt;p&gt;
 Derived classes should call through to the base class for it to perform
 the default menu handling.
@param {Object {MenuItem}} item The context menu item that was selected.
@return {Boolean} boolean Return false to allow normal context menu processing to
         proceed, true to consume it here.
*/
onContextItemSelected : function(  ) {},

<span id='android-app-Activity-method-onContextMenuClosed'>/**This hook is called whenever the context menu is being closed (either by
</span> the user canceling the menu with the back/menu button, or when an item is
 selected).
@param {Object {Menu}} menu The context menu that is being closed.
*/
onContextMenuClosed : function(  ) {},

<span id='android-app-Activity-method-showDialog'>/**Simple version of {@link #showDialog(int, Bundle)} that does not
</span> take any arguments.  Simply calls {@link #showDialog(int, Bundle)}
 with null arguments.
@deprecated Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.
*/
showDialog : function(  ) {},

<span id='android-app-Activity-method-showDialog'>/**Show a dialog managed by this activity.  A call to {@link #onCreateDialog(int, Bundle)}
</span> will be made with the same id the first time this is called for a given
 id.  From thereafter, the dialog will be automatically saved and restored.

 &lt;em&gt;If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 or later, consider instead using a {@link android.app.DialogFragment} instead.&lt;/em&gt;

 &lt;p&gt;Each time a dialog is shown, {@link #onPrepareandroid.app.Dialog(int, android.app.Dialog, Bundle)} will
 be made to provide an opportunity to do any timely preparation.
@param {Number} id The id of the managed dialog.
@param {Object {Bundle}} args Arguments to pass through to the dialog.  These will be saved
 and restored for you.  Note that if the dialog is already created,
 {@link #onCreateDialog(int, Bundle)} will not be called with the new
 arguments but {@link #onPrepareDialog(int, Dialog, Bundle)} will be.
 If you need to rebuild the dialog, call {@link #removeDialog(int)} first.
@return {Boolean} Returns true if the Dialog was created; false is returned if
 it is not created because {@link #onCreateDialog(int, Bundle)} returns false.
@see Dialog
@see #onCreateDialog(int, Bundle)
@see #onPrepareDialog(int, Dialog, Bundle)
@see #dismissDialog(int)
@see #removeDialog(int)
@deprecated Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.
*/
showDialog : function(  ) {},

<span id='android-app-Activity-method-dismissDialog'>/**Dismiss a dialog that was previously shown via {@link #showDialog}(int).
</span>@param {Number} id The id of the managed dialog.
@throws IllegalArgumentException if the id was not previously shown via
   {@link #showDialog(int)}.
@see #onCreateDialog(int, Bundle)
@see #onPrepareDialog(int, Dialog, Bundle)
@see #showDialog(int)
@see #removeDialog(int)
@deprecated Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.
*/
dismissDialog : function(  ) {},

<span id='android-app-Activity-method-removeDialog'>/**Removes any internal references to a dialog managed by this Activity.
</span> If the dialog is showing, it will dismiss it as part of the clean up.

 &lt;p&gt;This can be useful if you know that you will never show a dialog again and
 want to avoid the overhead of saving and restoring it in the future.

 &lt;p&gt;As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}, this function
 will not throw an exception if you try to remove an ID that does not
 currently have an associated dialog.&lt;/p&gt;
@param {Number} id The id of the managed dialog.
@see #onCreateDialog(int, Bundle)
@see #onPrepareDialog(int, Dialog, Bundle)
@see #showDialog(int)
@see #dismissDialog(int)
@deprecated Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.
*/
removeDialog : function(  ) {},

<span id='android-app-Activity-method-onSearchRequested'>/**This hook is called when the user signals the desire to start a search.
</span>
 &lt;p&gt;You can use this function as a simple way to launch the search UI, in response to a
 menu item, search button, or other widgets within your activity. Unless overidden,
 calling this function is the same as calling
 {@link #startSearch startSearch(null, false, null, false)}, which launches
 search for the current activity as specified in its manifest, see {@link android.app.SearchManager}.

 &lt;p&gt;You can override this function to force global search, e.g. in response to a dedicated
 search key, or to block search entirely (by simply returning false).

 &lt;p&gt;Note: when running in a {@link Configuration#UI_MODE_TYPE_TELEVISION} or
 {@link Configuration#UI_MODE_TYPE_WATCH}, the default implementation changes to simply
 return false and you must supply your own custom implementation if you want to support
 search.
@param {Object {SearchEvent}} searchEvent The {@link SearchEvent} that signaled this search.
@return {Boolean} Returns {@code true} if search launched, and {@code false} if the activity does
 not respond to search.  The default implementation always returns {@code true}, except
 when in {@link Configuration#UI_MODE_TYPE_TELEVISION} mode where it returns false.
@see android.app.SearchManager
*/
onSearchRequested : function(  ) {},

<span id='android-app-Activity-method-onSearchRequested'>/**
</span>@see #onSearchRequested(SearchEvent)
*/
onSearchRequested : function(  ) {},

<span id='android-app-Activity-method-getSearchEvent'>/**During the onSearchRequested() callbacks, this function will return the
</span> {@link SearchEvent} that triggered the callback, if it exists.
@return {Object {android.view.SearchEvent}} SearchEvent The SearchEvent that triggered the {@link
                    #onSearchRequested} callback.
*/
getSearchEvent : function(  ) {},

<span id='android-app-Activity-method-startSearch'>/**This hook is called to launch the search UI.
</span>
 &lt;p&gt;It is typically called from onSearchRequested(), either directly from
 Activity.onSearchRequested() or from an overridden version in any given
 Activity.  If your goal is simply to activate search, it is preferred to call
 onSearchRequested(), which may have been overridden elsewhere in your Activity.  If your goal
 is to inject specific data such as context data, it is preferred to &lt;i&gt;override&lt;/i&gt;
 onSearchRequested(), so that any callers to it will benefit from the override.

 &lt;p&gt;Note: when running in a {@link Configuration#UI_MODE_TYPE_WATCH}, use of this API is
 not supported.
@param {String} initialQuery Any non-null non-empty string will be inserted as
 pre-entered text in the search query box.
@param {Boolean} selectInitialQuery If true, the initial query will be preselected, which means that
 any further typing will replace it.  This is useful for cases where an entire pre-formed
 query is being inserted.  If false, the selection point will be placed at the end of the
 inserted query.  This is useful when the inserted query is text that the user entered,
 and the user would expect to be able to keep typing.  &lt;i&gt;This parameter is only meaningful
 if initialQuery is a non-empty string.&lt;/i&gt;
@param {Object {Bundle}} appSearchData An application can insert application-specific
 context here, in order to improve quality or specificity of its own
 searches.  This data will be returned with SEARCH intent(s).  Null if
 no extra data is required.
@param {Boolean} globalSearch If false, this will only launch the search that has been specifically
 defined by the application (which is usually defined as a local search).  If no default
 search is defined in the current application or activity, global search will be launched.
 If true, this will always launch a platform-global (e.g. web-based) search instead.
@see android.app.SearchManager
@see #onSearchRequested
*/
startSearch : function(  ) {},

<span id='android-app-Activity-method-triggerSearch'>/**Similar to {@link #startSearch}, but actually fires off the search query after invoking
</span> the search dialog.  Made available for testing purposes.
@param {String} query The query to trigger.  If empty, the request will be ignored.
@param {Object {Bundle}} appSearchData An application can insert application-specific
 context here, in order to improve quality or specificity of its own
 searches.  This data will be returned with SEARCH intent(s).  Null if
 no extra data is required.
*/
triggerSearch : function(  ) {},

<span id='android-app-Activity-method-takeKeyEvents'>/**Request that key events come to this activity. Use this if your
</span> activity has no views with focus, but the activity still wants
 a chance to process key events.
@see android.view.Window#takeKeyEvents
*/
takeKeyEvents : function(  ) {},

<span id='android-app-Activity-method-requestWindowFeature'>/**Enable extended window features.  This is a convenience for calling
</span> {@link android.view.Window#requestFeature getWindow().requestFeature()}.
@param {Number} featureId The desired feature as defined in
                  {@link android.view.Window}.
@return {Boolean} Returns true if the requested feature is supported and now
         enabled.
@see android.view.Window#requestFeature
*/
requestWindowFeature : function(  ) {},

<span id='android-app-Activity-method-setFeatureDrawableResource'>/**Convenience for calling
</span> {@link android.view.Window#setFeatureDrawableResource}.
*/
setFeatureDrawableResource : function(  ) {},

<span id='android-app-Activity-method-setFeatureDrawableUri'>/**Convenience for calling
</span> {@link android.view.Window#setFeatureDrawableUri}.
*/
setFeatureDrawableUri : function(  ) {},

<span id='android-app-Activity-method-setFeatureDrawable'>/**Convenience for calling
</span> {@link android.view.Window#setFeatureDrawable(int, Drawable)}.
*/
setFeatureDrawable : function(  ) {},

<span id='android-app-Activity-method-setFeatureDrawableAlpha'>/**Convenience for calling
</span> {@link android.view.Window#setFeatureDrawableAlpha}.
*/
setFeatureDrawableAlpha : function(  ) {},

<span id='android-app-Activity-method-getLayoutInflater'>/**Convenience for calling
</span> {@link android.view.Window#getLayoutInflater}.
*/
getLayoutInflater : function(  ) {},

<span id='android-app-Activity-method-getMenuInflater'>/**Returns a {@link MenuInflater} with this context.
</span>*/
getMenuInflater : function(  ) {},

<span id='android-app-Activity-method-setTheme'>/**
</span>*/
setTheme : function(  ) {},

<span id='android-app-Activity-method-requestPermissions'>/**Requests permissions to be granted to this application. These permissions
</span> must be requested in your manifest, they should not be granted to your app,
 and they should have protection level {@link android.content.pm.PermissionInfo#PROTECTION_DANGEROUS dangerous}, regardless
 whether they are declared by the platform or a third-party app.
 &lt;p&gt;
 Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 are granted at install time if requested in the manifest. Signature permissions
 {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 install time if requested in the manifest and the signature of your app matches
 the signature of the app declaring the permissions.
 &lt;/p&gt;
 &lt;p&gt;
 If your app does not have the requested permissions the user will be presented
 with UI for accepting them. After the user has accepted or rejected the
 requested permissions you will receive a callback on {@link #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 permissions were granted or not.
 &lt;/p&gt;
 &lt;p&gt;
 Note that requesting a permission does not guarantee it will be granted and
 your app should be able to run without having this permission.
 &lt;/p&gt;
 &lt;p&gt;
 This method may start an activity allowing the user to choose which permissions
 to grant and which to reject. Hence, you should be prepared that your activity
 may be paused and resumed. Further, granting some permissions may require
 a restart of you application. In such a case, the system will recreate the
 activity stack before delivering the result to {@link #onRequestPermissionsResult(int, String[], int[])}.
 &lt;/p&gt;
 &lt;p&gt;
 When checking whether you have a permission you should use {@link #checkSelfPermission}(String).
 &lt;/p&gt;
 &lt;p&gt;
 Calling this API for permissions already granted to your app would show UI
 to the user to decide whether the app can still hold these permissions. This
 can be useful if the way your app uses data guarded by the permissions
 changes significantly.
 &lt;/p&gt;
 &lt;p&gt;
 You cannot request a permission if your activity sets {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 &lt;code&gt;true&lt;/code&gt; because in this case the activity would not receive
 result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 &lt;/p&gt;
 &lt;p&gt;
 The &lt;a href=&quot;https://github.com/googlesamples/android-RuntimePermissions&quot;&gt;
 RuntimePermissions&lt;/a&gt; sample app demonstrates how to use this method to
 request permissions at run time.
 &lt;/p&gt;
@param {Object {java.lang.String[]}} permissions The requested permissions. Must me non-null and not empty.
@param {Number} requestCode Application specific request code to match with a result
    reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
    Should be &gt;= 0.
@throws IllegalArgumentException if requestCode is negative.
@see #onRequestPermissionsResult(int, String[], int[])
@see #checkSelfPermission(String)
@see #shouldShowRequestPermissionRationale(String)
*/
requestPermissions : function(  ) {},

<span id='android-app-Activity-method-onRequestPermissionsResult'>/**Callback for the result from requesting permissions. This method
</span> is invoked for every call on {@link #requestPermissions(String[], int)}.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; It is possible that the permissions request interaction
 with the user is interrupted. In this case you will receive empty permissions
 and results arrays which should be treated as a cancellation.
 &lt;/p&gt;
@param {Number} requestCode The request code passed in {@link #requestPermissions(String[], int)}.
@param {Object {java.lang.String[]}} permissions The requested permissions. Never null.
@param {Object {int[]}} grantResults The grant results for the corresponding permissions
     which is either {@link android.content.pm.PackageManager#PERMISSION_GRANTED}
     or {@link android.content.pm.PackageManager#PERMISSION_DENIED}. Never null.
@see #requestPermissions(String[], int)
*/
onRequestPermissionsResult : function(  ) {},

<span id='android-app-Activity-method-shouldShowRequestPermissionRationale'>/**Gets whether you should show UI with rationale for requesting a permission.
</span> You should do this only if you do not have the permission and the context in
 which the permission is requested does not clearly communicate to the user
 what would be the benefit from granting this permission.
 &lt;p&gt;
 For example, if you write a camera app, requesting the camera permission
 would be expected by the user and no rationale for why it is requested is
 needed. If however, the app needs location for tagging photos then a non-tech
 savvy user may wonder how location is related to taking photos. In this case
 you may choose to show UI with rationale of requesting this permission.
 &lt;/p&gt;
@param {String} permission A permission your app wants to request.
@return {Boolean} Whether you can show permission rationale UI.
@see #checkSelfPermission(String)
@see #requestPermissions(String[], int)
@see #onRequestPermissionsResult(int, String[], int[])
*/
shouldShowRequestPermissionRationale : function(  ) {},

<span id='android-app-Activity-method-startActivityForResult'>/**Same as calling {@link #startActivityForResult(Intent, int, Bundle)}
</span> with no options.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode If &gt;= 0, this code will be returned in
                    onActivityResult() when the activity exits.
@throws android.content.ActivityNotFoundException
@see #startActivity
*/
startActivityForResult : function(  ) {},

<span id='android-app-Activity-method-startActivityForResult'>/**Launch an activity for which you would like a result when it finished.
</span> When this activity exits, your
 onActivityResult() method will be called with the given requestCode.
 Using a negative requestCode is the same as calling
 {@link #startActivity} (the activity is not launched as a sub-activity).

 &lt;p&gt;Note that this method should only be used with Intent protocols
 that are defined to return a result.  In other protocols (such as
 {@link Intent#ACTION_MAIN} or {@link Intent#ACTION_VIEW}), you may
 not get the result when you expect.  For example, if the activity you
 are launching uses {@link Intent#FLAG_ACTIVITY_NEW_TASK}, it will not
 run in your task and thus you will immediately receive a cancel result.

 &lt;p&gt;As a special case, if you call startActivityForResult() with a requestCode
 &gt;= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your
 activity, then your window will not be displayed until a result is
 returned back from the started activity.  This is to avoid visible
 flickering when redirecting to another activity.

 &lt;p&gt;This method throws {@link android.content.ActivityNotFoundException}
 if there was no Activity found to run the given Intent.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode If &gt;= 0, this code will be returned in
                    onActivityResult() when the activity exits.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@throws android.content.ActivityNotFoundException
@see #startActivity
*/
startActivityForResult : function(  ) {},

<span id='android-app-Activity-method-isActivityTransitionRunning'>/**Returns whether there are any activity transitions currently running on this
</span> activity. A return value of {@code true} can mean that either an enter or
 exit transition is running, including whether the background of the activity
 is animating as a part of that transition.
@return {Boolean} true if a transition is currently running on this activity, false otherwise.
*/
isActivityTransitionRunning : function(  ) {},

<span id='android-app-Activity-method-startActivityForResultAsUser'>/**
</span>@hide Implement to provide correct calling token.
*/
startActivityForResultAsUser : function(  ) {},

<span id='android-app-Activity-method-startActivityForResultAsUser'>/**
</span>@hide Implement to provide correct calling token.
*/
startActivityForResultAsUser : function(  ) {},

<span id='android-app-Activity-method-startActivityForResultAsUser'>/**
</span>@hide Implement to provide correct calling token.
*/
startActivityForResultAsUser : function(  ) {},

<span id='android-app-Activity-method-startActivityAsUser'>/**
</span>@hide Implement to provide correct calling token.
*/
startActivityAsUser : function(  ) {},

<span id='android-app-Activity-method-startActivityAsUser'>/**
</span>@hide Implement to provide correct calling token.
*/
startActivityAsUser : function(  ) {},

<span id='android-app-Activity-method-startActivityAsCaller'>/**Start a new activity as if it was started by the activity that started our
</span> current activity.  This is for the resolver and chooser activities, which operate
 as intermediaries that dispatch their intent to the target the user selects -- to
 do this, they must perform all security checks including permission grants as if
 their launch had come from the original activity.
@param {Object {Intent}} intent The Intent to start.
@param {Object {Bundle}} options ActivityOptions or null.
@param {Object {IBinder}} permissionToken Token received from the system that permits this call to be made.
@param {Boolean} ignoreTargetSecurity If true, the activity manager will not check whether the
 caller it is doing the start is, is actually allowed to start the target activity.
 If you set this to true, you must set an explicit component in the Intent and do any
 appropriate security checks yourself.
@param {Number} userId The user the new activity should run as.
@hide 
*/
startActivityAsCaller : function(  ) {},

<span id='android-app-Activity-method-startIntentSenderForResult'>/**Same as calling {@link #startIntentSenderForResult(IntentSender, int,
</span> Intent, int, int, int, Bundle)} with no options.
@param {Object {IntentSender}} intent The IntentSender to launch.
@param {Number} requestCode If &gt;= 0, this code will be returned in
                    onActivityResult() when the activity exits.
@param {Object {Intent}} fillInIntent If non-null, this will be provided as the
 intent parameter to {@link IntentSender#sendIntent}.
@param {Number} flagsMask Intent flags in the original IntentSender that you
 would like to change.
@param {Number} flagsValues Desired values for any bits set in
 &lt;var&gt;flagsMask&lt;/var&gt;
@param {Number} extraFlags Always set to 0.
*/
startIntentSenderForResult : function(  ) {},

<span id='android-app-Activity-method-startIntentSenderForResult'>/**Like {@link #startActivityForResult(Intent, int)}, but allowing you
</span> to use a IntentSender to describe the activity to be started.  If
 the IntentSender is for an activity, that activity will be started
 as if you had called the regular {@link #startActivityForResult(Intent, int)}
 here; otherwise, its associated action will be executed (such as
 sending a broadcast) as if you had called
 {@link IntentSender#sendIntent IntentSender.sendIntent} on it.
@param {Object {IntentSender}} intent The IntentSender to launch.
@param {Number} requestCode If &gt;= 0, this code will be returned in
                    onActivityResult() when the activity exits.
@param {Object {Intent}} fillInIntent If non-null, this will be provided as the
 intent parameter to {@link IntentSender#sendIntent}.
@param {Number} flagsMask Intent flags in the original IntentSender that you
 would like to change.
@param {Number} flagsValues Desired values for any bits set in
 &lt;var&gt;flagsMask&lt;/var&gt;
@param {Number} extraFlags Always set to 0.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.  If options
 have also been supplied by the IntentSender, options given here will
 override any that conflict with those given by the IntentSender.
*/
startIntentSenderForResult : function(  ) {},

<span id='android-app-Activity-method-startActivity'>/**Same as {@link #startActivity(Intent, Bundle)} with no options
</span> specified.
@param {Object {Intent}} intent The intent to start.
@throws android.content.ActivityNotFoundException
@see #startActivity(Intent, Bundle)
@see #startActivityForResult
*/
startActivity : function(  ) {},

<span id='android-app-Activity-method-startActivity'>/**Launch a new activity.  You will not receive any information about when
</span> the activity exits.  This implementation overrides the base version,
 providing information about
 the activity performing the launch.  Because of this additional
 information, the {@link Intent#FLAG_ACTIVITY_NEW_TASK} launch flag is not
 required; if not specified, the new activity will be added to the
 task of the caller.

 &lt;p&gt;This method throws {@link android.content.ActivityNotFoundException}
 if there was no Activity found to run the given Intent.
@param {Object {Intent}} intent The intent to start.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@throws android.content.ActivityNotFoundException
@see #startActivity(Intent)
@see #startActivityForResult
*/
startActivity : function(  ) {},

<span id='android-app-Activity-method-startActivities'>/**Same as {@link #startActivities(Intent[], Bundle)} with no options
</span> specified.
@param {Object {android.content.Intent[]}} intents The intents to start.
@throws android.content.ActivityNotFoundException
@see #startActivities(Intent[], Bundle)
@see #startActivityForResult
*/
startActivities : function(  ) {},

<span id='android-app-Activity-method-startActivities'>/**Launch a new activity.  You will not receive any information about when
</span> the activity exits.  This implementation overrides the base version,
 providing information about
 the activity performing the launch.  Because of this additional
 information, the {@link Intent#FLAG_ACTIVITY_NEW_TASK} launch flag is not
 required; if not specified, the new activity will be added to the
 task of the caller.

 &lt;p&gt;This method throws {@link android.content.ActivityNotFoundException}
 if there was no Activity found to run the given Intent.
@param {Object {android.content.Intent[]}} intents The intents to start.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@throws android.content.ActivityNotFoundException
@see #startActivities(Intent[])
@see #startActivityForResult
*/
startActivities : function(  ) {},

<span id='android-app-Activity-method-startIntentSender'>/**Same as calling {@link #startIntentSender(IntentSender, Intent, int, int, int, Bundle)}
</span> with no options.
@param {Object {IntentSender}} intent The IntentSender to launch.
@param {Object {Intent}} fillInIntent If non-null, this will be provided as the
 intent parameter to {@link IntentSender#sendIntent}.
@param {Number} flagsMask Intent flags in the original IntentSender that you
 would like to change.
@param {Number} flagsValues Desired values for any bits set in
 &lt;var&gt;flagsMask&lt;/var&gt;
@param {Number} extraFlags Always set to 0.
*/
startIntentSender : function(  ) {},

<span id='android-app-Activity-method-startIntentSender'>/**Like {@link #startActivity(Intent, Bundle)}, but taking a IntentSender
</span> to start; see
 {@link #startIntentSenderForResult(IntentSender, int, Intent, int, int, int, Bundle)}
 for more information.
@param {Object {IntentSender}} intent The IntentSender to launch.
@param {Object {Intent}} fillInIntent If non-null, this will be provided as the
 intent parameter to {@link IntentSender#sendIntent}.
@param {Number} flagsMask Intent flags in the original IntentSender that you
 would like to change.
@param {Number} flagsValues Desired values for any bits set in
 &lt;var&gt;flagsMask&lt;/var&gt;
@param {Number} extraFlags Always set to 0.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.  If options
 have also been supplied by the IntentSender, options given here will
 override any that conflict with those given by the IntentSender.
*/
startIntentSender : function(  ) {},

<span id='android-app-Activity-method-startActivityIfNeeded'>/**Same as calling {@link #startActivityIfNeeded(Intent, int, Bundle)}
</span> with no options.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode If &gt;= 0, this code will be returned in
         onActivityResult() when the activity exits, as described in
         {@link #startActivityForResult}.
@return {Boolean} If a new activity was launched then true is returned; otherwise
         false is returned and you must handle the Intent yourself.
@see #startActivity
@see #startActivityForResult
*/
startActivityIfNeeded : function(  ) {},

<span id='android-app-Activity-method-startActivityIfNeeded'>/**A special variation to launch an activity only if a new activity
</span> instance is needed to handle the given Intent.  In other words, this is
 just like {@link #startActivityForResult(Intent, int)} except: if you are
 using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 singleTask or singleTop
 {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 and the activity
 that handles &lt;var&gt;intent&lt;/var&gt; is the same as your currently running
 activity, then a new instance is not needed.  In this case, instead of
 the normal behavior of calling {@link #onNewIntent} this function will
 return and you can handle the Intent yourself.

 &lt;p&gt;This function can only be called from a top-level activity; if it is
 called from a child activity, a runtime exception will be thrown.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode If &gt;= 0, this code will be returned in
         onActivityResult() when the activity exits, as described in
         {@link #startActivityForResult}.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@return {Boolean} If a new activity was launched then true is returned; otherwise
         false is returned and you must handle the Intent yourself.
@see #startActivity
@see #startActivityForResult
*/
startActivityIfNeeded : function(  ) {},

<span id='android-app-Activity-method-startNextMatchingActivity'>/**Same as calling {@link #startNextMatchingActivity(Intent, Bundle)} with
</span> no options.
@param {Object {Intent}} intent The intent to dispatch to the next activity.  For
 correct behavior, this must be the same as the Intent that started
 your own activity; the only changes you can make are to the extras
 inside of it.
@return {Boolean} Returns a boolean indicating whether there was another Activity
 to start: true if there was a next activity to start, false if there
 wasn't.  In general, if true is returned you will then want to call
 finish() on yourself.
*/
startNextMatchingActivity : function(  ) {},

<span id='android-app-Activity-method-startNextMatchingActivity'>/**Special version of starting an activity, for use when you are replacing
</span> other activity components.  You can use this to hand the Intent off
 to the next Activity that can handle it.  You typically call this in
 {@link #onCreate} with the Intent returned by {@link #getIntent}.
@param {Object {Intent}} intent The intent to dispatch to the next activity.  For
 correct behavior, this must be the same as the Intent that started
 your own activity; the only changes you can make are to the extras
 inside of it.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@return {Boolean} Returns a boolean indicating whether there was another Activity
 to start: true if there was a next activity to start, false if there
 wasn't.  In general, if true is returned you will then want to call
 finish() on yourself.
*/
startNextMatchingActivity : function(  ) {},

<span id='android-app-Activity-method-startActivityFromChild'>/**Same as calling {@link #startActivityFromChild(Activity, Intent, int, Bundle)}
</span> with no options.
@param {Object {Activity}} child The activity making the call.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode Reply request code.  &lt; 0 if reply is not requested.
@throws android.content.ActivityNotFoundException
@see #startActivity
@see #startActivityForResult
*/
startActivityFromChild : function(  ) {},

<span id='android-app-Activity-method-startActivityFromChild'>/**This is called when a child activity of this one calls its
</span> {@link #startActivity} or {@link #startActivityForResult} method.

 &lt;p&gt;This method throws {@link android.content.ActivityNotFoundException}
 if there was no Activity found to run the given Intent.
@param {Object {Activity}} child The activity making the call.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode Reply request code.  &lt; 0 if reply is not requested.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@throws android.content.ActivityNotFoundException
@see #startActivity
@see #startActivityForResult
*/
startActivityFromChild : function(  ) {},

<span id='android-app-Activity-method-startActivityFromFragment'>/**Same as calling {@link #startActivityFromFragment(Fragment, Intent, int, Bundle)}
</span> with no options.
@param {Object {Fragment}} fragment The fragment making the call.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode Reply request code.  &lt; 0 if reply is not requested.
@throws android.content.ActivityNotFoundException
@see Fragment#startActivity
@see Fragment#startActivityForResult
@deprecated Use {@link android.support.v4.app.FragmentActivity#startActivityFromFragment(
 android.support.v4.app.Fragment,Intent,int)}
*/
startActivityFromFragment : function(  ) {},

<span id='android-app-Activity-method-startActivityFromFragment'>/**This is called when a Fragment in this activity calls its
</span> {@link android.app.Fragment#startActivity} or {@link android.app.Fragment#startActivityForResult}
 method.

 &lt;p&gt;This method throws {@link android.content.ActivityNotFoundException}
 if there was no Activity found to run the given Intent.
@param {Object {Fragment}} fragment The fragment making the call.
@param {Object {Intent}} intent The intent to start.
@param {Number} requestCode Reply request code.  &lt; 0 if reply is not requested.
@param {Object {Bundle}} options Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)}
 Context.startActivity(Intent, Bundle)} for more details.
@throws android.content.ActivityNotFoundException
@see Fragment#startActivity
@see Fragment#startActivityForResult
@deprecated Use {@link android.support.v4.app.FragmentActivity#startActivityFromFragment(
 android.support.v4.app.Fragment,Intent,int,Bundle)}
*/
startActivityFromFragment : function(  ) {},

<span id='android-app-Activity-method-startActivityAsUserFromFragment'>/**
</span>@hide 
*/
startActivityAsUserFromFragment : function(  ) {},

<span id='android-app-Activity-method-startActivityForResult'>/**
</span>@hide 
*/
startActivityForResult : function(  ) {},

<span id='android-app-Activity-method-canStartActivityForResult'>/**
</span>@hide 
*/
canStartActivityForResult : function(  ) {},

<span id='android-app-Activity-method-startIntentSenderFromChild'>/**Same as calling {@link #startIntentSenderFromChild(Activity, IntentSender,
</span> int, Intent, int, int, int, Bundle)} with no options.
*/
startIntentSenderFromChild : function(  ) {},

<span id='android-app-Activity-method-startIntentSenderFromChild'>/**Like {@link #startActivityFromChild(Activity, Intent, int)}, but
</span> taking a IntentSender; see
 {@link #startIntentSenderForResult(IntentSender, int, Intent, int, int, int)}
 for more information.
*/
startIntentSenderFromChild : function(  ) {},

<span id='android-app-Activity-method-startIntentSenderFromChildFragment'>/**Like {@link #startIntentSenderFromChild}, but taking a Fragment; see
</span> {@link #startIntentSenderForResult(IntentSender, int, Intent, int, int, int)}
 for more information.
@hide 
*/
startIntentSenderFromChildFragment : function(  ) {},

<span id='android-app-Activity-method-overridePendingTransition'>/**Call immediately after one of the flavors of {@link #startActivity}(Intent)
</span> or {@link #finish} to specify an explicit transition animation to
 perform next.

 &lt;p&gt;As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 to using this with starting activities is to supply the desired animation
 information through a {@link android.app.ActivityOptions} bundle to
 {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 you to specify a custom animation even when starting an activity from
 outside the context of the current top activity.
@param {Number} enterAnim A resource ID of the animation resource to use for
 the incoming activity.  Use 0 for no animation.
@param {Number} exitAnim A resource ID of the animation resource to use for
 the outgoing activity.  Use 0 for no animation.
*/
overridePendingTransition : function(  ) {},

<span id='android-app-Activity-method-setResult'>/**Call this to set the result that your activity will return to its
</span> caller.
@param {Number} resultCode The result code to propagate back to the originating
                   activity, often RESULT_CANCELED or RESULT_OK
@see #RESULT_CANCELED
@see #RESULT_OK
@see #RESULT_FIRST_USER
@see #setResult(int, Intent)
*/
setResult : function(  ) {},

<span id='android-app-Activity-method-setResult'>/**Call this to set the result that your activity will return to its
</span> caller.

 &lt;p&gt;As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}, the Intent
 you supply here can have {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
 Intent.FLAG_GRANT_READ_URI_PERMISSION} and/or {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
 Intent.FLAG_GRANT_WRITE_URI_PERMISSION} set.  This will grant the
 Activity receiving the result access to the specific URIs in the Intent.
 Access will remain until the Activity has finished (it will remain across the hosting
 process being killed and other temporary destruction) and will be added
 to any existing set of URI permissions it already holds.
@param {Number} resultCode The result code to propagate back to the originating
                   activity, often RESULT_CANCELED or RESULT_OK
@param {Object {Intent}} data The data to propagate back to the originating activity.
@see #RESULT_CANCELED
@see #RESULT_OK
@see #RESULT_FIRST_USER
@see #setResult(int)
*/
setResult : function(  ) {},

<span id='android-app-Activity-method-getReferrer'>/**Return information about who launched this activity.  If the launching Intent
</span> contains an {@link android.content.Intent#EXTRA_REFERRER Intent.EXTRA_REFERRER},
 that will be returned as-is; otherwise, if known, an
 {@link Intent#URI_ANDROID_APP_SCHEME android-app:} referrer URI containing the
 package name that started the Intent will be returned.  This may return null if no
 referrer can be identified -- it is neither explicitly specified, nor is it known which
 application package was involved.

 &lt;p&gt;If called while inside the handling of {@link #onNewIntent}, this function will
 return the referrer that submitted that new intent to the activity.  Otherwise, it
 always returns the referrer of the original Intent.&lt;/p&gt;

 &lt;p&gt;Note that this is &lt;em&gt;not&lt;/em&gt; a security feature -- you can not trust the
 referrer information, applications can spoof it.&lt;/p&gt;
*/
getReferrer : function(  ) {},

<span id='android-app-Activity-method-onProvideReferrer'>/**Override to generate the desired referrer for the content currently being shown
</span> by the app.  The default implementation returns null, meaning the referrer will simply
 be the android-app: of the package name of this activity.  Return a non-null Uri to
 have that supplied as the {@link Intent#EXTRA_REFERRER} of any activities started from it.
*/
onProvideReferrer : function(  ) {},

<span id='android-app-Activity-method-getCallingPackage'>/**Return the name of the package that invoked this activity.  This is who
</span> the data in {@link #setResult setResult()} will be sent to.  You can
 use this information to validate that the recipient is allowed to
 receive the data.

 &lt;p class=&quot;note&quot;&gt;Note: if the calling activity is not expecting a result (that is it
 did not use the {@link #startActivityForResult}
 form that includes a request code), then the calling package will be
 null.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 the result from this method was unstable.  If the process hosting the calling
 package was no longer running, it would return null instead of the proper package
 name.  You can use {@link #getCallingActivity}() and retrieve the package name
 from that instead.&lt;/p&gt;
@return {String} The package of the activity that will receive your
         reply, or null if none.
*/
getCallingPackage : function(  ) {},

<span id='android-app-Activity-method-getCallingActivity'>/**Return the name of the activity that invoked this activity.  This is
</span> who the data in {@link #setResult setResult()} will be sent to.  You
 can use this information to validate that the recipient is allowed to
 receive the data.

 &lt;p class=&quot;note&quot;&gt;Note: if the calling activity is not expecting a result (that is it
 did not use the {@link #startActivityForResult}
 form that includes a request code), then the calling package will be
 null.
@return {Object {android.content.ComponentName}} The ComponentName of the activity that will receive your
         reply, or null if none.
*/
getCallingActivity : function(  ) {},

<span id='android-app-Activity-method-setVisible'>/**Control whether this activity's main window is visible.  This is intended
</span> only for the special case of an activity that is not going to show a
 UI itself, but can't just finish prior to onResume() because it needs
 to wait for a service binding or such.  Setting this to false allows
 you to prevent your UI from being shown during that time.

 &lt;p&gt;The default value for this is taken from the
 {@link android.R.attr#windowNoDisplay} attribute of the activity's theme.
*/
setVisible : function(  ) {},

<span id='android-app-Activity-method-isFinishing'>/**Check to see whether this activity is in the process of finishing,
</span> either because you called {@link #finish} on it or someone else
 has requested that it finished.  This is often used in
 {@link #onPause} to determine whether the activity is simply pausing or
 completely finishing.
@return {Boolean} If the activity is finishing, returns true; else returns false.
@see #finish
*/
isFinishing : function(  ) {},

<span id='android-app-Activity-method-isDestroyed'>/**Returns true if the final {@link #onDestroy}() call has been made
</span> on the Activity, so this instance is now dead.
*/
isDestroyed : function(  ) {},

<span id='android-app-Activity-method-isChangingConfigurations'>/**Check to see whether this activity is in the process of being destroyed in order to be
</span> recreated with a new configuration. This is often used in
 {@link #onStop} to determine whether the state needs to be cleaned up or will be passed
 on to the next instance of the activity via {@link #onRetainNonConfigurationInstance}().
@return {Boolean} If the activity is being torn down in order to be recreated with a new configuration,
 returns true; else returns false.
*/
isChangingConfigurations : function(  ) {},

<span id='android-app-Activity-method-recreate'>/**Cause this Activity to be recreated with a new instance.  This results
</span> in essentially the same flow as when the Activity is created due to
 a configuration change -- the current instance will go through its
 lifecycle to {@link #onDestroy} and a new instance then created after it.
*/
recreate : function(  ) {},

<span id='android-app-Activity-method-finish'>/**Call this when your activity is done and should be closed.  The
</span> ActivityResult is propagated back to whoever launched you via
 onActivityResult().
*/
finish : function(  ) {},

<span id='android-app-Activity-method-finishAffinity'>/**Finish this activity as well as all activities immediately below it
</span> in the current task that have the same affinity.  This is typically
 used when an application can be launched on to another task (such as
 from an ACTION_VIEW of a content type it understands) and the user
 has used the up navigation to switch out of the current task and in
 to its own task.  In this case, if the user has navigated down into
 any other activities of the second application, all of those should
 be removed from the original task as part of the task switch.

 &lt;p&gt;Note that this finish does &lt;em&gt;not&lt;/em&gt; allow you to deliver results
 to the previous activity, and an exception will be thrown if you are trying
 to do so.&lt;/p&gt;
*/
finishAffinity : function(  ) {},

<span id='android-app-Activity-method-finishFromChild'>/**This is called when a child activity of this one calls its
</span> {@link #finish} method.  The default implementation simply calls
 finish() on this activity (the parent), finishing the entire group.
@param {Object {Activity}} child The activity making the call.
@see #finish
*/
finishFromChild : function(  ) {},

<span id='android-app-Activity-method-finishAfterTransition'>/**Reverses the Activity Scene entry Transition and triggers the calling Activity
</span> to reverse its exit Transition. When the exit Transition completes,
 {@link #finish}() is called. If no entry Transition was used, finish() is called
 immediately and the Activity exit Transition is run.
@see android.app.ActivityOptions#makeSceneTransitionAnimation(Activity, android.util.Pair[])
*/
finishAfterTransition : function(  ) {},

<span id='android-app-Activity-method-finishActivity'>/**Force finish another activity that you had previously started with
</span> {@link #startActivityForResult}.
@param {Number} requestCode The request code of the activity that you had
                    given to startActivityForResult().  If there are multiple
                    activities started with this request code, they
                    will all be finished.
*/
finishActivity : function(  ) {},

<span id='android-app-Activity-method-finishActivityFromChild'>/**This is called when a child activity of this one calls its
</span> finishActivity().
@param {Object {Activity}} child The activity making the call.
@param {Number} requestCode Request code that had been used to start the
                    activity.
*/
finishActivityFromChild : function(  ) {},

<span id='android-app-Activity-method-finishAndRemoveTask'>/**Call this when your activity is done and should be closed and the task should be completely
</span> removed as a part of finishing the root activity of the task.
*/
finishAndRemoveTask : function(  ) {},

<span id='android-app-Activity-method-releaseInstance'>/**Ask that the local app instance of this activity be released to free up its memory.
</span> This is asking for the activity to be destroyed, but does &lt;b&gt;not&lt;/b&gt; finish the activity --
 a new instance of the activity will later be re-created if needed due to the user
 navigating back to it.
@return {Boolean} Returns true if the activity was in a state that it has started the process
 of destroying its current instance; returns false if for any reason this could not
 be done: it is currently visible to the user, it is already being destroyed, it is
 being finished, it hasn't yet saved its state, etc.
*/
releaseInstance : function(  ) {},

<span id='android-app-Activity-method-onActivityReenter'>/**Called when an activity you launched with an activity transition exposes this
</span> Activity through a returning activity transition, giving you the resultCode
 and any additional data from it. This method will only be called if the activity
 set a result code other than {@link #RESULT_CANCELED} and it supports activity
 transitions with {@link Window#FEATURE_ACTIVITY_TRANSITIONS}.

 &lt;p&gt;The purpose of this function is to let the called Activity send a hint about
 its state so that this underlying Activity can prepare to be exposed. A call to
 this method does not guarantee that the called Activity has or will be exiting soon.
 It only indicates that it will expose this Activity's Window and it has
 some data to pass to prepare it.&lt;/p&gt;
@param {Number} resultCode The integer result code returned by the child activity
                   through its setResult().
@param {Object {Intent}} data An Intent, which can return result data to the caller
               (various data can be attached to Intent &quot;extras&quot;).
*/
onActivityReenter : function(  ) {},

<span id='android-app-Activity-method-createPendingResult'>/**Create a new PendingIntent object which you can hand to others
</span> for them to use to send result data back to your
 {@link #onActivityResult} callback.  The created object will be either
 one-shot (becoming invalid after a result is sent back) or multiple
 (allowing any number of results to be sent through it).
@param {Number} requestCode Private request code for the sender that will be
 associated with the result data when it is returned.  The sender can not
 modify this value, allowing you to identify incoming results.
@param {Object {Intent}} data Default data to supply in the result, which may be modified
 by the sender.
@param {Number} flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 or any of the flags as supported by
 {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 of the intent that can be supplied when the actual send happens.
@return {Object {android.app.PendingIntent}} Returns an existing or new PendingIntent matching the given
 parameters.  May return null only if
 {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 supplied.
@see PendingIntent
*/
createPendingResult : function(  ) {},

<span id='android-app-Activity-method-setRequestedOrientation'>/**Change the desired orientation of this activity.  If the activity
</span> is currently in the foreground or otherwise impacting the screen
 orientation, the screen will immediately be changed (possibly causing
 the activity to be restarted). Otherwise, this will be used the next
 time the activity is visible.
@param {Number} requestedOrientation An orientation constant as used in
 {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
*/
setRequestedOrientation : function(  ) {},

<span id='android-app-Activity-method-getRequestedOrientation'>/**Return the current requested orientation of the activity.  This will
</span> either be the orientation requested in its component's manifest, or
 the last requested orientation given to
 {@link #setRequestedOrientation}(int).
@return {Number} Returns an orientation constant as used in
 {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
*/
getRequestedOrientation : function(  ) {},

<span id='android-app-Activity-method-getTaskId'>/**Return the identifier of the task this activity is in.  This identifier
</span> will remain the same for the lifetime of the activity.
@return {Number} Task identifier, an opaque integer.
*/
getTaskId : function(  ) {},

<span id='android-app-Activity-method-isTaskRoot'>/**Return whether this activity is the root of a task.  The root is the
</span> first activity in a task.
@return {Boolean} True if this is the root activity, else false.
*/
isTaskRoot : function(  ) {},

<span id='android-app-Activity-method-moveTaskToBack'>/**Move the task containing this activity to the back of the activity
</span> stack.  The activity's order within the task is unchanged.
@param {Boolean} nonRoot If false then this only works if the activity is the root
                of a task; if true it will work for any activity in
                a task.
@return {Boolean} If the task was moved (or it was already at the
         back) true is returned, else false.
*/
moveTaskToBack : function(  ) {},

<span id='android-app-Activity-method-getLocalClassName'>/**Returns class name for this activity with the package prefix removed.
</span> This is the default name used to read and write settings.
@return {String} The local class name.
*/
getLocalClassName : function(  ) {},

<span id='android-app-Activity-method-getComponentName'>/**Returns the complete component name of this activity.
</span>@return {Object {android.content.ComponentName}} Returns the complete component name for this activity
*/
getComponentName : function(  ) {},

<span id='android-app-Activity-method-autofillClientGetComponentName'>/**
</span>@hide 
*/
autofillClientGetComponentName : function(  ) {},

<span id='android-app-Activity-method-contentCaptureClientGetComponentName'>/**
</span>@hide 
*/
contentCaptureClientGetComponentName : function(  ) {},

<span id='android-app-Activity-method-getPreferences'>/**Retrieve a {@link SharedPreferences} object for accessing preferences
</span> that are private to this activity.  This simply calls the underlying
 {@link #getSharedPreferences(String, int)} method by passing in this activity's
 class name as the preferences name.
@param {Number} mode Operating mode.  Use {@link #MODE_PRIVATE} for the default
             operation.
@return {Object {android.content.SharedPreferences}} Returns the single SharedPreferences instance that can be used
         to retrieve and modify the preference values.
*/
getPreferences : function(  ) {},

<span id='android-app-Activity-method-getSystemService'>/**
</span>*/
getSystemService : function(  ) {},

<span id='android-app-Activity-method-setTitle'>/**Change the title associated with this activity.  If this is a
</span> top-level activity, the title for its window will change.  If it
 is an embedded activity, the parent can do whatever it wants
 with it.
*/
setTitle : function(  ) {},

<span id='android-app-Activity-method-setTitle'>/**Change the title associated with this activity.  If this is a
</span> top-level activity, the title for its window will change.  If it
 is an embedded activity, the parent can do whatever it wants
 with it.
*/
setTitle : function(  ) {},

<span id='android-app-Activity-method-setTitleColor'>/**Change the color of the title associated with this activity.
</span> &lt;p&gt;
 This method is deprecated starting in API Level 11 and replaced by action
 bar styles. For information on styling the Action Bar, read the &lt;a
 href=&quot;{@docRoot} guide/topics/ui/actionbar.html&quot;&gt;Action Bar&lt;/a&gt; developer
 guide.
@deprecated Use action bar styles instead.
*/
setTitleColor : function(  ) {},

<span id='android-app-Activity-method-getTitle'>/**
</span>*/
getTitle : function(  ) {},

<span id='android-app-Activity-method-getTitleColor'>/**
</span>*/
getTitleColor : function(  ) {},

<span id='android-app-Activity-method-setTaskDescription'>/**Sets information describing the task with this activity for presentation inside the Recents
</span> System UI. When {@link android.app.ActivityManager#getRecentTasks} is called, the activities of each task
 are traversed in order from the topmost activity to the bottommost. The traversal continues
 for each property until a suitable value is found. For each task the taskDescription will be
 returned in {@link android.app.ActivityManager.TaskDescription}.
@param {Object {ActivityManager.TaskDescription}} taskDescription The TaskDescription properties that describe the task with this activity
@see android.app.ActivityManager.TaskDescription
@param taskDescription The TaskDescription properties that describe the task with this activity
*/
setTaskDescription : function(  ) {},

<span id='android-app-Activity-method-setProgressBarVisibility'>/**Sets the visibility of the progress bar in the title.
</span> &lt;p&gt;
 In order for the progress bar to be shown, the feature must be requested
 via {@link #requestWindowFeature}(int).
@param {Boolean} visible Whether to show the progress bars in the title.
@deprecated No longer supported starting in API 21.
*/
setProgressBarVisibility : function(  ) {},

<span id='android-app-Activity-method-setProgressBarIndeterminateVisibility'>/**Sets the visibility of the indeterminate progress bar in the title.
</span> &lt;p&gt;
 In order for the progress bar to be shown, the feature must be requested
 via {@link #requestWindowFeature}(int).
@param {Boolean} visible Whether to show the progress bars in the title.
@deprecated No longer supported starting in API 21.
*/
setProgressBarIndeterminateVisibility : function(  ) {},

<span id='android-app-Activity-method-setProgressBarIndeterminate'>/**Sets whether the horizontal progress bar in the title should be indeterminate (the circular
</span> is always indeterminate).
 &lt;p&gt;
 In order for the progress bar to be shown, the feature must be requested
 via {@link #requestWindowFeature}(int).
@param {Boolean} indeterminate Whether the horizontal progress bar should be indeterminate.
@deprecated No longer supported starting in API 21.
*/
setProgressBarIndeterminate : function(  ) {},

<span id='android-app-Activity-method-setProgress'>/**Sets the progress for the progress bars in the title.
</span> &lt;p&gt;
 In order for the progress bar to be shown, the feature must be requested
 via {@link #requestWindowFeature}(int).
@param {Number} progress The progress for the progress bar. Valid ranges are from
            0 to 10000 (both inclusive). If 10000 is given, the progress
            bar will be completely filled and will fade out.
@deprecated No longer supported starting in API 21.
*/
setProgress : function(  ) {},

<span id='android-app-Activity-method-setSecondaryProgress'>/**Sets the secondary progress for the progress bar in the title. This
</span> progress is drawn between the primary progress (set via
 {@link #setProgress}(int) and the background. It can be ideal for media
 scenarios such as showing the buffering progress while the default
 progress shows the play progress.
 &lt;p&gt;
 In order for the progress bar to be shown, the feature must be requested
 via {@link #requestWindowFeature}(int).
@param {Number} secondaryProgress The secondary progress for the progress bar. Valid ranges are from
            0 to 10000 (both inclusive).
@deprecated No longer supported starting in API 21.
*/
setSecondaryProgress : function(  ) {},

<span id='android-app-Activity-method-setVolumeControlStream'>/**Suggests an audio stream whose volume should be changed by the hardware
</span> volume controls.
 &lt;p&gt;
 The suggested audio stream will be tied to the window of this Activity.
 Volume requests which are received while the Activity is in the
 foreground will affect this stream.
 &lt;p&gt;
 It is not guaranteed that the hardware volume controls will always change
 this stream's volume (for example, if a call is in progress, its stream's
 volume may be changed instead). To reset back to the default, use
 {@link AudioManager#USE_DEFAULT_STREAM_TYPE}.
@param {Number} streamType The type of the audio stream whose volume should be
            changed by the hardware volume controls.
*/
setVolumeControlStream : function(  ) {},

<span id='android-app-Activity-method-getVolumeControlStream'>/**Gets the suggested audio stream whose volume should be changed by the
</span> hardware volume controls.
@return {Number} The suggested audio stream type whose volume should be changed by
         the hardware volume controls.
@see #setVolumeControlStream(int)
*/
getVolumeControlStream : function(  ) {},

<span id='android-app-Activity-method-setMediaController'>/**Sets a {@link MediaController} to send media keys and volume changes to.
</span> &lt;p&gt;
 The controller will be tied to the window of this Activity. Media key and
 volume events which are received while the Activity is in the foreground
 will be forwarded to the controller and used to invoke transport controls
 or adjust the volume. This may be used instead of or in addition to
 {@link #setVolumeControlStream} to affect a specific session instead of a
 specific stream.
 &lt;p&gt;
 It is not guaranteed that the hardware volume controls will always change
 this session's volume (for example, if a call is in progress, its
 stream's volume may be changed instead). To reset back to the default use
 null as the controller.
@param {Object {MediaController}} controller The controller for the session which should receive
            media keys and volume changes.
*/
setMediaController : function(  ) {},

<span id='android-app-Activity-method-getMediaController'>/**Gets the controller which should be receiving media key and volume events
</span> while this activity is in the foreground.
@return {Object {android.media.session.MediaController}} The controller which should receive events.
@see #setMediaController(android.media.session.MediaController)
*/
getMediaController : function(  ) {},

<span id='android-app-Activity-method-runOnUiThread'>/**Runs the specified action on the UI thread. If the current thread is the UI
</span> thread, then the action is executed immediately. If the current thread is
 not the UI thread, the action is posted to the event queue of the UI thread.
@param {Object {Runnable}} action the action to run on the UI thread
*/
runOnUiThread : function(  ) {},

<span id='android-app-Activity-method-autofillClientRunOnUiThread'>/**
</span>@hide 
*/
autofillClientRunOnUiThread : function(  ) {},

<span id='android-app-Activity-method-onCreateView'>/**Standard implementation of
</span> {@link android.view.LayoutInflater.Factory#onCreateView} used when
 inflating with the LayoutInflater returned by {@link #getSystemService}.
 This implementation does nothing and is for
 pre-{@link android.os.Build.VERSION_CODES#HONEYCOMB} apps.  Newer apps
 should use {@link #onCreateView(View, String, Context, AttributeSet)}.
@see android.view.LayoutInflater#createView
@see android.view.Window#getLayoutInflater
*/
onCreateView : function(  ) {},

<span id='android-app-Activity-method-onCreateView'>/**Standard implementation of
</span> {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 This implementation handles &lt;fragment&gt; tags to embed fragments inside
 of the activity.
@see android.view.LayoutInflater#createView
@see android.view.Window#getLayoutInflater
*/
onCreateView : function(  ) {},

<span id='android-app-Activity-method-dump'>/**Print the Activity's state into the given stream.  This gets invoked if
</span> you run &quot;adb shell dumpsys activity &amp;lt;activity_component_name&amp;gt;&quot;.
@param {String} prefix Desired prefix to prepend at each line of output.
@param {Object {FileDescriptor}} fd The raw file descriptor that the dump is being sent to.
@param {Object {PrintWriter}} writer The PrintWriter to which you should dump your state.  This will be
 closed for you after you return.
@param {Object {java.lang.String[]}} args additional arguments to the dump request.
*/
dump : function(  ) {},

<span id='android-app-Activity-method-isImmersive'>/**Bit indicating that this activity is &quot;immersive&quot; and should not be
</span> interrupted by notifications if possible.

 This value is initially set by the manifest property
 &lt;code&gt;android:immersive&lt;/code&gt; but may be changed at runtime by
 {@link #setImmersive}.
@see #setImmersive(boolean)
@see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
*/
isImmersive : function(  ) {},

<span id='android-app-Activity-method-convertFromTranslucent'>/**Convert a translucent themed Activity {@link android.R.attr#windowIsTranslucent} to a
</span> fullscreen opaque Activity.
 &lt;p&gt;
 Call this whenever the background of a translucent Activity has changed to become opaque.
 Doing so will allow the {@link android.view.Surface} of the Activity behind to be released.
 &lt;p&gt;
 This call has no effect on non-translucent activities or on activities with the
 {@link android.R.attr#windowIsFloating} attribute.
@see #convertToTranslucent(android.app.Activity.TranslucentConversionListener,
 ActivityOptions)
@see TranslucentConversionListener
@hide 
*/
convertFromTranslucent : function(  ) {},

<span id='android-app-Activity-method-convertToTranslucent'>/**Convert a translucent themed Activity {@link android.R.attr#windowIsTranslucent} back from
</span> opaque to translucent following a call to {@link #convertFromTranslucent}().
 &lt;p&gt;
 Calling this allows the Activity behind this one to be seen again. Once all such Activities
 have been redrawn {@link android.app.Activity.TranslucentConversionListener#onTranslucentConversionComplete} will
 be called indicating that it is safe to make this activity translucent again. Until
 {@link android.app.Activity.TranslucentConversionListener#onTranslucentConversionComplete} is called the image
 behind the frontmost Activity will be indeterminate.
 &lt;p&gt;
 This call has no effect on non-translucent activities or on activities with the
 {@link android.R.attr#windowIsFloating} attribute.
@param {Object {Activity.TranslucentConversionListener}} callback the method to call when all visible Activities behind this one have been
 drawn and it is safe to make this Activity translucent again.
@param {Object {ActivityOptions}} options activity options delivered to the activity below this one. The options
 are retrieved using {@link #getActivityOptions}.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if Window was opaque and will become translucent or
 &lt;code&gt;false&lt;/code&gt; if window was translucent and no change needed to be made.
@see #convertFromTranslucent()
@see TranslucentConversionListener
@hide 
*/
convertToTranslucent : function(  ) {},

<span id='android-app-Activity-method-onNewActivityOptions'>/**
</span>@hide 
*/
onNewActivityOptions : function(  ) {},

<span id='android-app-Activity-method-requestVisibleBehind'>/**Activities that want to remain visible behind a translucent activity above them must call
</span> this method anytime between the start of {@link #onResume}() and the return from
 {@link #onPause}(). If this call is successful then the activity will remain visible after
 {@link #onPause}() is called, and is allowed to continue playing media in the background.

 &lt;p&gt;The actions of this call are reset each time that this activity is brought to the
 front. That is, every time {@link #onResume}() is called the activity will be assumed
 to not have requested visible behind. Therefore, if you want this activity to continue to
 be visible in the background you must call this method again.

 &lt;p&gt;Only fullscreen opaque activities may make this call. I.e. this call is a nop
 for dialog and translucent activities.

 &lt;p&gt;Under all circumstances, the activity must stop playing and release resources prior to or
 within a call to {@link #onVisibleBehindCanceled}() or if this call returns false.

 &lt;p&gt;False will be returned any time this method is called between the return of onPause and
      the next call to onResume.
@param {Boolean} visible true to notify the system that the activity wishes to be visible behind other
                translucent activities, false to indicate otherwise. Resources must be
                released when passing false to this method.
@param visible true to notify the system that the activity wishes to be visible behind other
                translucent activities, false to indicate otherwise. Resources must be
                released when passing false to this method.
@return {Boolean} the resulting visibiity state. If true the activity will remain visible beyond
      {@link #onPause()} if the next activity is translucent or not fullscreen. If false
      then the activity may not count on being visible behind other translucent activities,
      and must stop any media playback and release resources.
      Returning false may occur in lieu of a call to {@link #onVisibleBehindCanceled()} so
      the return value must be checked.
@see #onVisibleBehindCanceled()
*/
requestVisibleBehind : function(  ) {},

<span id='android-app-Activity-method-onVisibleBehindCanceled'>/**Called when a translucent activity over this activity is becoming opaque or another
</span> activity is being launched. Activities that override this method must call
 &lt;code&gt;super.onVisibleBehindCanceled()&lt;/code&gt; or a SuperNotCalledException will be thrown.

 &lt;p&gt;When this method is called the activity has 500 msec to release any resources it may be
 using while visible in the background.
 If the activity has not returned from this method in 500 msec the system will destroy
 the activity and kill the process in order to recover the resources for another
 process. Otherwise {@link #onStop}() will be called following return.
@see #requestVisibleBehind(boolean)
@deprecated This method's functionality is no longer supported as of
 {@link android.os.Build.VERSION_CODES#O} and will be removed in a future release.
*/
onVisibleBehindCanceled : function(  ) {},

<span id='android-app-Activity-method-isBackgroundVisibleBehind'>/**Translucent activities may call this to determine if there is an activity below them that
</span> is currently set to be visible in the background.
@deprecated This method's functionality is no longer supported as of
 {@link android.os.Build.VERSION_CODES#O} and will be removed in a future release.
@return {Boolean} true if an activity below is set to visible according to the most recent call to
 {@link #requestVisibleBehind(boolean)}, false otherwise.
@see #requestVisibleBehind(boolean)
@see #onVisibleBehindCanceled()
@see #onBackgroundVisibleBehindChanged(boolean)
@hide 
*/
isBackgroundVisibleBehind : function(  ) {},

<span id='android-app-Activity-method-onBackgroundVisibleBehindChanged'>/**The topmost foreground activity will receive this call when the background visibility state
</span> of the activity below it changes.

 This call may be a consequence of {@link #requestVisibleBehind}(boolean) or might be
 due to a background activity finishing itself.
@param {Boolean} visible true if a background activity is visible, false otherwise.
@param visible true if a background activity is visible, false otherwise.
@see #requestVisibleBehind(boolean)
@see #onVisibleBehindCanceled()
@hide 
*/
onBackgroundVisibleBehindChanged : function(  ) {},

<span id='android-app-Activity-method-onEnterAnimationComplete'>/**Activities cannot draw during the period that their windows are animating in. In order
</span> to know when it is safe to begin drawing they can override this method which will be
 called when the entering animation has completed.
*/
onEnterAnimationComplete : function(  ) {},

<span id='android-app-Activity-method-dispatchEnterAnimationComplete'>/**
</span>@hide 
*/
dispatchEnterAnimationComplete : function(  ) {},

<span id='android-app-Activity-method-setImmersive'>/**Adjust the current immersive mode setting.
</span>
 Note that changing this value will have no effect on the activity's
 {@link android.content.pm.ActivityInfo} structure; that is, if
 &lt;code&gt;android:immersive&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;
 in the application's manifest entry for this activity, the {@link android.content.pm.android.app.ActivityInfo#flags android.app.ActivityInfo.flags} member will
 always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 FLAG_IMMERSIVE} bit set.
@see #isImmersive()
@see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
*/
setImmersive : function(  ) {},

<span id='android-app-Activity-method-setVrModeEnabled'>/**Enable or disable virtual reality (VR) mode for this Activity.
</span>
 &lt;p&gt;VR mode is a hint to Android system to switch to a mode optimized for VR applications
 while this Activity has user focus.&lt;/p&gt;

 &lt;p&gt;It is recommended that applications additionally declare
 {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 transitions when switching between VR activities.&lt;/p&gt;

 &lt;p&gt;If the requested {@link android.service.vr.VrListenerService} component is not available,
 VR mode will not be started.  Developers can handle this case as follows:&lt;/p&gt;

 &lt;pre&gt;
 String servicePackage = &quot;com.whatever.app&quot;;
 String serviceClass = &quot;com.whatever.app.MyVrListenerService&quot;;

 // Name of the component of the VrListenerService to start.
 ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);

 try {
    setVrModeEnabled(true, myComponentName);
 } catch (PackageManager.NameNotFoundException e) {
        List&amp;lt;ApplicationInfo&gt; installed = getPackageManager().getInstalledApplications(0);
        boolean isInstalled = false;
        for (ApplicationInfo app : installed) {
            if (app.packageName.equals(servicePackage)) {
                isInstalled = true;
                break;
            }
        }
        if (isInstalled) {
            // Package is installed, but not enabled in Settings.  Let user enable it.
            startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
        } else {
            // Package is not installed.  Send an intent to download this.
            sentIntentToLaunchAppStore(servicePackage);
        }
 }
 &lt;/pre&gt;
@param {Boolean} enabled {@code true} to enable this mode.
@param {Object {ComponentName}} requestedComponent the name of the component to use as a
        {@link android.service.vr.VrListenerService} while VR mode is enabled.
@throws android.content.pm.PackageManager.NameNotFoundException if the given component
    to run as a {@link android.service.vr.VrListenerService} is not installed, or has
    not been enabled in user settings.
@see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
@see android.service.vr.VrListenerService
@see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
@see android.R.attr#enableVrMode
*/
setVrModeEnabled : function(  ) {},

<span id='android-app-Activity-method-startActionMode'>/**Start an action mode of the default type {@link android.app.Notification.ActionMode#TYPE_PRIMARY}.
</span>@param {Object {ActionMode.Callback}} callback Callback that will manage lifecycle events for this action mode
@return {Object {android.view.ActionMode}} The ActionMode that was started, or null if it was canceled
@see ActionMode
*/
startActionMode : function(  ) {},

<span id='android-app-Activity-method-startActionMode'>/**Start an action mode of the given type.
</span>@param {Object {ActionMode.Callback}} callback Callback that will manage lifecycle events for this action mode
@param {Number} type One of {@link ActionMode#TYPE_PRIMARY} or {@link ActionMode#TYPE_FLOATING}.
@return {Object {android.view.ActionMode}} The ActionMode that was started, or null if it was canceled
@see ActionMode
*/
startActionMode : function(  ) {},

<span id='android-app-Activity-method-onWindowStartingActionMode'>/**Give the Activity a chance to control the UI for an action mode requested
</span> by the system.

 &lt;p&gt;Note: If you are looking for a notification callback that an action mode
 has been started for this activity, see {@link #onActionModeStarted}(ActionMode).&lt;/p&gt;
@param {Object {ActionMode.Callback}} callback The callback that should control the new action mode
@return {Object {android.view.ActionMode}} The new action mode, or &lt;code&gt;null&lt;/code&gt; if the activity does not want to
         provide special handling for this action mode. (It will be handled by the system.)
*/
onWindowStartingActionMode : function(  ) {},

<span id='android-app-Activity-method-onWindowStartingActionMode'>/**{@inheritDoc}
</span>*/
onWindowStartingActionMode : function(  ) {},

<span id='android-app-Activity-method-onActionModeStarted'>/**Notifies the Activity that an action mode has been started.
</span> Activity subclasses overriding this method should call the superclass implementation.
@param {Object {ActionMode}} mode The new action mode.
*/
onActionModeStarted : function(  ) {},

<span id='android-app-Activity-method-onActionModeFinished'>/**Notifies the activity that an action mode has finished.
</span> Activity subclasses overriding this method should call the superclass implementation.
@param {Object {ActionMode}} mode The action mode that just finished.
*/
onActionModeFinished : function(  ) {},

<span id='android-app-Activity-method-shouldUpRecreateTask'>/**Returns true if the app should recreate the task when navigating 'up' from this activity
</span> by using targetIntent.

 &lt;p&gt;If this method returns false the app can trivially call
 {@link #navigateUpTo}(Intent) using the same parameters to correctly perform
 up navigation. If this method returns false, the app should synthesize a new task stack
 by using {@link android.app.TaskStackBuilder} or another similar mechanism to perform up navigation.&lt;/p&gt;
@param {Object {Intent}} targetIntent An intent representing the target destination for up navigation
@return {Boolean} true if navigating up should recreate a new task stack, false if the same task
         should be used for the destination
*/
shouldUpRecreateTask : function(  ) {},

<span id='android-app-Activity-method-navigateUpTo'>/**Navigate from this activity to the activity specified by upIntent, finishing this activity
</span> in the process. If the activity indicated by upIntent already exists in the task's history,
 this activity and all others before the indicated activity in the history stack will be
 finished.

 &lt;p&gt;If the indicated activity does not appear in the history stack, this will finish
 each activity in this task until the root activity of the task is reached, resulting in
 an &quot;in-app home&quot; behavior. This can be useful in apps with a complex navigation hierarchy
 when an activity may be reached by a path not passing through a canonical parent
 activity.&lt;/p&gt;

 &lt;p&gt;This method should be used when performing up navigation from within the same task
 as the destination. If up navigation should cross tasks in some cases, see
 {@link #shouldUpRecreateTask}(Intent).&lt;/p&gt;
@param {Object {Intent}} upIntent An intent representing the target destination for up navigation
@return {Boolean} true if up navigation successfully reached the activity indicated by upIntent and
         upIntent was delivered to it. false if an instance of the indicated activity could
         not be found and this activity was simply finished normally.
*/
navigateUpTo : function(  ) {},

<span id='android-app-Activity-method-navigateUpToFromChild'>/**This is called when a child activity of this one calls its
</span> {@link #navigateUpTo} method.  The default implementation simply calls
 navigateUpTo(upIntent) on this activity (the parent).
@param {Object {Activity}} child The activity making the call.
@param {Object {Intent}} upIntent An intent representing the target destination for up navigation
@return {Boolean} true if up navigation successfully reached the activity indicated by upIntent and
         upIntent was delivered to it. false if an instance of the indicated activity could
         not be found and this activity was simply finished normally.
*/
navigateUpToFromChild : function(  ) {},

<span id='android-app-Activity-method-getParentActivityIntent'>/**Obtain an {@link Intent} that will launch an explicit target activity specified by
</span> this activity's logical parent. The logical parent is named in the application's manifest
 by the {@link android.R.attr#parentActivityName parentActivityName} attribute.
 Activity subclasses may override this method to modify the Intent returned by
 super.getParentActivityIntent() or to implement a different mechanism of retrieving
 the parent intent entirely.
@return {Object {android.content.Intent}} a new Intent targeting the defined parent of this activity or null if
         there is no valid parent.
*/
getParentActivityIntent : function(  ) {},

<span id='android-app-Activity-method-setEnterSharedElementCallback'>/**When {@link android.app.ActivityOptions#makeSceneTransitionAnimation(Activity,
</span> android.view.View, String)} was used to start an Activity, &lt;var&gt;callback&lt;/var&gt;
 will be called to handle shared elements on the &lt;i&gt;launched&lt;/i&gt; Activity. This requires
 {@link Window#FEATURE_ACTIVITY_TRANSITIONS}.
@param {Object {SharedElementCallback}} callback Used to manipulate shared element transitions on the launched Activity.
*/
setEnterSharedElementCallback : function(  ) {},

<span id='android-app-Activity-method-setExitSharedElementCallback'>/**When {@link android.app.ActivityOptions#makeSceneTransitionAnimation(Activity,
</span> android.view.View, String)} was used to start an Activity, &lt;var&gt;callback&lt;/var&gt;
 will be called to handle shared elements on the &lt;i&gt;launching&lt;/i&gt; Activity. Most
 calls will only come when returning from the started Activity.
 This requires {@link Window#FEATURE_ACTIVITY_TRANSITIONS}.
@param {Object {SharedElementCallback}} callback Used to manipulate shared element transitions on the launching Activity.
*/
setExitSharedElementCallback : function(  ) {},

<span id='android-app-Activity-method-postponeEnterTransition'>/**Postpone the entering activity transition when Activity was started with
</span> {@link android.app.ActivityOptions#makeSceneTransitionAnimation(Activity,
 android.util.Pair[])}.
 &lt;p&gt;This method gives the Activity the ability to delay starting the entering and
 shared element transitions until all data is loaded. Until then, the Activity won't
 draw into its window, leaving the window transparent. This may also cause the
 returning animation to be delayed until data is ready. This method should be
 called in {@link #onCreate(android.os.Bundle)} or in
 {@link #onActivityReenter(int, android.content.Intent)}.
 {@link #startPostponedEnterTransition}() must be called to allow the Activity to
 start the transitions. If the Activity did not use
 {@link android.app.ActivityOptions#makeSceneTransitionAnimation(Activity,
 android.util.Pair[])}, then this method does nothing.&lt;/p&gt;
*/
postponeEnterTransition : function(  ) {},

<span id='android-app-Activity-method-startPostponedEnterTransition'>/**Begin postponed transitions after {@link #postponeEnterTransition}() was called.
</span> If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
 to have your Activity start drawing.
*/
startPostponedEnterTransition : function(  ) {},

<span id='android-app-Activity-method-requestDragAndDropPermissions'>/**Create {@link DragAndDropPermissions} object bound to this activity and controlling the
</span> access permissions for content URIs associated with the {@link DragEvent}.
@param {Object {DragEvent}} event Drag event
@return {Object {android.view.DragAndDropPermissions}} The {@link DragAndDropPermissions} object used to control access to the content URIs.
 Null if no content URIs are associated with the event or if permissions could not be granted.
*/
requestDragAndDropPermissions : function(  ) {},

<span id='android-app-Activity-method-getActivityToken'>/**
</span>@hide 
*/
getActivityToken : function(  ) {},

<span id='android-app-Activity-method-getAssistToken'>/**
</span>@hide 
*/
getAssistToken : function(  ) {},

<span id='android-app-Activity-method-getActivityThread'>/**
</span>@hide 
*/
getActivityThread : function(  ) {},

<span id='android-app-Activity-method-isResumed'>/**
</span>@hide 
*/
isResumed : function(  ) {},

<span id='android-app-Activity-method-startLockTask'>/**Request to put this activity in a mode where the user is locked to a restricted set of
</span> applications.

 &lt;p&gt;If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns {@code true}
 for this component, the current task will be launched directly into LockTask mode. Only apps
 whitelisted by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])} can
 be launched while LockTask mode is active. The user will not be able to leave this mode
 until this activity calls {@link #stopLockTask}(). Calling this method while the device is
 already in LockTask mode has no effect.

 &lt;p&gt;Otherwise, the current task will be launched into screen pinning mode. In this case, the
 system will prompt the user with a dialog requesting permission to use this mode.
 The user can exit at any time through instructions shown on the request dialog. Calling
 {@link #stopLockTask}() will also terminate this mode.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; this method can only be called when the activity is foreground.
 That is, between {@link #onResume}() and {@link #onPause}().
@see #stopLockTask()
@see android.R.attr#lockTaskMode
*/
startLockTask : function(  ) {},

<span id='android-app-Activity-method-stopLockTask'>/**Stop the current task from being locked.
</span>
 &lt;p&gt;Called to end the LockTask or screen pinning mode started by {@link #startLockTask}().
 This can only be called by activities that have called {@link #startLockTask}() previously.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If the device is in LockTask mode that is not initially started
 by this activity, then calling this method will not terminate the LockTask mode, but only
 finish its own task. The device will remain in LockTask mode, until the activity which
 started the LockTask mode calls this method, or until its whitelist authorization is revoked
 by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
@see #startLockTask()
@see android.R.attr#lockTaskMode
@see ActivityManager#getLockTaskModeState()
*/
stopLockTask : function(  ) {},

<span id='android-app-Activity-method-showLockTaskEscapeMessage'>/**Shows the user the system defined message for telling the user how to exit
</span> lock task mode. The task containing this activity must be in lock task mode at the time
 of this call for the message to be displayed.
*/
showLockTaskEscapeMessage : function(  ) {},

<span id='android-app-Activity-method-isOverlayWithDecorCaptionEnabled'>/**Check whether the caption on freeform windows is displayed directly on the content.
</span>@return {Boolean} True if caption is displayed on content, false if it pushes the content down.
@see #setOverlayWithDecorCaptionEnabled(boolean)
@hide 
*/
isOverlayWithDecorCaptionEnabled : function(  ) {},

<span id='android-app-Activity-method-setOverlayWithDecorCaptionEnabled'>/**Set whether the caption should displayed directly on the content rather than push it down.
</span>
 This affects only freeform windows since they display the caption and only the main
 window of the activity. The caption is used to drag the window around and also shows
 maximize and close action buttons.
@hide 
*/
setOverlayWithDecorCaptionEnabled : function(  ) {},

<span id='android-app-Activity-method-autofillClientAuthenticate'>/**
</span>@hide 
*/
autofillClientAuthenticate : function(  ) {},

<span id='android-app-Activity-method-autofillClientResetableStateAvailable'>/**
</span>@hide 
*/
autofillClientResetableStateAvailable : function(  ) {},

<span id='android-app-Activity-method-autofillClientRequestShowFillUi'>/**
</span>@hide 
*/
autofillClientRequestShowFillUi : function(  ) {},

<span id='android-app-Activity-method-autofillClientDispatchUnhandledKey'>/**
</span>@hide 
*/
autofillClientDispatchUnhandledKey : function(  ) {},

<span id='android-app-Activity-method-autofillClientRequestHideFillUi'>/**
</span>@hide 
*/
autofillClientRequestHideFillUi : function(  ) {},

<span id='android-app-Activity-method-autofillClientIsFillUiShowing'>/**
</span>@hide 
*/
autofillClientIsFillUiShowing : function(  ) {},

<span id='android-app-Activity-method-autofillClientFindViewsByAutofillIdTraversal'>/**
</span>@hide 
*/
autofillClientFindViewsByAutofillIdTraversal : function(  ) {},

<span id='android-app-Activity-method-autofillClientFindViewByAutofillIdTraversal'>/**
</span>@hide 
*/
autofillClientFindViewByAutofillIdTraversal : function(  ) {},

<span id='android-app-Activity-method-autofillClientGetViewVisibility'>/**
</span>@hide 
*/
autofillClientGetViewVisibility : function(  ) {},

<span id='android-app-Activity-method-autofillClientFindViewByAccessibilityIdTraversal'>/**
</span>@hide 
*/
autofillClientFindViewByAccessibilityIdTraversal : function(  ) {},

<span id='android-app-Activity-method-autofillClientGetActivityToken'>/**
</span>@hide 
*/
autofillClientGetActivityToken : function(  ) {},

<span id='android-app-Activity-method-autofillClientIsVisibleForAutofill'>/**
</span>@hide 
*/
autofillClientIsVisibleForAutofill : function(  ) {},

<span id='android-app-Activity-method-autofillClientIsCompatibilityModeEnabled'>/**
</span>@hide 
*/
autofillClientIsCompatibilityModeEnabled : function(  ) {},

<span id='android-app-Activity-method-isDisablingEnterExitEventForAutofill'>/**
</span>@hide 
*/
isDisablingEnterExitEventForAutofill : function(  ) {},

<span id='android-app-Activity-method-setDisablePreviewScreenshots'>/**If set to true, this indicates to the system that it should never take a
</span> screenshot of the activity to be used as a representation while it is not in a started state.
 &lt;p&gt;
 Note that the system may use the window background of the theme instead to represent
 the window when it is not running.
 &lt;p&gt;
 Also note that in comparison to {@link android.view.WindowManager.LayoutParams#FLAG_SECURE},
 this only affects the behavior when the activity's screenshot would be used as a
 representation when the activity is not in a started state, i.e. in Overview. The system may
 still take screenshots of the activity in other contexts; for example, when the user takes a
 screenshot of the entire screen, or when the active
 {@link android.service.voice.VoiceInteractionService} requests a screenshot via
 {@link android.service.voice.VoiceInteractionSession#SHOW_WITH_SCREENSHOT}.
@param {Boolean} disable {@code true} to disable preview screenshots; {@code false} otherwise.
@hide 
*/
setDisablePreviewScreenshots : function(  ) {},

<span id='android-app-Activity-method-setShowWhenLocked'>/**Specifies whether an {@link android.app.Activity} should be shown on top of the lock screen whenever
</span> the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
 to the stopped state if it is started while the lockscreen is up, but with this flag set the
 activity will remain in the resumed state visible on-top of the lock screen. This value can
 be set as a manifest attribute using {@link android.R.attr#showWhenLocked}.
@param {Boolean} showWhenLocked {@code true} to show the {@link Activity} on top of the lock screen;
                                   {@code false} otherwise.
@see #setTurnScreenOn(boolean)
@see android.R.attr#turnScreenOn
@see android.R.attr#showWhenLocked
*/
setShowWhenLocked : function(  ) {},

<span id='android-app-Activity-method-setInheritShowWhenLocked'>/**Specifies whether this {@link android.app.Activity} should be shown on top of the lock screen whenever
</span> the lockscreen is up and this activity has another activity behind it with the showWhenLock
 attribute set. That is, this activity is only visible on the lock screen if there is another
 activity with the showWhenLock attribute visible at the same time on the lock screen. A use
 case for this is permission dialogs, that should only be visible on the lock screen if their
 requesting activity is also visible. This value can be set as a manifest attribute using
 android.R.attr#inheritShowWhenLocked.
@param {Boolean} inheritShowWhenLocked {@code true} to show the {@link Activity} on top of the lock
                              screen when this activity has another activity behind it with
                              the showWhenLock attribute set; {@code false} otherwise.
@see #setShowWhenLocked(boolean)
@see android.R.attr#inheritShowWhenLocked
*/
setInheritShowWhenLocked : function(  ) {},

<span id='android-app-Activity-method-setTurnScreenOn'>/**Specifies whether the screen should be turned on when the {@link android.app.Activity} is resumed.
</span> Normally an activity will be transitioned to the stopped state if it is started while the
 screen if off, but with this flag set the activity will cause the screen to turn on if the
 activity will be visible and resumed due to the screen coming on. The screen will not be
 turned on if the activity won't be visible after the screen is turned on. This flag is
 normally used in conjunction with the {@link android.R.attr#showWhenLocked} flag to make sure
 the activity is visible after the screen is turned on when the lockscreen is up. In addition,
 if this flag is set and the activity calls {@link android.app.KeyguardManager#requestDismissKeyguard(Activity, android.app.KeyguardManager.KeyguardDismissCallback)}
 the screen will turn on.
@param {Boolean} turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
@see #setShowWhenLocked(boolean)
@see android.R.attr#turnScreenOn
@see android.R.attr#showWhenLocked
*/
setTurnScreenOn : function(  ) {},

<span id='android-app-Activity-method-registerRemoteAnimations'>/**Registers remote animations per transition type for this activity.
</span>@param {Object {RemoteAnimationDefinition}} definition The remote animation definition that defines which transition whould run
                   which remote animation.
@hide 
*/
registerRemoteAnimations : function(  ) {},


};</pre>
</body>
</html>
