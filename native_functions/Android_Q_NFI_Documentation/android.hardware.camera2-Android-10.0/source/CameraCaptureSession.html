<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-hardware-camera2-CameraCaptureSession'>/**@class android.hardware.camera2.CameraCaptureSession
</span> implements java.lang.AutoCloseable

@extends java.lang.Object

 A configured capture session for a {@link android.hardware.camera2.CameraDevice}, used for capturing images from the
 camera or reprocessing images captured from the camera in the same session previously.

 &lt;p&gt;A CameraCaptureSession is created by providing a set of target output surfaces to
 {@link android.hardware.camera2.CameraDevice#createCaptureSession createCaptureSession}, or by providing an
 {@link android.hardware.camera2.params.InputConfiguration} and a set of target output surfaces to
 {@link android.hardware.camera2.CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession} for a
 reprocessable capture session. Once created, the session is active until a new session is
 created by the camera device, or the camera device is closed.&lt;/p&gt;

 &lt;p&gt;All capture sessions can be used for capturing images from the camera but only reprocessable
 capture sessions can reprocess images captured from the camera in the same session previously.
 &lt;/p&gt;

 &lt;p&gt;Creating a session is an expensive operation and can take several hundred milliseconds, since
 it requires configuring the camera device's internal pipelines and allocating memory buffers for
 sending images to the desired targets. Therefore the setup is done asynchronously, and
 {@link android.hardware.camera2.CameraDevice#createCaptureSession createCaptureSession} and
 {@link android.hardware.camera2.CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession} will
 send the ready-to-use CameraCaptureSession to the provided listener's
 {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onConfigured onConfigured} callback. If configuration
 cannot be completed, then the
 {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onConfigureFailed onConfigureFailed} is called, and the
 session will not become active.&lt;/p&gt;
&lt;!--
 &lt;p&gt;Any capture requests (repeating or non-repeating) submitted before the session is ready will
 be queued up and will begin capture once the session becomes ready. In case the session cannot be
 configured and {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onConfigureFailed onConfigureFailed} is called, all queued
 capture requests are discarded.&lt;/p&gt;
--&gt;
 &lt;p&gt;If a new session is created by the camera device, then the previous session is closed, and its
 associated {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onClosed onClosed} callback will be invoked.  All
 of the session methods will throw an IllegalStateException if called once the session is
 closed.&lt;/p&gt;

 &lt;p&gt;A closed session clears any repeating requests (as if {@link #stopRepeating} had been called),
 but will still complete all of its in-progress capture requests as normal, before a newly
 created session takes over and reconfigures the camera device.&lt;/p&gt;
*/
var CameraCaptureSession = {

<span id='android-hardware-camera2-CameraCaptureSession-property-SESSION_ID_NONE'>/** Used to identify invalid session ID.
</span> @hide
*/
SESSION_ID_NONE : &quot;-1&quot;,
<span id='android-hardware-camera2-CameraCaptureSession-method-getDevice'>/**Get the camera device that this session is created for.
</span>*/
getDevice : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-prepare'>/**&lt;p&gt;Pre-allocate all buffers for an output Surface.&lt;/p&gt;
</span>
 &lt;p&gt;Normally, the image buffers for a given output Surface are allocated on-demand,
 to minimize startup latency and memory overhead.&lt;/p&gt;

 &lt;p&gt;However, in some cases, it may be desirable for the buffers to be allocated before
 any requests targeting the Surface are actually submitted to the device. Large buffers
 may take some time to allocate, which can result in delays in submitting requests until
 sufficient buffers are allocated to reach steady-state behavior. Such delays can cause
 bursts to take longer than desired, or cause skips or stutters in preview output.&lt;/p&gt;

 &lt;p&gt;The prepare() method can be used to perform this preallocation. It may only be called for
 a given output Surface before that Surface is used as a target for a request. The number of
 buffers allocated is the sum of the count needed by the consumer providing the output
 Surface, and the maximum number needed by the camera device to fill its pipeline. Since this
 may be a larger number than what is actually required for steady-state operation, using
 prepare may result in higher memory consumption than the normal on-demand behavior results
 in. Prepare() will also delay the time to first output to a given Surface, in exchange for
 smoother frame rate once the allocation is complete.&lt;/p&gt;

 &lt;p&gt;For example, an application that creates an
 {@link android.media.ImageReader#newInstance ImageReader} with a maxImages argument of 10,
 but only uses 3 simultaneous Images at once would normally only cause those 3 images to be
 allocated (plus what is needed by the camera device for smooth operation).  But using
 prepare() on the ImageReader Surface will result in all 10 Images being allocated. So
 applications using this method should take care to request only the number of buffers
 actually necessary for their application.&lt;/p&gt;

 &lt;p&gt;If the same output Surface is used in consecutive sessions (without closing the first
 session explicitly), then its already-allocated buffers are carried over, and if it was
 used as a target of a capture request in the first session, prepare cannot be called on it
 in the second session.&lt;/p&gt;

 &lt;p&gt;Once allocation is complete, {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onSurfacePrepared} will be invoked with
 the Surface provided to this method. Between the prepare call and the onSurfacePrepared call,
 the Surface provided to prepare must not be used as a target of a CaptureRequest submitted
 to this session.&lt;/p&gt;

 &lt;p&gt;Note that if 2 surfaces share the same stream via {@link OutputConfiguration#enableSurfaceSharing} and {@link OutputConfiguration#addSurface},
 prepare() only needs to be called on one surface, and {link
 StateCallback#onSurfacePrepared} will be triggered for both surfaces.&lt;/p&gt;

 &lt;p&gt;{@link android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}
 devices cannot pre-allocate output buffers; for those devices,
 {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onSurfacePrepared} will be immediately called, and no preallocation is
 done.&lt;/p&gt;
@param {Object {Surface}} surface the output Surface for which buffers should be pre-allocated. Must be one of
 the output Surfaces used to create this session.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has
                                  already been used as a target of a CaptureRequest in this
                                  session or immediately prior sessions.
@see StateCallback#onSurfacePrepared
*/
prepare : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-prepare'>/**&lt;p&gt;Pre-allocate at most maxCount buffers for an output Surface.&lt;/p&gt;
</span>
 &lt;p&gt;Like the {@link #prepare}(Surface) method, this method can be used to allocate output
 buffers for a given Surface.  However, while the {@link #prepare}(Surface) method allocates
 the maximum possible buffer count, this method allocates at most maxCount buffers.&lt;/p&gt;

 &lt;p&gt;If maxCount is greater than the possible maximum count (which is the sum of the buffer
 count requested by the creator of the Surface and the count requested by the camera device),
 only the possible maximum count is allocated, in which case the function acts exactly like
 {@link #prepare}(Surface).&lt;/p&gt;

 &lt;p&gt;The restrictions on when this method can be called are the same as for
 {@link #prepare}(Surface).&lt;/p&gt;

 &lt;p&gt;Repeated calls to this method are allowed, and a mix of {@link #prepare}(Surface) and
 this method is also allowed. Note that after the first call to {@link #prepare}(Surface),
 subsequent calls to either prepare method are effectively no-ops.  In addition, this method
 is not additive in terms of buffer count.  This means calling it twice with maxCount = 2
 will only allocate 2 buffers, not 4 (assuming the possible maximum is at least 2); to
 allocate two buffers on the first call and two on the second, the application needs to call
 prepare with prepare(surface, 2) and prepare(surface, 4).&lt;/p&gt;
@param {Number} maxCount the buffer count to try to allocate. If this is greater than the possible
                 maximum for this output, the possible maximum is allocated instead. If
                 maxCount buffers are already allocated, then prepare will do nothing.
@param {Object {Surface}} surface the output Surface for which buffers should be pre-allocated.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error.
@throws IllegalStateException if this session is no longer active, either because the
                               session was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException if the Surface is invalid, not part of this Session,
                                  or has already been used as a target of a CaptureRequest in
                                  this session or immediately prior sessions without an
                                  intervening tearDown call.
@hide 
*/
prepare : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-tearDown'>/**&lt;p&gt;Free all buffers allocated for an output Surface.&lt;/p&gt;
</span>
 &lt;p&gt;Normally, once allocated, the image buffers for a given output Surface remain allocated
 for the lifetime of the capture session, to minimize latency of captures and to reduce
 memory allocation overhead.&lt;/p&gt;

 &lt;p&gt;However, in some cases, it may be desirable for allocated buffers to be freed to reduce
 the application's memory consumption, if the particular output Surface will not be used by
 the application for some time.&lt;/p&gt;

 &lt;p&gt;The tearDown() method can be used to perform this operation. After the call finishes, all
 unfilled image buffers will have been freed. Any future use of the target Surface may require
 allocation of additional buffers, as if the session had just been created.  Buffers being
 held by the application (either explicitly as Image objects from ImageReader, or implicitly
 as the current texture in a SurfaceTexture or the current contents of a RS Allocation, will
 remain valid and allocated even when tearDown is invoked.&lt;/p&gt;

 &lt;p&gt;A Surface that has had tearDown() called on it is eligible to have prepare() invoked on it
 again even if it was used as a request target before the tearDown() call, as long as it
 doesn't get used as a target of a request between the tearDown() and prepare() calls.&lt;/p&gt;
@param {Object {Surface}} surface the output Surface for which buffers should be freed. Must be one of the
 the output Surfaces used to create this session.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error.
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has
                                  already been used as a target of a CaptureRequest in this
                                  session or immediately prior sessions.
@hide 
*/
tearDown : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-finalizeOutputConfigurations'>/**&lt;p&gt;Finalize the output configurations that now have their deferred and/or extra Surfaces
</span> included.&lt;/p&gt;

 &lt;p&gt;For camera use cases where a preview and other output configurations need to be
 configured, it can take some time for the preview Surface to be ready. For example, if the
 preview Surface is obtained from {@link android.view.SurfaceView}, the SurfaceView will only
 be ready after the UI layout is done, potentially delaying camera startup.&lt;/p&gt;

 &lt;p&gt;To speed up camera startup time, the application can configure the
 {@link android.hardware.camera2.CameraCaptureSession} with the eventual preview size (via
 {@link OutputConfiguration#OutputConfiguration(Size,Class) a deferred OutputConfiguration}),
 and defer the preview output configuration until the Surface is ready. After the
 {@link android.hardware.camera2.CameraCaptureSession} is created successfully with this deferred output and other
 normal outputs, the application can start submitting requests as long as they do not include
 deferred output Surfaces. Once a deferred Surface is ready, the application can add the
 Surface to the deferred output configuration with the
 {@link OutputConfiguration#addSurface} method, and then update the deferred output
 configuration via this method, before it can submit capture requests with this output
 target.&lt;/p&gt;

 &lt;p&gt;This function can also be called in case where multiple surfaces share the same
 OutputConfiguration, and one of the surfaces becomes available after the {@link android.hardware.camera2.CameraCaptureSession} is created. In that case, the application must first create the
 OutputConfiguration with the available Surface, then enable further surface sharing via
 {@link OutputConfiguration#enableSurfaceSharing}, before creating the CameraCaptureSession.
 After the CameraCaptureSession is created, and once the extra Surface becomes available, the
 application must then call {@link OutputConfiguration#addSurface} before finalizing the
 configuration with this method.&lt;/p&gt;

 &lt;p&gt;If the provided OutputConfigurations are unchanged from session creation, this function
 call has no effect. This function must only be called once for a particular output
 configuration. &lt;/p&gt;

 &lt;p&gt;The output Surfaces included by this list of
 {@link OutputConfiguration OutputConfigurations} can be used as {@link android.hardware.camera2.CaptureRequest}
 targets as soon as this call returns.&lt;/p&gt;

 &lt;p&gt;This method is not supported by
 {@link android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}-level devices.&lt;/p&gt;
@param {Object {java.util.List}} outputConfigs a list of {@link OutputConfiguration OutputConfigurations} that
            have had {@link OutputConfiguration#addSurface addSurface} invoked with a valid
            output Surface after {@link CameraDevice#createCaptureSessionByOutputConfigurations}.
@throws CameraAccessException if the camera device is no longer connected or has encountered
             a fatal error.
@throws IllegalStateException if this session is no longer active, either because the session
             was explicitly closed, a new session has been created, or the camera device has
             been closed.
@throws IllegalArgumentException for invalid output configurations, including ones where the
             source of the Surface is no longer valid or the Surface is from a unsupported
             source. Or if one of the output configuration was already finished with an
             included surface in a prior call.
*/
finalizeOutputConfigurations : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-capture'>/**&lt;p&gt;Submit a request for an image to be captured by the camera device.&lt;/p&gt;
</span>
 &lt;p&gt;The request defines all the parameters for capturing the single image,
 including sensor, lens, flash, and post-processing settings.&lt;/p&gt;

 &lt;p&gt;Each request will produce one {@link android.hardware.camera2.CaptureResult} and produce new frames for one or more
 target Surfaces, set with the CaptureRequest builder's
 {@link android.hardware.camera2.CaptureRequest.Builder#addTarget} method. The target surfaces (set with
 {@link android.hardware.camera2.CaptureRequest.Builder#addTarget}) must be a subset of the surfaces provided when this
 capture session was created.&lt;/p&gt;

 &lt;p&gt;Multiple regular and reprocess requests can be in progress at once. If there are only
 regular requests or reprocess requests in progress, they are processed in first-in,
 first-out order. If there are both regular and reprocess requests in progress, regular
 requests are processed in first-in, first-out order and reprocess requests are processed in
 first-in, first-out order, respectively. However, the processing order of a regular request
 and a reprocess request in progress is not specified. In other words, a regular request
 will always be processed before regular requets that are submitted later. A reprocess request
 will always be processed before reprocess requests that are submitted later. However, a
 regular request may not be processed before reprocess requests that are submitted later.&lt;p&gt;

 &lt;p&gt;Requests submitted through this method have higher priority than
 those submitted through {@link #setRepeatingRequest} or
 {@link #setRepeatingBurst}, and will be processed as soon as the current
 repeat/repeatBurst processing completes.&lt;/p&gt;

 &lt;p&gt;All capture sessions can be used for capturing images from the camera but only capture
 sessions created by
 {@link android.hardware.camera2.CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession}
 can submit reprocess capture requests. Submitting a reprocess request to a regular capture
 session will result in an {@link IllegalArgumentException}.&lt;/p&gt;
@param {Object {CaptureRequest}} request the settings for this capture
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify once this request has been
 processed. If null, no metadata will be produced for this capture,
 although image data will still be produced.
@param {Object {Handler}} handler the handler on which the listener should be invoked, or
 {@code null} to use the current thread's {@link android.os.Looper
 looper}.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not
                                  configured as outputs for this session; or the request
                                  targets a set of Surfaces that cannot be submitted
                                  simultaneously in a reprocessable capture session; or a
                                  reprocess capture request is submitted in a
                                  non-reprocessable capture session; or the reprocess capture
                                  request was created with a {@link TotalCaptureResult} from
                                  a different session; or the capture targets a Surface in
                                  the middle of being {@link #prepare prepared}; or the
                                  handler is null, the listener is not null, and the calling
                                  thread has no looper.
@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst
@see #abortCaptures
@see CameraDevice#createReprocessableCaptureSession
*/
capture : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-captureSingleRequest'>/**&lt;p&gt;Submit a request for an image to be captured by the camera device.&lt;/p&gt;
</span>
 &lt;p&gt;The behavior of this method matches that of
 {@link #capture(CaptureRequest, android.hardware.camera2.CameraCaptureSession.CaptureCallback, Handler)},
 except that it uses {@link java.util.concurrent.Executor} as an argument
 instead of {@link android.os.Handler}.&lt;/p&gt;
@param {Object {CaptureRequest}} request the settings for this capture
@param {Object {Executor}} executor the executor which will be used for invoking the listener.
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify once this request has been
 processed.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not
                                  configured as outputs for this session; or the request
                                  targets a set of Surfaces that cannot be submitted
                                  simultaneously in a reprocessable capture session; or a
                                  reprocess capture request is submitted in a
                                  non-reprocessable capture session; or the reprocess capture
                                  request was created with a {@link TotalCaptureResult} from
                                  a different session; or the capture targets a Surface in
                                  the middle of being {@link #prepare prepared}; or the
                                  executor is null, or the listener is not null.
@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst
@see #abortCaptures
@see CameraDevice#createReprocessableCaptureSession
*/
captureSingleRequest : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-captureBurst'>/**Submit a list of requests to be captured in sequence as a burst. The
</span> burst will be captured in the minimum amount of time possible, and will
 not be interleaved with requests submitted by other capture or repeat
 calls.

 &lt;p&gt;Regular and reprocess requests can be mixed together in a single burst. Regular requests
 will be captured in order and reprocess requests will be processed in order, respectively.
 However, the processing order between a regular request and a reprocess request is not
 specified. Each capture produces one {@link android.hardware.camera2.CaptureResult} and image buffers for one or more
 target {@link android.view.Surface surfaces}. The target surfaces (set with
 {@link android.hardware.camera2.CaptureRequest.Builder#addTarget}) must be a subset of the surfaces provided when
 this capture session was created.&lt;/p&gt;

 &lt;p&gt;The main difference between this method and simply calling
 {@link #capture} repeatedly is that this method guarantees that no
 other requests will be interspersed with the burst.&lt;/p&gt;

 &lt;p&gt;All capture sessions can be used for capturing images from the camera but only capture
 sessions created by
 {@link android.hardware.camera2.CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession}
 can submit reprocess capture requests. Submitting a reprocess request to a regular
 capture session will result in an {@link IllegalArgumentException}.&lt;/p&gt;
@param {Object {java.util.List}} requests the list of settings for this burst capture
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify each time one of the
 requests in the burst has been processed. If null, no metadata will be
 produced for any requests in this burst, although image data will still
 be produced.
@param {Object {Handler}} handler the handler on which the listener should be invoked, or
 {@code null} to use the current thread's {@link android.os.Looper
 looper}.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException If the requests target no Surfaces, or the requests target
                                  Surfaces not currently configured as outputs; or one of the
                                  requests targets a set of Surfaces that cannot be submitted
                                  simultaneously in a reprocessable capture session; or a
                                  reprocess capture request is submitted in a
                                  non-reprocessable capture session; or one of the reprocess
                                  capture requests was created with a
                                  {@link TotalCaptureResult} from a different session; or one
                                  of the captures targets a Surface in the middle of being
                                  {@link #prepare prepared}; or if the handler is null, the
                                  listener is not null, and the calling thread has no looper.
@see #capture
@see #setRepeatingRequest
@see #setRepeatingBurst
@see #abortCaptures
*/
captureBurst : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-captureBurstRequests'>/**Submit a list of requests to be captured in sequence as a burst. The
</span> burst will be captured in the minimum amount of time possible, and will
 not be interleaved with requests submitted by other capture or repeat
 calls.

 &lt;p&gt;The behavior of this method matches that of
 {@link #captureBurst(List, android.hardware.camera2.CameraCaptureSession.CaptureCallback, Handler)},
 except that it uses {@link java.util.concurrent.Executor} as an argument
 instead of {@link android.os.Handler}.&lt;/p&gt;
@param {Object {java.util.List}} requests the list of settings for this burst capture
@param {Object {Executor}} executor the executor which will be used for invoking the listener.
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify each time one of the
 requests in the burst has been processed.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException If the requests target no Surfaces, or the requests target
                                  Surfaces not currently configured as outputs; or one of the
                                  requests targets a set of Surfaces that cannot be submitted
                                  simultaneously in a reprocessable capture session; or a
                                  reprocess capture request is submitted in a
                                  non-reprocessable capture session; or one of the reprocess
                                  capture requests was created with a
                                  {@link TotalCaptureResult} from a different session; or one
                                  of the captures targets a Surface in the middle of being
                                  {@link #prepare prepared}; or if the executor is null; or if
                                  the listener is null.
@see #capture
@see #setRepeatingRequest
@see #setRepeatingBurst
@see #abortCaptures
*/
captureBurstRequests : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-setRepeatingRequest'>/**Request endlessly repeating capture of images by this capture session.
</span>
 &lt;p&gt;With this method, the camera device will continually capture images
 using the settings in the provided {@link android.hardware.camera2.CaptureRequest}, at the maximum
 rate possible.&lt;/p&gt;

 &lt;p&gt;Repeating requests are a simple way for an application to maintain a
 preview or other continuous stream of frames, without having to
 continually submit identical requests through {@link #capture}.&lt;/p&gt;

 &lt;p&gt;Repeat requests have lower priority than those submitted
 through {@link #capture} or {@link #captureBurst}, so if
 {@link #capture} is called when a repeating request is active, the
 capture request will be processed before any further repeating
 requests are processed.&lt;p&gt;

 &lt;p&gt;To stop the repeating capture, call {@link #stopRepeating}. Calling
 {@link #abortCaptures} will also clear the request.&lt;/p&gt;

 &lt;p&gt;Calling this method will replace any earlier repeating request or
 burst set up by this method or {@link #setRepeatingBurst}, although any
 in-progress burst will be completed before the new repeat request will be
 used.&lt;/p&gt;

 &lt;p&gt;This method does not support reprocess capture requests because each reprocess
 {@link android.hardware.camera2.CaptureRequest} must be created from the {@link android.hardware.camera2.TotalCaptureResult} that matches
 the input image to be reprocessed. This is either the {@link android.hardware.camera2.TotalCaptureResult} of capture
 that is sent for reprocessing, or one of the {@link android.hardware.camera2.TotalCaptureResult android.hardware.camera2.TotalCaptureResults}
 of a set of captures, when data from the whole set is combined by the application into a
 single reprocess input image. The request must be capturing images from the camera. If a
 reprocess capture request is submitted, this method will throw IllegalArgumentException.&lt;/p&gt;
@param {Object {CaptureRequest}} request the request to repeat indefinitely
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify every time the
 request finishes processing. If null, no metadata will be
 produced for this stream of requests, although image data will
 still be produced.
@param {Object {Handler}} handler the handler on which the listener should be invoked, or
 {@code null} to use the current thread's {@link android.os.Looper
 looper}.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException If the request references no Surfaces or references Surfaces
                                  that are not currently configured as outputs; or the request
                                  is a reprocess capture request; or the capture targets a
                                  Surface in the middle of being {@link #prepare prepared}; or
                                  the handler is null, the listener is not null, and the
                                  calling thread has no looper; or no requests were passed in.
@see #capture
@see #captureBurst
@see #setRepeatingBurst
@see #stopRepeating
@see #abortCaptures
*/
setRepeatingRequest : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-setSingleRepeatingRequest'>/**Request endlessly repeating capture of images by this capture session.
</span>
 &lt;p&gt;The behavior of this method matches that of
 {@link #setRepeatingRequest(CaptureRequest, android.hardware.camera2.CameraCaptureSession.CaptureCallback, Handler)},
 except that it uses {@link java.util.concurrent.Executor} as an argument
 instead of {@link android.os.Handler}.&lt;/p&gt;
@param {Object {CaptureRequest}} request the request to repeat indefinitely
@param {Object {Executor}} executor the executor which will be used for invoking the listener.
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify every time the
 request finishes processing.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException If the request references no Surfaces or references Surfaces
                                  that are not currently configured as outputs; or the request
                                  is a reprocess capture request; or the capture targets a
                                  Surface in the middle of being {@link #prepare prepared}; or
                                  the executor is null; or the listener is null.
@see #capture
@see #captureBurst
@see #setRepeatingBurst
@see #stopRepeating
@see #abortCaptures
*/
setSingleRepeatingRequest : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-setRepeatingBurst'>/**&lt;p&gt;Request endlessly repeating capture of a sequence of images by this
</span> capture session.&lt;/p&gt;

 &lt;p&gt;With this method, the camera device will continually capture images,
 cycling through the settings in the provided list of
 {@link android.hardware.camera2.CaptureRequest android.hardware.camera2.CaptureRequests}, at the maximum rate possible.&lt;/p&gt;

 &lt;p&gt;If a request is submitted through {@link #capture} or
 {@link #captureBurst}, the current repetition of the request list will be
 completed before the higher-priority request is handled. This guarantees
 that the application always receives a complete repeat burst captured in
 minimal time, instead of bursts interleaved with higher-priority
 captures, or incomplete captures.&lt;/p&gt;

 &lt;p&gt;Repeating burst requests are a simple way for an application to
 maintain a preview or other continuous stream of frames where each
 request is different in a predicatable way, without having to continually
 submit requests through {@link #captureBurst}.&lt;/p&gt;

 &lt;p&gt;To stop the repeating capture, call {@link #stopRepeating}. Any
 ongoing burst will still be completed, however. Calling
 {@link #abortCaptures} will also clear the request.&lt;/p&gt;

 &lt;p&gt;Calling this method will replace a previously-set repeating request or
 burst set up by this method or {@link #setRepeatingRequest}, although any
 in-progress burst will be completed before the new repeat burst will be
 used.&lt;/p&gt;

 &lt;p&gt;This method does not support reprocess capture requests because each reprocess
 {@link android.hardware.camera2.CaptureRequest} must be created from the {@link android.hardware.camera2.TotalCaptureResult} that matches
 the input image to be reprocessed. This is either the {@link android.hardware.camera2.TotalCaptureResult} of capture
 that is sent for reprocessing, or one of the {@link android.hardware.camera2.TotalCaptureResult android.hardware.camera2.TotalCaptureResults}
 of a set of captures, when data from the whole set is combined by the application into a
 single reprocess input image. The request must be capturing images from the camera. If a
 reprocess capture request is submitted, this method will throw IllegalArgumentException.&lt;/p&gt;
@param {Object {java.util.List}} requests the list of requests to cycle through indefinitely
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify each time one of the
 requests in the repeating bursts has finished processing. If null, no
 metadata will be produced for this stream of requests, although image
 data will still be produced.
@param {Object {Handler}} handler the handler on which the listener should be invoked, or
 {@code null} to use the current thread's {@link android.os.Looper
 looper}.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces
                                  not currently configured as outputs; or one of the requests
                                  is a reprocess capture request; or one of the captures
                                  targets a Surface in the middle of being
                                  {@link #prepare prepared}; or the handler is null, the
                                  listener is not null, and the calling thread has no looper;
                                  or no requests were passed in.
@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #stopRepeating
@see #abortCaptures
*/
setRepeatingBurst : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-setRepeatingBurstRequests'>/**&lt;p&gt;Request endlessly repeating capture of a sequence of images by this
</span> capture session.&lt;/p&gt;

 &lt;p&gt;The behavior of this method matches that of
 {@link #setRepeatingBurst(List, android.hardware.camera2.CameraCaptureSession.CaptureCallback, Handler)},
 except that it uses {@link java.util.concurrent.Executor} as an argument
 instead of {@link android.os.Handler}.&lt;/p&gt;
@param {Object {java.util.List}} requests the list of requests to cycle through indefinitely
@param {Object {Executor}} executor the executor which will be used for invoking the listener.
@param {Object {CameraCaptureSession.CaptureCallback}} listener The callback object to notify each time one of the
 requests in the repeating bursts has finished processing.
@return {Number} int A unique capture sequence ID used by
             {@link CaptureCallback#onCaptureSequenceCompleted}.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces
                                  not currently configured as outputs; or one of the requests
                                  is a reprocess capture request; or one of the captures
                                  targets a Surface in the middle of being
                                  {@link #prepare prepared}; or the executor is null; or the
                                  listener is null.
@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #stopRepeating
@see #abortCaptures
*/
setRepeatingBurstRequests : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-stopRepeating'>/**&lt;p&gt;Cancel any ongoing repeating capture set by either
</span> {@link #setRepeatingRequest setRepeatingRequest} or
 {@link #setRepeatingBurst}. Has no effect on requests submitted through
 {@link #capture capture} or {@link #captureBurst captureBurst}.&lt;/p&gt;

 &lt;p&gt;Any currently in-flight captures will still complete, as will any burst that is
 mid-capture. To ensure that the device has finished processing all of its capture requests
 and is in ready state, wait for the {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onReady} callback after
 calling this method.&lt;/p&gt;
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@see #setRepeatingRequest
@see #setRepeatingBurst
@see StateCallback#onReady
*/
stopRepeating : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-abortCaptures'>/**Discard all captures currently pending and in-progress as fast as possible.
</span>
 &lt;p&gt;The camera device will discard all of its current work as fast as possible. Some in-flight
 captures may complete successfully and call {@link android.hardware.camera2.CameraCaptureSession.CaptureCallback#onCaptureCompleted}, while
 others will trigger their {@link android.hardware.camera2.CameraCaptureSession.CaptureCallback#onCaptureFailed} callbacks. If a repeating
 request or a repeating burst is set, it will be cleared.&lt;/p&gt;

 &lt;p&gt;This method is the fastest way to switch the camera device to a new session with
 {@link android.hardware.camera2.CameraDevice#createCaptureSession} or
 {@link android.hardware.camera2.CameraDevice#createReprocessableCaptureSession}, at the cost of discarding in-progress
 work. It must be called before the new session is created. Once all pending requests are
 either completed or thrown away, the {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onReady} callback will be called,
 if the session has not been closed. Otherwise, the {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onClosed}
 callback will be fired when a new session is created by the camera device.&lt;/p&gt;

 &lt;p&gt;Cancelling will introduce at least a brief pause in the stream of data from the camera
 device, since once the camera device is emptied, the first new request has to make it through
 the entire camera pipeline before new output buffers are produced.&lt;/p&gt;

 &lt;p&gt;This means that using {@code abortCaptures()} to simply remove pending requests is not
 recommended; it's best used for quickly switching output configurations, or for cancelling
 long in-progress requests (such as a multi-second capture).&lt;/p&gt;
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
@see #setRepeatingRequest
@see #setRepeatingBurst
@see CameraDevice#createCaptureSession
@see CameraDevice#createReprocessableCaptureSession
*/
abortCaptures : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-isReprocessable'>/**Return if the application can submit reprocess capture requests with this camera capture
</span> session.
@return {Boolean} {@code true} if the application can submit reprocess capture requests with this
         camera capture session. {@code false} otherwise.
@see CameraDevice#createReprocessableCaptureSession
*/
isReprocessable : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-getInputSurface'>/**Get the input Surface associated with a reprocessable capture session.
</span>
 &lt;p&gt;Each reprocessable capture session has an input {@link Surface} where the reprocess
 capture requests get the input images from, rather than the camera device. The application
 can create a {@link android.media.ImageWriter ImageWriter} with this input {@link Surface}
 and use it to provide input images for reprocess capture requests. When the reprocessable
 capture session is closed, the input {@link Surface} is abandoned and becomes invalid.&lt;/p&gt;
@return {Object {android.view.Surface}} The {@link Surface} where reprocessing capture requests get the input images from. If
         this is not a reprocess capture session, {@code null} will be returned.
@see CameraDevice#createReprocessableCaptureSession
@see android.media.ImageWriter
@see android.media.ImageReader
*/
getInputSurface : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-updateOutputConfiguration'>/**Update {@link OutputConfiguration} after configuration finalization see
</span> {@link #finalizeOutputConfigurations}.

 &lt;p&gt;Any {@link OutputConfiguration} that has been modified via calls to
 {@link OutputConfiguration#addSurface} or {@link OutputConfiguration#removeSurface} must be
 updated. After the update call returns without throwing exceptions any newly added surfaces
 can be referenced in subsequent capture requests.&lt;/p&gt;

 &lt;p&gt;Surfaces that get removed must not be part of any active repeating or single/burst
 request or have any pending results. Consider updating any repeating requests first via
 {@link #setRepeatingRequest} or {@link #setRepeatingBurst} and then wait for the last frame
 number when the sequence completes {@link android.hardware.camera2.CameraCaptureSession.CaptureCallback#onCaptureSequenceCompleted}
 before calling updateOutputConfiguration to remove a previously active Surface.&lt;/p&gt;

 &lt;p&gt;Surfaces that get added must not be part of any other registered
 {@link OutputConfiguration}.&lt;/p&gt;
@param {Object {OutputConfiguration}} config Modified output configuration.
@throws CameraAccessException if the camera device is no longer connected or has
                               encountered a fatal error.
@throws IllegalArgumentException if an attempt was made to add a {@link Surface} already
                               in use by another buffer-producing API, such as MediaCodec or
                               a different camera device or {@link OutputConfiguration}; or
                               new surfaces are not compatible (see
                               {@link OutputConfiguration#enableSurfaceSharing}); or a
                               {@link Surface} that was removed from the modified
                               {@link OutputConfiguration} still has pending requests.
@throws IllegalStateException if this session is no longer active, either because the session
                               was explicitly closed, a new session has been created
                               or the camera device has been closed.
*/
updateOutputConfiguration : function(  ) {},

<span id='android-hardware-camera2-CameraCaptureSession-method-close'>/**Close this capture session asynchronously.
</span>
 &lt;p&gt;Closing a session frees up the target output Surfaces of the session for reuse with either
 a new session, or to other APIs that can draw to Surfaces.&lt;/p&gt;

 &lt;p&gt;Note that creating a new capture session with {@link android.hardware.camera2.CameraDevice#createCaptureSession}
 will close any existing capture session automatically, and call the older session listener's
 {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onClosed} callback. Using {@link android.hardware.camera2.CameraDevice#createCaptureSession}
 directly without closing is the recommended approach for quickly switching to a new session,
 since unchanged target outputs can be reused more efficiently.&lt;/p&gt;

 &lt;p&gt;Once a session is closed, all methods on it will throw an IllegalStateException, and any
 repeating requests or bursts are stopped (as if {@link #stopRepeating}() was called).
 However, any in-progress capture requests submitted to the session will be completed as
 normal; once all captures have completed and the session has been torn down,
 {@link android.hardware.camera2.CameraCaptureSession.StateCallback#onClosed} will be called.&lt;/p&gt;

 &lt;p&gt;Closing a session is idempotent; closing more than once has no effect.&lt;/p&gt;
*/
close : function(  ) {},


};</pre>
</body>
</html>
