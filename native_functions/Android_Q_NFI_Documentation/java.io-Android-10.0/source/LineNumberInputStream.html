<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-io-LineNumberInputStream'>/**@class java.io.LineNumberInputStream
</span>@extends java.io.FilterInputStream

 This class is an input stream filter that provides the added
 functionality of keeping track of the current line number.
 &lt;p&gt;
 A line is a sequence of bytes ending with a carriage return
 character ({@code '\r'}), a newline character
 ({@code '\n'}), or a carriage return character followed
 immediately by a linefeed character. In all three cases, the line
 terminating character(s) are returned as a single newline character.
 &lt;p&gt;
 The line number begins at {@code 0}, and is incremented by
 {@code 1} when a {@code read} returns a newline character.

 @author     Arthur van Hoff
 @see        java.io.LineNumberReader
 @since      JDK1.0
 @deprecated This class incorrectly assumes that bytes adequately represent
             characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
             character streams is via the new character-stream classes, which
             include a class for counting line numbers.
*/
var LineNumberInputStream = {

<span id='java-io-LineNumberInputStream-method-read'>/**Reads the next byte of data from this input stream. The value
</span> byte is returned as an {@code int} in the range
 {@code 0} to {@code 255}. If no byte is available
 because the end of the stream has been reached, the value
 {@code -1} is returned. This method blocks until input data
 is available, the end of the stream is detected, or an exception
 is thrown.
 &lt;p&gt;
 The {@code read} method of
 {@code LineNumberInputStream} calls the {@code read}
 method of the underlying input stream. It checks for carriage
 returns and newline characters in the input, and modifies the
 current line number as appropriate. A carriage-return character or
 a carriage return followed by a newline character are both
 converted into a single newline character.
@return {Number} the next byte of data, or {@code -1} if the end of this
             stream is reached.
@exception IOException  if an I/O error occurs.
@see java.io.FilterInputStream#in
@see java.io.LineNumberInputStream#getLineNumber()
*/
read : function(  ) {},

<span id='java-io-LineNumberInputStream-method-read'>/**Reads up to {@code len} bytes of data from this input stream
</span> into an array of bytes. This method blocks until some input is available.
 &lt;p&gt;
 The {@code read} method of
 {@code LineNumberInputStream} repeatedly calls the
 {@code read} method of zero arguments to fill in the byte array.
@param {Object {byte[]}} b     the buffer into which the data is read.
@param {Number} off   the start offset of the data.
@param {Number} len   the maximum number of bytes read.
@return {Number} the total number of bytes read into the buffer, or
             {@code -1} if there is no more data because the end of
             this stream has been reached.
@exception IOException  if an I/O error occurs.
@see java.io.LineNumberInputStream#read()
*/
read : function(  ) {},

<span id='java-io-LineNumberInputStream-method-skip'>/**Skips over and discards {@code n} bytes of data from this
</span> input stream. The {@code skip} method may, for a variety of
 reasons, end up skipping over some smaller number of bytes,
 possibly {@code 0}. The actual number of bytes skipped is
 returned.  If {@code n} is negative, no bytes are skipped.
 &lt;p&gt;
 The {@code skip} method of {@code LineNumberInputStream} creates
 a byte array and then repeatedly reads into it until
 {@code n} bytes have been read or the end of the stream has
 been reached.
@param {Number} n   the number of bytes to be skipped.
@return {Number} the actual number of bytes skipped.
@exception IOException  if an I/O error occurs.
@see java.io.FilterInputStream#in
*/
skip : function(  ) {},

<span id='java-io-LineNumberInputStream-method-setLineNumber'>/**Sets the line number to the specified argument.
</span>@param {Number} lineNumber   the new line number.
@see #getLineNumber
*/
setLineNumber : function(  ) {},

<span id='java-io-LineNumberInputStream-method-getLineNumber'>/**Returns the current line number.
</span>@return {Number} the current line number.
@see #setLineNumber
*/
getLineNumber : function(  ) {},

<span id='java-io-LineNumberInputStream-method-available'>/**Returns the number of bytes that can be read from this input
</span> stream without blocking.
 &lt;p&gt;
 Note that if the underlying input stream is able to supply
 &lt;i&gt;k&lt;/i&gt; input characters without blocking, the
 {@code LineNumberInputStream} can guarantee only to provide
 &lt;i&gt;k&lt;/i&gt;/2 characters without blocking, because the
 &lt;i&gt;k&lt;/i&gt; characters from the underlying input stream might
 consist of &lt;i&gt;k&lt;/i&gt;/2 pairs of {@code '\r'} and
 {@code '\n'}, which are converted to just
 &lt;i&gt;k&lt;/i&gt;/2 {@code '\n'} characters.
@return {Number} the number of bytes that can be read from this input stream
             without blocking.
@exception IOException  if an I/O error occurs.
@see java.io.FilterInputStream#in
*/
available : function(  ) {},

<span id='java-io-LineNumberInputStream-method-mark'>/**Marks the current position in this input stream. A subsequent
</span> call to the {@code reset} method repositions this stream at
 the last marked position so that subsequent reads re-read the same bytes.
 &lt;p&gt;
 The {@code mark} method of
 {@code LineNumberInputStream} remembers the current line
 number in a private variable, and then calls the {@code mark}
 method of the underlying input stream.
@param {Number} readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.
@see java.io.FilterInputStream#in
@see java.io.LineNumberInputStream#reset()
*/
mark : function(  ) {},

<span id='java-io-LineNumberInputStream-method-reset'>/**Repositions this stream to the position at the time the
</span> {@code mark} method was last called on this input stream.
 &lt;p&gt;
 The {@code reset} method of
 {@code LineNumberInputStream} resets the line number to be
 the line number at the time the {@code mark} method was
 called, and then calls the {@code reset} method of the
 underlying input stream.
 &lt;p&gt;
 Stream marks are intended to be used in
 situations where you need to read ahead a little to see what's in
 the stream. Often this is most easily done by invoking some
 general parser. If the stream is of the type handled by the
 parser, it just chugs along happily. If the stream is not of
 that type, the parser should toss an exception when it fails,
 which, if it happens within readlimit bytes, allows the outer
 code to reset the stream and try another parser.
@exception IOException  if an I/O error occurs.
@see java.io.FilterInputStream#in
@see java.io.LineNumberInputStream#mark(int)
*/
reset : function(  ) {},


};</pre>
</body>
</html>
