<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='com-android-uiautomator-core-UiWatcher'>/**@class com.android.uiautomator.core.UiWatcher
</span> See {@link UiDevice#registerWatcher(String, com.android.uiautomator.core.UiWatcher)} on how to register a
 a condition watcher to be called by the automation library. The automation library will
 invoke checkForCondition() only when a regular API call is in retry mode because it is unable
 to locate its selector yet. Only during this time, the watchers are invoked to check if there is
 something else unexpected on the screen.
 @since API Level 16
 @deprecated New tests should be written using UI Automator 2.0 which is available as part of the
 Android Testing Support Library.
*/
var UiWatcher = {

<span id='com-android-uiautomator-core-UiWatcher-method-checkForCondition'>/**Custom handler that is automatically called when the testing framework is unable to
</span> find a match using the {@link com.android.uiautomator.core.UiSelector}

 When the framework is in the process of matching a {@link com.android.uiautomator.core.UiSelector} and it
 is unable to match any widget based on the specified criteria in the selector,
 the framework will perform retries for a predetermined time, waiting for the display
 to update and show the desired widget. While the framework is in this state, it will call
 registered watchers' checkForCondition(). This gives the registered watchers a chance
 to take a look at the display and see if there is a recognized condition that can be
 handled and in doing so allowing the current test to continue.

 An example usage would be to look for dialogs popped due to other background
 processes requesting user attention and have nothing to do with the application
 currently under test.
@return {Boolean} true to indicate a matched condition or false for nothing was matched
@since API Level 16
*/
checkForCondition : function(  ) {},


};</pre>
</body>
</html>
