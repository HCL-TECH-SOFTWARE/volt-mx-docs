<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-widget-Chronometer'>/**@class android.widget.Chronometer
</span>@extends android.widget.TextView

 Class that implements a simple timer.
 &lt;p&gt;
 You can give it a start time in the {@link SystemClock#elapsedRealtime} timebase,
 and it counts up from that, or if you don't give it a base time, it will use the
 time at which you call {@link #start}.

 &lt;p&gt;The timer can also count downward towards the base time by
 setting {@link #setCountDown}(boolean) to true.

  &lt;p&gt;By default it will display the current
 timer value in the form &quot;MM:SS&quot; or &quot;H:MM:SS&quot;, or you can use {@link #setFormat}
 to format the timer value into an arbitrary string.

 @attr ref android.R.styleable#Chronometer_format
 @attr ref android.R.styleable#Chronometer_countDown
*/
var Chronometer = {

<span id='android-widget-Chronometer-method-setCountDown'>/**Set this view to count down to the base instead of counting up from it.
</span>@param {Boolean} countDown whether this view should count down
@see #setBase(long)
*/
setCountDown : function(  ) {},

<span id='android-widget-Chronometer-method-isCountDown'>/**
</span>@return {Boolean} whether this view counts down
@see #setCountDown(boolean)
*/
isCountDown : function(  ) {},

<span id='android-widget-Chronometer-method-isTheFinalCountDown'>/**
</span>@return {Boolean} whether this is the final countdown
*/
isTheFinalCountDown : function(  ) {},

<span id='android-widget-Chronometer-method-setBase'>/**Set the time that the count-up timer is in reference to.
</span>@param {Number} base Use the {@link SystemClock#elapsedRealtime} time base.
*/
setBase : function(  ) {},

<span id='android-widget-Chronometer-method-getBase'>/**Return the base time as set through {@link #setBase}.
</span>*/
getBase : function(  ) {},

<span id='android-widget-Chronometer-method-setFormat'>/**Sets the format string used for display.  The Chronometer will display
</span> this string, with the first &quot;%s&quot; replaced by the current timer value in
 &quot;MM:SS&quot; or &quot;H:MM:SS&quot; form.

 If the format string is null, or if you never call setFormat(), the
 Chronometer will simply display the timer value in &quot;MM:SS&quot; or &quot;H:MM:SS&quot;
 form.
@param {String} format the format string.
*/
setFormat : function(  ) {},

<span id='android-widget-Chronometer-method-getFormat'>/**Returns the current format string as set through {@link #setFormat}.
</span>*/
getFormat : function(  ) {},

<span id='android-widget-Chronometer-method-setOnChronometerTickListener'>/**Sets the listener to be called when the chronometer changes.
</span>@param {Object {Chronometer.OnChronometerTickListener}} listener The listener.
*/
setOnChronometerTickListener : function(  ) {},

<span id='android-widget-Chronometer-method-getOnChronometerTickListener'>/**
</span>@return {Object {android.widget.Chronometer.OnChronometerTickListener}} The listener (may be null) that is listening for chronometer change
         events.
*/
getOnChronometerTickListener : function(  ) {},

<span id='android-widget-Chronometer-method-start'>/**Start counting up.  This does not affect the base as set from {@link #setBase}, just
</span> the view display.

 Chronometer works by regularly scheduling messages to the handler, even when the
 Widget is not visible.  To make sure resource leaks do not occur, the user should
 make sure that each start() call has a reciprocal call to {@link #stop}.
*/
start : function(  ) {},

<span id='android-widget-Chronometer-method-stop'>/**Stop counting up.  This does not affect the base as set from {@link #setBase}, just
</span> the view display.

 This stops the messages to the handler, effectively releasing resources that would
 be held as the chronometer is running, via {@link #start}.
*/
stop : function(  ) {},

<span id='android-widget-Chronometer-method-setStarted'>/**The same as calling {@link #start} or {@link #stop}.
</span>@hide pending API council approval
*/
setStarted : function(  ) {},

<span id='android-widget-Chronometer-method-getContentDescription'>/**
</span>*/
getContentDescription : function(  ) {},

<span id='android-widget-Chronometer-method-getAccessibilityClassName'>/**
</span>*/
getAccessibilityClassName : function(  ) {},


};</pre>
</body>
</html>
