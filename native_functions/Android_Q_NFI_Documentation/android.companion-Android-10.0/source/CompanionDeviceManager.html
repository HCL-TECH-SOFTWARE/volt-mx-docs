<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-companion-CompanionDeviceManager'>/**@class android.companion.CompanionDeviceManager
</span>@extends java.lang.Object

 System level service for managing companion devices

 &lt;p&gt;To obtain an instance call {@link Context#getSystemService}({@link Context#COMPANION_DEVICE_SERVICE}) Then, call {@link #associate(AssociationRequest,
 android.companion.CompanionDeviceManager.Callback, Handler)} to initiate the flow of associating current package with a
 device selected by user.&lt;/p&gt;

 @see AssociationRequest
*/
var CompanionDeviceManager = {

<span id='android-companion-CompanionDeviceManager-property-EXTRA_DEVICE'>/** A device, returned in the activity result of the {@link IntentSender} received in
</span> {@link android.companion.CompanionDeviceManager.Callback#onDeviceFound}
*/
EXTRA_DEVICE : &quot;android.companion.extra.DEVICE&quot;,
<span id='android-companion-CompanionDeviceManager-property-COMPANION_DEVICE_DISCOVERY_PACKAGE_NAME'>/** The package name of the companion device discovery component.
</span>
 @hide
*/
COMPANION_DEVICE_DISCOVERY_PACKAGE_NAME : &quot;com.android.companiondevicemanager&quot;,
<span id='android-companion-CompanionDeviceManager-method-associate'>/**Associate this app with a companion device, selected by user
</span>
 &lt;p&gt;Once at least one appropriate device is found, {@code callback} will be called with a
 {@link PendingIntent} that can be used to show the list of available devices for the user
 to select.
 It should be started for result (i.e. using
 {@link android.app.Activity#startIntentSenderForResult}), as the resulting
 {@link android.content.Intent} will contain extra {@link #EXTRA_DEVICE}, with the selected
 device. (e.g. {@link android.bluetooth.BluetoothDevice})&lt;/p&gt;

 &lt;p&gt;If your app needs to be excluded from battery optimizations (run in the background)
 or to have unrestricted data access (use data in the background) you can declare that
 you use the {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and {@link android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} respectively. Note that these
 special capabilities have a negative effect on the device's battery and user's data
 usage, therefore you should requested them when absolutely necessary.&lt;/p&gt;

 &lt;p&gt;You can call {@link #getAssociations} to get the list of currently associated
 devices, and {@link #disassociate} to remove an association. Consider doing so when the
 association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 from special privileges that the association provides&lt;/p&gt;

 &lt;p&gt;Calling this API requires a uses-feature
 {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest&lt;/p&gt;
@param {Object {AssociationRequest}} request specific details about this request
@param {Object {CompanionDeviceManager.Callback}} callback will be called once there's at least one device found for user to choose from
@param {Object {Handler}} handler A handler to control which thread the callback will be delivered on, or null,
                to deliver it on main thread
@see AssociationRequest
*/
associate : function(  ) {},

<span id='android-companion-CompanionDeviceManager-method-getAssociations'>/**&lt;p&gt;Calling this API requires a uses-feature
</span> {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest&lt;/p&gt;
@return {Object {java.util.List}} a list of MAC addresses of devices that have been previously associated with the
 current app. You can use these with {@link #disassociate}
*/
getAssociations : function(  ) {},

<span id='android-companion-CompanionDeviceManager-method-disassociate'>/**Remove the association between this app and the device with the given mac address.
</span>
 &lt;p&gt;Any privileges provided via being associated with a given device will be revoked&lt;/p&gt;

 &lt;p&gt;Consider doing so when the
 association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 from special privileges that the association provides&lt;/p&gt;

 &lt;p&gt;Calling this API requires a uses-feature
 {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest&lt;/p&gt;
@param {String} deviceMacAddress the MAC address of device to disassociate from this app
*/
disassociate : function(  ) {},

<span id='android-companion-CompanionDeviceManager-method-requestNotificationAccess'>/**Request notification access for the given component.
</span>
 The given component must follow the protocol specified in {@link NotificationListenerService}

 Only components from the same {@link ComponentName#getPackageName package} as the calling app
 are allowed.

 Your app must have an association with a device before calling this API

 &lt;p&gt;Calling this API requires a uses-feature
 {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest&lt;/p&gt;
*/
requestNotificationAccess : function(  ) {},

<span id='android-companion-CompanionDeviceManager-method-hasNotificationAccess'>/**Check whether the given component can access the notifications via a
</span> {@link NotificationListenerService}

 Your app must have an association with a device before calling this API

 &lt;p&gt;Calling this API requires a uses-feature
 {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest&lt;/p&gt;
@param {Object {ComponentName}} component the name of the component
@return {Boolean} whether the given component has the notification listener permission
*/
hasNotificationAccess : function(  ) {},


};</pre>
</body>
</html>
