<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='com-android-server-pm-dex-DexoptUtils'>/**@class com.android.server.pm.dex.DexoptUtils
</span>@extends java.lang.Object

*/
var DexoptUtils = {

<span id='com-android-server-pm-dex-DexoptUtils-method-getClassLoaderContexts'>/**Creates the class loader context dependencies for each of the application code paths.
</span> The returned array contains the class loader contexts that needs to be passed to dexopt in
 order to ensure correct optimizations. &quot;Code&quot; paths with no actual code, as specified by
 {@param pathsWithCode}, are ignored and will have null as their context in the returned array
 (configuration splits are an example of paths without code).

 A class loader context describes how the class loader chain should be built by dex2oat
 in order to ensure that classes are resolved during compilation as they would be resolved
 at runtime. The context will be encoded in the compiled code. If at runtime the dex file is
 loaded in a different context (with a different set of class loaders or a different
 classpath), the compiled code will be rejected.

 Note that the class loader context only includes dependencies and not the code path itself.
 The contexts are created based on the application split dependency list and
 the provided shared libraries.

 All the code paths encoded in the context will be relative to the base directory. This
 enables stage compilation where compiler artifacts may be moved around.

 The result is indexed as follows:
   - index 0 contains the context for the base apk
   - index 1 to n contain the context for the splits in the order determined by
     {@code info.getSplitCodePaths()}

 IMPORTANT: keep this logic in sync with the loading code in {@link android.app.LoadedApk}
 and pay attention to the way the classpath is created for the non isolated mode in:
 {@link android.app.LoadedApk#makePaths(
 android.app.ActivityThread, boolean, ApplicationInfo, List, List)}.
*/
getClassLoaderContexts : function(  ) {},

<span id='com-android-server-pm-dex-DexoptUtils-method-getClassLoaderContext'>/**Creates the class loader context for the given shared library.
</span>*/
getClassLoaderContext : function(  ) {},


};</pre>
</body>
</html>
