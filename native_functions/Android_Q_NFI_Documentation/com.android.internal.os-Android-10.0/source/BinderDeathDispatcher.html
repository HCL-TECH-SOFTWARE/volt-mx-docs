<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='com-android-internal-os-BinderDeathDispatcher'>/**@class com.android.internal.os.BinderDeathDispatcher
</span>@extends java.lang.Object

 Multiplexes multiple binder death recipients on the same binder objects, so that at the native
 level, we only need to keep track of one death recipient reference. This will help reduce the
 number of JNI strong references.

 test with: atest FrameworksCoreTests:BinderDeathDispatcherTest
*/
var BinderDeathDispatcher = {

<span id='com-android-internal-os-BinderDeathDispatcher-method-linkToDeath'>/**Add a {@code recipient} to the death recipient list on {@code target}.
</span>@return {Number} # of recipients in the recipient list, including {@code recipient}. Or, -1
 if {@code target} is already dead, in which case recipient's
 {@link DeathRecipient#binderDied} won't be called.
*/
linkToDeath : function(  ) {},

<span id='com-android-internal-os-BinderDeathDispatcher-method-unlinkToDeath'>/**
</span>*/
unlinkToDeath : function(  ) {},

<span id='com-android-internal-os-BinderDeathDispatcher-method-dump'>/**
</span>*/
dump : function(  ) {},

<span id='com-android-internal-os-BinderDeathDispatcher-method-getTargetsForTest'>/**
</span>*/
getTargetsForTest : function(  ) {},


};</pre>
</body>
</html>
