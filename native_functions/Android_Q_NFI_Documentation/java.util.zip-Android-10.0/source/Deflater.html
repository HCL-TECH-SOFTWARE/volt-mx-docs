<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-zip-Deflater'>/**@class java.util.zip.Deflater
</span>@extends java.lang.Object

 This class provides support for general purpose compression using the
 popular ZLIB compression library. The ZLIB compression library was
 initially developed as part of the PNG graphics standard and is not
 protected by patents. It is fully described in the specifications at
 the &lt;a href=&quot;package-summary.html#package_description&quot;&gt;java.util.zip
 package description&lt;/a&gt;.

 &lt;p&gt;The following code fragment demonstrates a trivial compression
 and decompression of a string using &lt;tt&gt;Deflater&lt;/tt&gt; and
 &lt;tt&gt;Inflater&lt;/tt&gt;.

 &lt;blockquote&gt;&lt;pre&gt;
 try {
     // Encode a String into bytes
     String inputString = &quot;blahblahblah&quot;;
     byte[] input = inputString.getBytes(&quot;UTF-8&quot;);

     // Compress the bytes
     byte[] output = new byte[100];
     Deflater compresser = new Deflater();
     compresser.setInput(input);
     compresser.finish();
     int compressedDataLength = compresser.deflate(output);
     compresser.end();

     // Decompress the bytes
     Inflater decompresser = new Inflater();
     decompresser.setInput(output, 0, compressedDataLength);
     byte[] result = new byte[100];
     int resultLength = decompresser.inflate(result);
     decompresser.end();

     // Decode the bytes into a String
     String outputString = new String(result, 0, resultLength, &quot;UTF-8&quot;);
 } catch(java.io.UnsupportedEncodingException ex) {
     // handle
 } catch (java.util.zip.DataFormatException ex) {
     // handle
 }
 &lt;/pre&gt;&lt;/blockquote&gt;

 @see         Inflater
 @author      David Connelly
*/
var Deflater = {

<span id='java-util-zip-Deflater-property-DEFLATED'>/** Compression method for the deflate algorithm (the only one currently
</span> supported).
*/
DEFLATED : &quot;8&quot;,
<span id='java-util-zip-Deflater-property-NO_COMPRESSION'>/** Compression level for no compression.
</span>*/
NO_COMPRESSION : &quot;0&quot;,
<span id='java-util-zip-Deflater-property-BEST_SPEED'>/** Compression level for fastest compression.
</span>*/
BEST_SPEED : &quot;1&quot;,
<span id='java-util-zip-Deflater-property-BEST_COMPRESSION'>/** Compression level for best compression.
</span>*/
BEST_COMPRESSION : &quot;9&quot;,
<span id='java-util-zip-Deflater-property-DEFAULT_COMPRESSION'>/** Default compression level.
</span>*/
DEFAULT_COMPRESSION : &quot;-1&quot;,
<span id='java-util-zip-Deflater-property-FILTERED'>/** Compression strategy best used for data consisting mostly of small
</span> values with a somewhat random distribution. Forces more Huffman coding
 and less string matching.
*/
FILTERED : &quot;1&quot;,
<span id='java-util-zip-Deflater-property-HUFFMAN_ONLY'>/** Compression strategy for Huffman coding only.
</span>*/
HUFFMAN_ONLY : &quot;2&quot;,
<span id='java-util-zip-Deflater-property-DEFAULT_STRATEGY'>/** Default compression strategy.
</span>*/
DEFAULT_STRATEGY : &quot;0&quot;,
<span id='java-util-zip-Deflater-property-NO_FLUSH'>/** Compression flush mode used to achieve best compression result.
</span>
 @see Deflater#deflate(byte[], int, int, int)
 @since 1.7
*/
NO_FLUSH : &quot;0&quot;,
<span id='java-util-zip-Deflater-property-SYNC_FLUSH'>/** Compression flush mode used to flush out all pending output; may
</span> degrade compression for some compression algorithms.

 @see Deflater#deflate(byte[], int, int, int)
 @since 1.7
*/
SYNC_FLUSH : &quot;2&quot;,
<span id='java-util-zip-Deflater-property-FULL_FLUSH'>/** Compression flush mode used to flush out all pending output and
</span> reset the deflater. Using this mode too often can seriously degrade
 compression.

 @see Deflater#deflate(byte[], int, int, int)
 @since 1.7
*/
FULL_FLUSH : &quot;3&quot;,
<span id='java-util-zip-Deflater-method-setInput'>/**Sets input data for compression. This should be called whenever
</span> needsInput() returns true indicating that more input data is required.
@param {Object {byte[]}} b the input data bytes
@param {Number} off the start offset of the data
@param {Number} len the length of the data
@see Deflater#needsInput
*/
setInput : function(  ) {},

<span id='java-util-zip-Deflater-method-setInput'>/**Sets input data for compression. This should be called whenever
</span> needsInput() returns true indicating that more input data is required.
@param {Object {byte[]}} b the input data bytes
@see Deflater#needsInput
*/
setInput : function(  ) {},

<span id='java-util-zip-Deflater-method-setDictionary'>/**Sets preset dictionary for compression. A preset dictionary is used
</span> when the history buffer can be predetermined. When the data is later
 uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
 in order to get the Adler-32 value of the dictionary required for
 decompression.
@param {Object {byte[]}} b the dictionary data bytes
@param {Number} off the start offset of the data
@param {Number} len the length of the data
@see Inflater#inflate
@see Inflater#getAdler
*/
setDictionary : function(  ) {},

<span id='java-util-zip-Deflater-method-setDictionary'>/**Sets preset dictionary for compression. A preset dictionary is used
</span> when the history buffer can be predetermined. When the data is later
 uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
 in order to get the Adler-32 value of the dictionary required for
 decompression.
@param {Object {byte[]}} b the dictionary data bytes
@see Inflater#inflate
@see Inflater#getAdler
*/
setDictionary : function(  ) {},

<span id='java-util-zip-Deflater-method-setStrategy'>/**Sets the compression strategy to the specified value.
</span>
 &lt;p&gt; If the compression strategy is changed, the next invocation
 of {@code deflate} will compress the input available so far with
 the old strategy (and may be flushed); the new strategy will take
 effect only after that invocation.
@param {Number} strategy the new compression strategy
@exception IllegalArgumentException if the compression strategy is
                                     invalid
*/
setStrategy : function(  ) {},

<span id='java-util-zip-Deflater-method-setLevel'>/**Sets the compression level to the specified value.
</span>
 &lt;p&gt; If the compression level is changed, the next invocation
 of {@code deflate} will compress the input available so far
 with the old level (and may be flushed); the new level will
 take effect only after that invocation.
@param {Number} level the new compression level (0-9)
@exception IllegalArgumentException if the compression level is invalid
*/
setLevel : function(  ) {},

<span id='java-util-zip-Deflater-method-needsInput'>/**Returns true if the input data buffer is empty and setInput()
</span> should be called in order to provide more input.
@return {Boolean} true if the input data buffer is empty and setInput()
 should be called in order to provide more input
*/
needsInput : function(  ) {},

<span id='java-util-zip-Deflater-method-finish'>/**When called, indicates that compression should end with the current
</span> contents of the input buffer.
*/
finish : function(  ) {},

<span id='java-util-zip-Deflater-method-finished'>/**Returns true if the end of the compressed data output stream has
</span> been reached.
@return {Boolean} true if the end of the compressed data output stream has
 been reached
*/
finished : function(  ) {},

<span id='java-util-zip-Deflater-method-deflate'>/**Compresses the input data and fills specified buffer with compressed
</span> data. Returns actual number of bytes of compressed data. A return value
 of 0 indicates that {@link #needsInput() needsInput} should be called
 in order to determine if more input data is required.

 &lt;p&gt;This method uses {@link #NO_FLUSH} as its compression flush mode.
 An invocation of this method of the form {@code deflater.deflate(b, off, len)}
 yields the same result as the invocation of
 {@code deflater.deflate(b, off, len, Deflater.NO_FLUSH)}.
@param {Object {byte[]}} b the buffer for the compressed data
@param {Number} off the start offset of the data
@param {Number} len the maximum number of bytes of compressed data
@return {Number} the actual number of bytes of compressed data written to the
         output buffer
*/
deflate : function(  ) {},

<span id='java-util-zip-Deflater-method-deflate'>/**Compresses the input data and fills specified buffer with compressed
</span> data. Returns actual number of bytes of compressed data. A return value
 of 0 indicates that {@link #needsInput() needsInput} should be called
 in order to determine if more input data is required.

 &lt;p&gt;This method uses {@link #NO_FLUSH} as its compression flush mode.
 An invocation of this method of the form {@code deflater.deflate(b)}
 yields the same result as the invocation of
 {@code deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH)}.
@param {Object {byte[]}} b the buffer for the compressed data
@return {Number} the actual number of bytes of compressed data written to the
         output buffer
*/
deflate : function(  ) {},

<span id='java-util-zip-Deflater-method-deflate'>/**Compresses the input data and fills the specified buffer with compressed
</span> data. Returns actual number of bytes of data compressed.

 &lt;p&gt;Compression flush mode is one of the following three modes:

 &lt;ul&gt;
 &lt;li&gt;{@link #NO_FLUSH}: allows the deflater to decide how much data
 to accumulate, before producing output, in order to achieve the best
 compression (should be used in normal use scenario). A return value
 of 0 in this flush mode indicates that {@link #needsInput}() should
 be called in order to determine if more input data is required.

 &lt;li&gt;{@link #SYNC_FLUSH}: all pending output in the deflater is flushed,
 to the specified output buffer, so that an inflater that works on
 compressed data can get all input data available so far (In particular
 the {@link #needsInput}() returns {@code true} after this invocation
 if enough output space is provided). Flushing with {@link #SYNC_FLUSH}
 may degrade compression for some compression algorithms and so it
 should be used only when necessary.

 &lt;li&gt;{@link #FULL_FLUSH}: all pending output is flushed out as with
 {@link #SYNC_FLUSH}. The compression state is reset so that the inflater
 that works on the compressed output data can restart from this point
 if previous compressed data has been damaged or if random access is
 desired. Using {@link #FULL_FLUSH} too often can seriously degrade
 compression.
 &lt;/ul&gt;

 &lt;p&gt;In the case of {@link #FULL_FLUSH} or {@link #SYNC_FLUSH}, if
 the return value is {@code len}, the space available in output
 buffer {@code b}, this method should be invoked again with the same
 {@code flush} parameter and more output space.
@param {Object {byte[]}} b the buffer for the compressed data
@param {Number} off the start offset of the data
@param {Number} len the maximum number of bytes of compressed data
@param {Number} flush the compression flush mode
@return {Number} the actual number of bytes of compressed data written to
         the output buffer
@throws IllegalArgumentException if the flush mode is invalid
@since 1.7
*/
deflate : function(  ) {},

<span id='java-util-zip-Deflater-method-getAdler'>/**Returns the ADLER-32 value of the uncompressed data.
</span>@return {Number} the ADLER-32 value of the uncompressed data
*/
getAdler : function(  ) {},

<span id='java-util-zip-Deflater-method-getTotalIn'>/**Returns the total number of uncompressed bytes input so far.
</span>
 &lt;p&gt;Since the number of bytes may be greater than
 Integer.MAX_VALUE, the {@link #getBytesRead}() method is now
 the preferred means of obtaining this information.&lt;/p&gt;
@return {Number} the total number of uncompressed bytes input so far
*/
getTotalIn : function(  ) {},

<span id='java-util-zip-Deflater-method-getBytesRead'>/**Returns the total number of uncompressed bytes input so far.
</span>@return {Number} the total (non-negative) number of uncompressed bytes input so far
@since 1.5
*/
getBytesRead : function(  ) {},

<span id='java-util-zip-Deflater-method-getTotalOut'>/**Returns the total number of compressed bytes output so far.
</span>
 &lt;p&gt;Since the number of bytes may be greater than
 Integer.MAX_VALUE, the {@link #getBytesWritten}() method is now
 the preferred means of obtaining this information.&lt;/p&gt;
@return {Number} the total number of compressed bytes output so far
*/
getTotalOut : function(  ) {},

<span id='java-util-zip-Deflater-method-getBytesWritten'>/**Returns the total number of compressed bytes output so far.
</span>@return {Number} the total (non-negative) number of compressed bytes output so far
@since 1.5
*/
getBytesWritten : function(  ) {},

<span id='java-util-zip-Deflater-method-reset'>/**Resets deflater so that a new set of input data can be processed.
</span> Keeps current compression level and strategy settings.
*/
reset : function(  ) {},

<span id='java-util-zip-Deflater-method-end'>/**Closes the compressor and discards any unprocessed input.
</span> This method should be called when the compressor is no longer
 being used, but will also be called automatically by the
 finalize() method. Once this method is called, the behavior
 of the Deflater object is undefined.
*/
end : function(  ) {},


};</pre>
</body>
</html>
