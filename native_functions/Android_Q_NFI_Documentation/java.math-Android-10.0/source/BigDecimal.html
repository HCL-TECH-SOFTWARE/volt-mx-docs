<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-math-BigDecimal'>/**@class java.math.BigDecimal
</span> implements java.lang.Comparable

 implements java.io.Serializable

@extends java.lang.Number

 An immutable arbitrary-precision signed decimal.

 &lt;p&gt;A value is represented by an arbitrary-precision &quot;unscaled value&quot; and a signed 32-bit &quot;scale&quot;,
 combined thus: {@code unscaled * 10&lt;sup&gt;-scale&lt;/sup&gt;}. See {@link #unscaledValue} and {@link #scale}.

 &lt;p&gt;Most operations allow you to supply a {@link java.math.MathContext} to specify a desired rounding mode.
*/
var BigDecimal = {

<span id='java-math-BigDecimal-property-ROUND_UP'>/** Rounding mode where positive values are rounded towards positive infinity
</span> and negative values towards negative infinity.

 @see RoundingMode#UP
*/
ROUND_UP : &quot;0&quot;,
<span id='java-math-BigDecimal-property-ROUND_DOWN'>/** Rounding mode where the values are rounded towards zero.
</span>
 @see RoundingMode#DOWN
*/
ROUND_DOWN : &quot;1&quot;,
<span id='java-math-BigDecimal-property-ROUND_CEILING'>/** Rounding mode to round towards positive infinity. For positive values
</span> this rounding mode behaves as {@link #ROUND_UP}, for negative values as
 {@link #ROUND_DOWN}.

 @see RoundingMode#CEILING
*/
ROUND_CEILING : &quot;2&quot;,
<span id='java-math-BigDecimal-property-ROUND_FLOOR'>/** Rounding mode to round towards negative infinity. For positive values
</span> this rounding mode behaves as {@link #ROUND_DOWN}, for negative values as
 {@link #ROUND_UP}.

 @see RoundingMode#FLOOR
*/
ROUND_FLOOR : &quot;3&quot;,
<span id='java-math-BigDecimal-property-ROUND_HALF_UP'>/** Rounding mode where values are rounded towards the nearest neighbor.
</span> Ties are broken by rounding up.

 @see RoundingMode#HALF_UP
*/
ROUND_HALF_UP : &quot;4&quot;,
<span id='java-math-BigDecimal-property-ROUND_HALF_DOWN'>/** Rounding mode where values are rounded towards the nearest neighbor.
</span> Ties are broken by rounding down.

 @see RoundingMode#HALF_DOWN
*/
ROUND_HALF_DOWN : &quot;5&quot;,
<span id='java-math-BigDecimal-property-ROUND_HALF_EVEN'>/** Rounding mode where values are rounded towards the nearest neighbor.
</span> Ties are broken by rounding to the even neighbor.

 @see RoundingMode#HALF_EVEN
*/
ROUND_HALF_EVEN : &quot;6&quot;,
<span id='java-math-BigDecimal-property-ROUND_UNNECESSARY'>/** Rounding mode where the rounding operations throws an {@code
</span> ArithmeticException} for the case that rounding is necessary, i.e. for
 the case that the value cannot be represented exactly.

 @see RoundingMode#UNNECESSARY
*/
ROUND_UNNECESSARY : &quot;7&quot;,
<span id='java-math-BigDecimal-property-ZERO'>/** The constant zero as a {@code BigDecimal}.
</span>*/
ZERO : &quot;null&quot;,
<span id='java-math-BigDecimal-property-ONE'>/** The constant one as a {@code BigDecimal}.
</span>*/
ONE : &quot;null&quot;,
<span id='java-math-BigDecimal-property-TEN'>/** The constant ten as a {@code BigDecimal}.
</span>*/
TEN : &quot;null&quot;,
<span id='java-math-BigDecimal-method-valueOf'>/**Returns a new {@code BigDecimal} instance whose value is equal to {@code
</span> unscaledVal * 10&lt;sup&gt;-scale&lt;/sup&gt;}). The scale of the result is {@code
 scale}, and its unscaled value is {@code unscaledVal}.
*/
valueOf : function(  ) {},

<span id='java-math-BigDecimal-method-valueOf'>/**Returns a new {@code BigDecimal} instance whose value is equal to {@code
</span> unscaledVal}. The scale of the result is {@code 0}, and its unscaled
 value is {@code unscaledVal}.
@param {Number} unscaledVal
            value to be converted to a {@code BigDecimal}.
@return {Object {java.math.BigDecimal}} {@code BigDecimal} instance with the value {@code unscaledVal}.
*/
valueOf : function(  ) {},

<span id='java-math-BigDecimal-method-valueOf'>/**Returns a new {@code BigDecimal} instance whose value is equal to {@code
</span> val}. The new decimal is constructed as if the {@code BigDecimal(String)}
 constructor is called with an argument which is equal to {@code
 Double.toString(val)}. For example, {@code valueOf(&quot;0.1&quot;)} is converted to
 (unscaled=1, scale=1), although the double {@code 0.1} cannot be
 represented exactly as a double value. In contrast to that, a new {@code
 BigDecimal(0.1)} instance has the value {@code
 0.1000000000000000055511151231257827021181583404541015625} with an
 unscaled value {@code 1000000000000000055511151231257827021181583404541015625}
 and the scale {@code 55}.
@param {Number} val
            double value to be converted to a {@code BigDecimal}.
@return {Object {java.math.BigDecimal}} {@code BigDecimal} instance with the value {@code val}.
@throws NumberFormatException
             if {@code val} is infinite or {@code val} is not a number
*/
valueOf : function(  ) {},

<span id='java-math-BigDecimal-method-add'>/**Returns a new {@code BigDecimal} whose value is {@code this + augend}.
</span> The scale of the result is the maximum of the scales of the two
 arguments.
@param {Object {BigDecimal}} augend
            value to be added to {@code this}.
@return {Object {java.math.BigDecimal}} {@code this + augend}.
@throws NullPointerException
             if {@code augend == null}.
*/
add : function(  ) {},

<span id='java-math-BigDecimal-method-add'>/**Returns a new {@code BigDecimal} whose value is {@code this + augend}.
</span> The result is rounded according to the passed context {@code mc}.
@param {Object {BigDecimal}} augend
            value to be added to {@code this}.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code this + augend}.
@throws NullPointerException
             if {@code augend == null} or {@code mc == null}.
*/
add : function(  ) {},

<span id='java-math-BigDecimal-method-subtract'>/**Returns a new {@code BigDecimal} whose value is {@code this - subtrahend}.
</span> The scale of the result is the maximum of the scales of the two arguments.
@param {Object {BigDecimal}} subtrahend
            value to be subtracted from {@code this}.
@return {Object {java.math.BigDecimal}} {@code this - subtrahend}.
@throws NullPointerException
             if {@code subtrahend == null}.
*/
subtract : function(  ) {},

<span id='java-math-BigDecimal-method-subtract'>/**Returns a new {@code BigDecimal} whose value is {@code this - subtrahend}.
</span> The result is rounded according to the passed context {@code mc}.
@param {Object {BigDecimal}} subtrahend
            value to be subtracted from {@code this}.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code this - subtrahend}.
@throws NullPointerException
             if {@code subtrahend == null} or {@code mc == null}.
*/
subtract : function(  ) {},

<span id='java-math-BigDecimal-method-multiply'>/**Returns a new {@code BigDecimal} whose value is {@code this *
</span> multiplicand}. The scale of the result is the sum of the scales of the
 two arguments.
@param {Object {BigDecimal}} multiplicand
            value to be multiplied with {@code this}.
@return {Object {java.math.BigDecimal}} {@code this * multiplicand}.
@throws NullPointerException
             if {@code multiplicand == null}.
*/
multiply : function(  ) {},

<span id='java-math-BigDecimal-method-multiply'>/**Returns a new {@code BigDecimal} whose value is {@code this *
</span> multiplicand}. The result is rounded according to the passed context
 {@code mc}.
@param {Object {BigDecimal}} multiplicand
            value to be multiplied with {@code this}.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code this * multiplicand}.
@throws NullPointerException
             if {@code multiplicand == null} or {@code mc == null}.
*/
multiply : function(  ) {},

<span id='java-math-BigDecimal-method-divide'>/**Returns a new {@code BigDecimal} whose value is {@code this / divisor}.
</span> As scale of the result the parameter {@code scale} is used. If rounding
 is required to meet the specified scale, then the specified rounding mode
 {@code roundingMode} is applied.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Number} scale
            the scale of the result returned.
@param {Number} roundingMode
            rounding mode to be used to round the result.
@return {Object {java.math.BigDecimal}} {@code this / divisor} rounded according to the given rounding
         mode.
@throws NullPointerException
             if {@code divisor == null}.
@throws IllegalArgumentException
             if {@code roundingMode} is not a valid rounding mode.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code roundingMode == ROUND_UNNECESSARY} and rounding is
             necessary according to the given scale.
*/
divide : function(  ) {},

<span id='java-math-BigDecimal-method-divide'>/**Returns a new {@code BigDecimal} whose value is {@code this / divisor}.
</span> As scale of the result the parameter {@code scale} is used. If rounding
 is required to meet the specified scale, then the specified rounding mode
 {@code roundingMode} is applied.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Number} scale
            the scale of the result returned.
@param {Object {RoundingMode}} roundingMode
            rounding mode to be used to round the result.
@return {Object {java.math.BigDecimal}} {@code this / divisor} rounded according to the given rounding
         mode.
@throws NullPointerException
             if {@code divisor == null} or {@code roundingMode == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code roundingMode == RoundingMode.UNNECESSAR}Y and
             rounding is necessary according to the given scale and given
             precision.
*/
divide : function(  ) {},

<span id='java-math-BigDecimal-method-divide'>/**Returns a new {@code BigDecimal} whose value is {@code this / divisor}.
</span> The scale of the result is the scale of {@code this}. If rounding is
 required to meet the specified scale, then the specified rounding mode
 {@code roundingMode} is applied.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Number} roundingMode
            rounding mode to be used to round the result.
@return {Object {java.math.BigDecimal}} {@code this / divisor} rounded according to the given rounding
         mode.
@throws NullPointerException
             if {@code divisor == null}.
@throws IllegalArgumentException
             if {@code roundingMode} is not a valid rounding mode.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code roundingMode == ROUND_UNNECESSARY} and rounding is
             necessary according to the scale of this.
*/
divide : function(  ) {},

<span id='java-math-BigDecimal-method-divide'>/**Returns a new {@code BigDecimal} whose value is {@code this / divisor}.
</span> The scale of the result is the scale of {@code this}. If rounding is
 required to meet the specified scale, then the specified rounding mode
 {@code roundingMode} is applied.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Object {RoundingMode}} roundingMode
            rounding mode to be used to round the result.
@return {Object {java.math.BigDecimal}} {@code this / divisor} rounded according to the given rounding
         mode.
@throws NullPointerException
             if {@code divisor == null} or {@code roundingMode == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code roundingMode == RoundingMode.UNNECESSARY} and
             rounding is necessary according to the scale of this.
*/
divide : function(  ) {},

<span id='java-math-BigDecimal-method-divide'>/**Returns a new {@code BigDecimal} whose value is {@code this / divisor}.
</span> The scale of the result is the difference of the scales of {@code this}
 and {@code divisor}. If the exact result requires more digits, then the
 scale is adjusted accordingly. For example, {@code 1/128 = 0.0078125}
 which has a scale of {@code 7} and precision {@code 5}.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@return {Object {java.math.BigDecimal}} {@code this / divisor}.
@throws NullPointerException
             if {@code divisor == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if the result cannot be represented exactly.
*/
divide : function(  ) {},

<span id='java-math-BigDecimal-method-divide'>/**Returns a new {@code BigDecimal} whose value is {@code this / divisor}.
</span> The result is rounded according to the passed context {@code mc}. If the
 passed math context specifies precision {@code 0}, then this call is
 equivalent to {@code this.divide(divisor)}.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code this / divisor}.
@throws NullPointerException
             if {@code divisor == null} or {@code mc == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code mc.getRoundingMode() == UNNECESSARY} and rounding
             is necessary according {@code mc.getPrecision()}.
*/
divide : function(  ) {},

<span id='java-math-BigDecimal-method-divideToIntegralValue'>/**Returns a new {@code BigDecimal} whose value is the integral part of
</span> {@code this / divisor}. The quotient is rounded down towards zero to the
 next integer. For example, {@code 0.5/0.2 = 2}.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@return {Object {java.math.BigDecimal}} integral part of {@code this / divisor}.
@throws NullPointerException
             if {@code divisor == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
*/
divideToIntegralValue : function(  ) {},

<span id='java-math-BigDecimal-method-divideToIntegralValue'>/**Returns a new {@code BigDecimal} whose value is the integral part of
</span> {@code this / divisor}. The quotient is rounded down towards zero to the
 next integer. The rounding mode passed with the parameter {@code mc} is
 not considered. But if the precision of {@code mc &gt; 0} and the integral
 part requires more digits, then an {@code ArithmeticException} is thrown.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Object {MathContext}} mc
            math context which determines the maximal precision of the
            result.
@return {Object {java.math.BigDecimal}} integral part of {@code this / divisor}.
@throws NullPointerException
             if {@code divisor == null} or {@code mc == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code mc.getPrecision() &gt; 0} and the result requires more
             digits to be represented.
*/
divideToIntegralValue : function(  ) {},

<span id='java-math-BigDecimal-method-remainder'>/**Returns a new {@code BigDecimal} whose value is {@code this % divisor}.
</span> &lt;p&gt;
 The remainder is defined as {@code this -
 this.divideToIntegralValue(divisor) * divisor}.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@return {Object {java.math.BigDecimal}} {@code this % divisor}.
@throws NullPointerException
             if {@code divisor == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
*/
remainder : function(  ) {},

<span id='java-math-BigDecimal-method-remainder'>/**Returns a new {@code BigDecimal} whose value is {@code this % divisor}.
</span> &lt;p&gt;
 The remainder is defined as {@code this -
 this.divideToIntegralValue(divisor) * divisor}.
 &lt;p&gt;
 The specified rounding mode {@code mc} is used for the division only.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Object {MathContext}} mc
            rounding mode and precision to be used.
@return {Object {java.math.BigDecimal}} {@code this % divisor}.
@throws NullPointerException
             if {@code divisor == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@throws ArithmeticException
             if {@code mc.getPrecision() &gt; 0} and the result of {@code
             this.divideToIntegralValue(divisor, mc)} requires more digits
             to be represented.
*/
remainder : function(  ) {},

<span id='java-math-BigDecimal-method-divideAndRemainder'>/**Returns a {@code BigDecimal} array which contains the integral part of
</span> {@code this / divisor} at index 0 and the remainder {@code this %
 divisor} at index 1. The quotient is rounded down towards zero to the
 next integer.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@return {Object {java.math.BigDecimal}} {@code [this.divideToIntegralValue(divisor),
         this.remainder(divisor)]}.
@throws NullPointerException
             if {@code divisor == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@see #divideToIntegralValue
@see #remainder
*/
divideAndRemainder : function(  ) {},

<span id='java-math-BigDecimal-method-divideAndRemainder'>/**Returns a {@code BigDecimal} array which contains the integral part of
</span> {@code this / divisor} at index 0 and the remainder {@code this %
 divisor} at index 1. The quotient is rounded down towards zero to the
 next integer. The rounding mode passed with the parameter {@code mc} is
 not considered. But if the precision of {@code mc &gt; 0} and the integral
 part requires more digits, then an {@code ArithmeticException} is thrown.
@param {Object {BigDecimal}} divisor
            value by which {@code this} is divided.
@param {Object {MathContext}} mc
            math context which determines the maximal precision of the
            result.
@return {Object {java.math.BigDecimal}} {@code [this.divideToIntegralValue(divisor),
         this.remainder(divisor)]}.
@throws NullPointerException
             if {@code divisor == null}.
@throws ArithmeticException
             if {@code divisor == 0}.
@see #divideToIntegralValue
@see #remainder
*/
divideAndRemainder : function(  ) {},

<span id='java-math-BigDecimal-method-pow'>/**Returns a new {@code BigDecimal} whose value is {@code this&lt;sup&gt;n&lt;/sup&gt;}. The
</span> scale of the result is {@code n * this.scale()}.

 &lt;p&gt;{@code x.pow(0)} returns {@code 1}, even if {@code x == 0}.

 &lt;p&gt;Implementation Note: The implementation is based on the ANSI standard
 X3.274-1996 algorithm.
@throws ArithmeticException
             if {@code n &lt; 0} or {@code n &gt; 999999999}.
*/
pow : function(  ) {},

<span id='java-math-BigDecimal-method-pow'>/**Returns a new {@code BigDecimal} whose value is {@code this&lt;sup&gt;n&lt;/sup&gt;}. The
</span> result is rounded according to the passed context {@code mc}.

 &lt;p&gt;Implementation Note: The implementation is based on the ANSI standard
 X3.274-1996 algorithm.
@param {Number} mc
            rounding mode and precision for the result of this operation.
@throws ArithmeticException
             if {@code n &lt; 0} or {@code n &gt; 999999999}.
*/
pow : function(  ) {},

<span id='java-math-BigDecimal-method-abs'>/**Returns a {@code BigDecimal} whose value is the absolute value of
</span> {@code this}. The scale of the result is the same as the scale of this.
*/
abs : function(  ) {},

<span id='java-math-BigDecimal-method-abs'>/**Returns a {@code BigDecimal} whose value is the absolute value of
</span> {@code this}. The result is rounded according to the passed context
 {@code mc}.
*/
abs : function(  ) {},

<span id='java-math-BigDecimal-method-negate'>/**Returns a new {@code BigDecimal} whose value is the {@code -this}. The
</span> scale of the result is the same as the scale of this.
@return {Object {java.math.BigDecimal}} {@code -this}
*/
negate : function(  ) {},

<span id='java-math-BigDecimal-method-negate'>/**Returns a new {@code BigDecimal} whose value is the {@code -this}. The
</span> result is rounded according to the passed context {@code mc}.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code -this}
*/
negate : function(  ) {},

<span id='java-math-BigDecimal-method-plus'>/**Returns a new {@code BigDecimal} whose value is {@code +this}. The scale
</span> of the result is the same as the scale of this.
@return {Object {java.math.BigDecimal}} {@code this}
*/
plus : function(  ) {},

<span id='java-math-BigDecimal-method-plus'>/**Returns a new {@code BigDecimal} whose value is {@code +this}. The result
</span> is rounded according to the passed context {@code mc}.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code this}, rounded
*/
plus : function(  ) {},

<span id='java-math-BigDecimal-method-signum'>/**Returns the sign of this {@code BigDecimal}.
</span>@return {Number} {@code -1} if {@code this &lt; 0},
         {@code 0} if {@code this == 0},
         {@code 1} if {@code this &gt; 0}.
*/
signum : function(  ) {},

<span id='java-math-BigDecimal-method-scale'>/**Returns the scale of this {@code BigDecimal}. The scale is the number of
</span> digits behind the decimal point. The value of this {@code BigDecimal} is
 the {@code unsignedValue * 10&lt;sup&gt;-scale&lt;/sup&gt;}. If the scale is negative,
 then this {@code BigDecimal} represents a big integer.
@return {Number} the scale of this {@code BigDecimal}.
*/
scale : function(  ) {},

<span id='java-math-BigDecimal-method-precision'>/**Returns the precision of this {@code BigDecimal}. The precision is the
</span> number of decimal digits used to represent this decimal. It is equivalent
 to the number of digits of the unscaled value. The precision of {@code 0}
 is {@code 1} (independent of the scale).
@return {Number} the precision of this {@code BigDecimal}.
*/
precision : function(  ) {},

<span id='java-math-BigDecimal-method-unscaledValue'>/**Returns the unscaled value (mantissa) of this {@code BigDecimal} instance
</span> as a {@code BigInteger}. The unscaled value can be computed as
 {@code this * 10&lt;sup&gt;scale&lt;/sup&gt;}.
*/
unscaledValue : function(  ) {},

<span id='java-math-BigDecimal-method-round'>/**Returns a new {@code BigDecimal} whose value is {@code this}, rounded
</span> according to the passed context {@code mc}.
 &lt;p&gt;
 If {@code mc.precision = 0}, then no rounding is performed.
 &lt;p&gt;
 If {@code mc.precision &gt; 0} and {@code mc.roundingMode == UNNECESSARY},
 then an {@code ArithmeticException} is thrown if the result cannot be
 represented exactly within the given precision.
@param {Object {MathContext}} mc
            rounding mode and precision for the result of this operation.
@return {Object {java.math.BigDecimal}} {@code this} rounded according to the passed context.
@throws ArithmeticException
             if {@code mc.precision &gt; 0} and {@code mc.roundingMode ==
             UNNECESSARY} and this cannot be represented within the given
             precision.
*/
round : function(  ) {},

<span id='java-math-BigDecimal-method-setScale'>/**Returns a new {@code BigDecimal} instance with the specified scale.
</span> &lt;p&gt;
 If the new scale is greater than the old scale, then additional zeros are
 added to the unscaled value. In this case no rounding is necessary.
 &lt;p&gt;
 If the new scale is smaller than the old scale, then trailing digits are
 removed. If these trailing digits are not zero, then the remaining
 unscaled value has to be rounded. For this rounding operation the
 specified rounding mode is used.
@param {Number} newScale
            scale of the result returned.
@param {Object {RoundingMode}} roundingMode
            rounding mode to be used to round the result.
@return {Object {java.math.BigDecimal}} a new {@code BigDecimal} instance with the specified scale.
@throws NullPointerException
             if {@code roundingMode == null}.
@throws ArithmeticException
             if {@code roundingMode == ROUND_UNNECESSARY} and rounding is
             necessary according to the given scale.
*/
setScale : function(  ) {},

<span id='java-math-BigDecimal-method-setScale'>/**Returns a new {@code BigDecimal} instance with the specified scale.
</span> &lt;p&gt;
 If the new scale is greater than the old scale, then additional zeros are
 added to the unscaled value. In this case no rounding is necessary.
 &lt;p&gt;
 If the new scale is smaller than the old scale, then trailing digits are
 removed. If these trailing digits are not zero, then the remaining
 unscaled value has to be rounded. For this rounding operation the
 specified rounding mode is used.
@param {Number} newScale
            scale of the result returned.
@param {Number} roundingMode
            rounding mode to be used to round the result.
@return {Object {java.math.BigDecimal}} a new {@code BigDecimal} instance with the specified scale.
@throws IllegalArgumentException
             if {@code roundingMode} is not a valid rounding mode.
@throws ArithmeticException
             if {@code roundingMode == ROUND_UNNECESSARY} and rounding is
             necessary according to the given scale.
*/
setScale : function(  ) {},

<span id='java-math-BigDecimal-method-setScale'>/**Returns a new {@code BigDecimal} instance with the specified scale. If
</span> the new scale is greater than the old scale, then additional zeros are
 added to the unscaled value. If the new scale is smaller than the old
 scale, then trailing zeros are removed. If the trailing digits are not
 zeros then an ArithmeticException is thrown.
 &lt;p&gt;
 If no exception is thrown, then the following equation holds: {@code
 x.setScale(s).compareTo(x) == 0}.
@param {Number} newScale
            scale of the result returned.
@return {Object {java.math.BigDecimal}} a new {@code BigDecimal} instance with the specified scale.
@throws ArithmeticException
             if rounding would be necessary.
*/
setScale : function(  ) {},

<span id='java-math-BigDecimal-method-movePointLeft'>/**Returns a new {@code BigDecimal} instance where the decimal point has
</span> been moved {@code n} places to the left. If {@code n &lt; 0} then the
 decimal point is moved {@code -n} places to the right.

 &lt;p&gt;The result is obtained by changing its scale. If the scale of the result
 becomes negative, then its precision is increased such that the scale is
 zero.

 &lt;p&gt;Note, that {@code movePointLeft(0)} returns a result which is
 mathematically equivalent, but which has {@code scale &gt;= 0}.
*/
movePointLeft : function(  ) {},

<span id='java-math-BigDecimal-method-movePointRight'>/**Returns a new {@code BigDecimal} instance where the decimal point has
</span> been moved {@code n} places to the right. If {@code n &lt; 0} then the
 decimal point is moved {@code -n} places to the left.

 &lt;p&gt;The result is obtained by changing its scale. If the scale of the result
 becomes negative, then its precision is increased such that the scale is
 zero.

 &lt;p&gt;Note, that {@code movePointRight(0)} returns a result which is
 mathematically equivalent, but which has scale &gt;= 0.
*/
movePointRight : function(  ) {},

<span id='java-math-BigDecimal-method-scaleByPowerOfTen'>/**Returns a new {@code BigDecimal} whose value is {@code this * 10&lt;sup&gt;n&lt;/sup&gt;}.
</span> The scale of the result is {@code this.scale()} - {@code n}.
 The precision of the result is the precision of {@code this}.

 &lt;p&gt;This method has the same effect as {@link #movePointRight}, except that
 the precision is not changed.
*/
scaleByPowerOfTen : function(  ) {},

<span id='java-math-BigDecimal-method-stripTrailingZeros'>/**Returns a new {@code BigDecimal} instance with the same value as {@code
</span> this} but with a unscaled value where the trailing zeros have been
 removed. If the unscaled value of {@code this} has n trailing zeros, then
 the scale and the precision of the result has been reduced by n.
@return {Object {java.math.BigDecimal}} a new {@code BigDecimal} instance equivalent to this where the
         trailing zeros of the unscaled value have been removed.
*/
stripTrailingZeros : function(  ) {},

<span id='java-math-BigDecimal-method-compareTo'>/**Compares this {@code BigDecimal} with {@code val}. Returns one of the
</span> three values {@code 1}, {@code 0}, or {@code -1}. The method behaves as
 if {@code this.subtract(val)} is computed. If this difference is &gt; 0 then
 1 is returned, if the difference is &lt; 0 then -1 is returned, and if the
 difference is 0 then 0 is returned. This means, that if two decimal
 instances are compared which are equal in value but differ in scale, then
 these two instances are considered as equal.
@param {Object {BigDecimal}} val
            value to be compared with {@code this}.
@return {Number} {@code 1} if {@code this &gt; val}, {@code -1} if {@code this &lt; val},
         {@code 0} if {@code this == val}.
@throws NullPointerException
             if {@code val == null}.
*/
compareTo : function(  ) {},

<span id='java-math-BigDecimal-method-equals'>/**Returns {@code true} if {@code x} is a {@code BigDecimal} instance and if
</span> this instance is equal to this big decimal. Two big decimals are equal if
 their unscaled value and their scale is equal. For example, 1.0
 (10*10&lt;sup&gt;-1&lt;/sup&gt;) is not equal to 1.00 (100*10&lt;sup&gt;-2&lt;/sup&gt;). Similarly, zero
 instances are not equal if their scale differs.
*/
equals : function(  ) {},

<span id='java-math-BigDecimal-method-min'>/**Returns the minimum of this {@code BigDecimal} and {@code val}.
</span>@param {Object {BigDecimal}} val
            value to be used to compute the minimum with this.
@return {Object {java.math.BigDecimal}} {@code min(this, val}.
@throws NullPointerException
             if {@code val == null}.
*/
min : function(  ) {},

<span id='java-math-BigDecimal-method-max'>/**Returns the maximum of this {@code BigDecimal} and {@code val}.
</span>@param {Object {BigDecimal}} val
            value to be used to compute the maximum with this.
@return {Object {java.math.BigDecimal}} {@code max(this, val}.
@throws NullPointerException
             if {@code val == null}.
*/
max : function(  ) {},

<span id='java-math-BigDecimal-method-hashCode'>/**Returns a hash code for this {@code BigDecimal}.
</span>@return {Number} hash code for {@code this}.
*/
hashCode : function(  ) {},

<span id='java-math-BigDecimal-method-toString'>/**Returns a canonical string representation of this {@code BigDecimal}. If
</span> necessary, scientific notation is used. This representation always prints
 all significant digits of this value.
 &lt;p&gt;
 If the scale is negative or if {@code scale - precision &gt;= 6} then
 scientific notation is used.
@return {String} a string representation of {@code this} in scientific notation if
         necessary.
*/
toString : function(  ) {},

<span id='java-math-BigDecimal-method-toEngineeringString'>/**Returns a string representation of this {@code BigDecimal}. This
</span> representation always prints all significant digits of this value.
 &lt;p&gt;
 If the scale is negative or if {@code scale - precision &gt;= 6} then
 engineering notation is used. Engineering notation is similar to the
 scientific notation except that the exponent is made to be a multiple of
 3 such that the integer part is &gt;= 1 and &lt; 1000.
@return {String} a string representation of {@code this} in engineering notation
         if necessary.
*/
toEngineeringString : function(  ) {},

<span id='java-math-BigDecimal-method-toPlainString'>/**Returns a string representation of this {@code BigDecimal}. No scientific
</span> notation is used. This methods adds zeros where necessary.
 &lt;p&gt;
 If this string representation is used to create a new instance, this
 instance is generally not identical to {@code this} as the precision
 changes.
 &lt;p&gt;
 {@code x.equals(new BigDecimal(x.toPlainString())} usually returns
 {@code false}.
 &lt;p&gt;
 {@code x.compareTo(new BigDecimal(x.toPlainString())} returns {@code 0}.
@return {String} a string representation of {@code this} without exponent part.
*/
toPlainString : function(  ) {},

<span id='java-math-BigDecimal-method-toBigInteger'>/**Returns this {@code BigDecimal} as a big integer instance. A fractional
</span> part is discarded.
@return {Object {java.math.BigInteger}} this {@code BigDecimal} as a big integer instance.
*/
toBigInteger : function(  ) {},

<span id='java-math-BigDecimal-method-toBigIntegerExact'>/**Returns this {@code BigDecimal} as a big integer instance if it has no
</span> fractional part. If this {@code BigDecimal} has a fractional part, i.e.
 if rounding would be necessary, an {@code ArithmeticException} is thrown.
@return {Object {java.math.BigInteger}} this {@code BigDecimal} as a big integer value.
@throws ArithmeticException
             if rounding is necessary.
*/
toBigIntegerExact : function(  ) {},

<span id='java-math-BigDecimal-method-longValue'>/**Returns this {@code BigDecimal} as an long value. Any fractional part is
</span> discarded. If the integral part of {@code this} is too big to be
 represented as an long, then {@code this % 2&lt;sup&gt;64&lt;/sup&gt;} is returned.
*/
longValue : function(  ) {},

<span id='java-math-BigDecimal-method-longValueExact'>/**Returns this {@code BigDecimal} as a long value if it has no fractional
</span> part and if its value fits to the int range ([-2&lt;sup&gt;63&lt;/sup&gt;..2&lt;sup&gt;63&lt;/sup&gt;-1]). If
 these conditions are not met, an {@code ArithmeticException} is thrown.
@throws ArithmeticException
             if rounding is necessary or the number doesn't fit in a long.
*/
longValueExact : function(  ) {},

<span id='java-math-BigDecimal-method-intValue'>/**Returns this {@code BigDecimal} as an int value. Any fractional part is
</span> discarded. If the integral part of {@code this} is too big to be
 represented as an int, then {@code this % 2&lt;sup&gt;32&lt;/sup&gt;} is returned.
*/
intValue : function(  ) {},

<span id='java-math-BigDecimal-method-intValueExact'>/**Returns this {@code BigDecimal} as a int value if it has no fractional
</span> part and if its value fits to the int range ([-2&lt;sup&gt;31&lt;/sup&gt;..2&lt;sup&gt;31&lt;/sup&gt;-1]). If
 these conditions are not met, an {@code ArithmeticException} is thrown.
@throws ArithmeticException
             if rounding is necessary or the number doesn't fit in an int.
*/
intValueExact : function(  ) {},

<span id='java-math-BigDecimal-method-shortValueExact'>/**Returns this {@code BigDecimal} as a short value if it has no fractional
</span> part and if its value fits to the short range ([-2&lt;sup&gt;15&lt;/sup&gt;..2&lt;sup&gt;15&lt;/sup&gt;-1]). If
 these conditions are not met, an {@code ArithmeticException} is thrown.
@throws ArithmeticException
             if rounding is necessary of the number doesn't fit in a short.
*/
shortValueExact : function(  ) {},

<span id='java-math-BigDecimal-method-byteValueExact'>/**Returns this {@code BigDecimal} as a byte value if it has no fractional
</span> part and if its value fits to the byte range ([-128..127]). If these
 conditions are not met, an {@code ArithmeticException} is thrown.
@throws ArithmeticException
             if rounding is necessary or the number doesn't fit in a byte.
*/
byteValueExact : function(  ) {},

<span id='java-math-BigDecimal-method-floatValue'>/**Returns this {@code BigDecimal} as a float value. If {@code this} is too
</span> big to be represented as an float, then {@code Float.POSITIVE_INFINITY}
 or {@code Float.NEGATIVE_INFINITY} is returned.
 &lt;p&gt;
 Note, that if the unscaled value has more than 24 significant digits,
 then this decimal cannot be represented exactly in a float variable. In
 this case the result is rounded.
 &lt;p&gt;
 For example, if the instance {@code x1 = new BigDecimal(&quot;0.1&quot;)} cannot be
 represented exactly as a float, and thus {@code x1.equals(new
 BigDecimal(x1.floatValue())} returns {@code false} for this case.
 &lt;p&gt;
 Similarly, if the instance {@code new BigDecimal(16777217)} is converted
 to a float, the result is {@code 1.6777216E}7.
@return {Number} this {@code BigDecimal} as a float value.
*/
floatValue : function(  ) {},

<span id='java-math-BigDecimal-method-doubleValue'>/**Returns this {@code BigDecimal} as a double value. If {@code this} is too
</span> big to be represented as an float, then {@code Double.POSITIVE_INFINITY}
 or {@code Double.NEGATIVE_INFINITY} is returned.
 &lt;p&gt;
 Note, that if the unscaled value has more than 53 significant digits,
 then this decimal cannot be represented exactly in a double variable. In
 this case the result is rounded.
 &lt;p&gt;
 For example, if the instance {@code x1 = new BigDecimal(&quot;0.1&quot;)} cannot be
 represented exactly as a double, and thus {@code x1.equals(new
 BigDecimal(x1.doubleValue())} returns {@code false} for this case.
 &lt;p&gt;
 Similarly, if the instance {@code new BigDecimal(9007199254740993L)} is
 converted to a double, the result is {@code 9.007199254740992E15}.
 &lt;p&gt;
@return {Number} this {@code BigDecimal} as a double value.
*/
doubleValue : function(  ) {},

<span id='java-math-BigDecimal-method-ulp'>/**Returns the unit in the last place (ULP) of this {@code BigDecimal}
</span> instance. An ULP is the distance to the nearest big decimal with the same
 precision.

 &lt;p&gt;The amount of a rounding error in the evaluation of a floating-point
 operation is often expressed in ULPs. An error of 1 ULP is often seen as
 a tolerable error.

 &lt;p&gt;For class {@code BigDecimal}, the ULP of a number is simply 10&lt;sup&gt;-scale&lt;/sup&gt;.
 For example, {@code new BigDecimal(0.1).ulp()} returns {@code 1E-55}.
@return {Object {java.math.BigDecimal}} unit in the last place (ULP) of this {@code BigDecimal} instance.
*/
ulp : function(  ) {},


};</pre>
</body>
</html>
