Ext.data.JsonP.java_util_concurrent_locks_ReentrantReadWriteLock({"tagname":"class","name":"java.util.concurrent.locks.ReentrantReadWriteLock","autodetected":{},"files":[{"filename":"ReentrantReadWriteLock.js","href":"ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock"}],"extends":"java.lang.Object","since":"1.5","author":[{"tagname":"author","name":"Doug Lea","email":null}],"members":[{"name":"getQueueLength","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-getQueueLength","meta":{}},{"name":"getReadHoldCount","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-getReadHoldCount","meta":{}},{"name":"getReadLockCount","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-getReadLockCount","meta":{}},{"name":"getWaitQueueLength","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-getWaitQueueLength","meta":{}},{"name":"getWriteHoldCount","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-getWriteHoldCount","meta":{}},{"name":"hasQueuedThread","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-hasQueuedThread","meta":{}},{"name":"hasQueuedThreads","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-hasQueuedThreads","meta":{}},{"name":"hasWaiters","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-hasWaiters","meta":{}},{"name":"isFair","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-isFair","meta":{}},{"name":"isWriteLocked","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-isWriteLocked","meta":{}},{"name":"isWriteLockedByCurrentThread","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-isWriteLockedByCurrentThread","meta":{}},{"name":"readLock","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-readLock","meta":{}},{"name":"toString","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-toString","meta":{}},{"name":"writeLock","tagname":"method","owner":"java.util.concurrent.locks.ReentrantReadWriteLock","id":"method-writeLock","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.util.concurrent.locks.ReentrantReadWriteLock","short_doc":"implements java.util.concurrent.locks.ReadWriteLock\n\n implements java.io.Serializable\n\nAn implementation of java.util...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>java.util.concurrent.locks.ReentrantReadWriteLock</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock' target='_blank'>ReentrantReadWriteLock.js</a></div></pre><div class='doc-contents'><p>implements <a href=\"#!/api/java.util.concurrent.locks.ReadWriteLock\" rel=\"java.util.concurrent.locks.ReadWriteLock\" class=\"docClass\">java.util.concurrent.locks.ReadWriteLock</a></p>\n\n<p> implements java.io.Serializable</p>\n\n<p>An implementation of <a href=\"#!/api/java.util.concurrent.locks.ReadWriteLock\" rel=\"java.util.concurrent.locks.ReadWriteLock\" class=\"docClass\">java.util.concurrent.locks.ReadWriteLock</a> supporting similar\n semantics to <a href=\"#!/api/java.util.concurrent.locks.ReentrantLock\" rel=\"java.util.concurrent.locks.ReentrantLock\" class=\"docClass\">java.util.concurrent.locks.ReentrantLock</a>.\n <p>This class has the following properties:</p>\n\n<p> <ul>\n <li><b>Acquisition order</b></li></ul></p>\n\n<p> <p>This class does not impose a reader or writer preference\n ordering for lock access.  However, it does support an optional\n <em>fairness</em> policy.</p>\n\n<p> <dl>\n <dt><b><i>Non-fair mode (default)</i></b>\n <dd style=\"font-family:'DejaVu Sans', Arial, Helvetica, sans-serif\">\n When constructed as non-fair (the default), the order of entry\n to the read and write lock is unspecified, subject to reentrancy\n constraints.  A nonfair lock that is continuously contended may\n indefinitely postpone one or more reader or writer threads, but\n will normally have higher throughput than a fair lock.</dd></dt></dl></p>\n\n<p> <dt><b><i>Fair mode</i></b>\n <dd style=\"font-family:'DejaVu Sans', Arial, Helvetica, sans-serif\">\n When constructed as fair, threads contend for entry using an\n approximately arrival-order policy. When the currently held lock\n is released, either the longest-waiting single writer thread will\n be assigned the write lock, or if there is a group of reader threads\n waiting longer than all waiting writer threads, that group will be\n assigned the read lock.</dd></dt></p>\n\n<p> <p>A thread that tries to acquire a fair read lock (non-reentrantly)\n will block if either the write lock is held, or there is a waiting\n writer thread. The thread will not acquire the read lock until\n after the oldest currently waiting writer thread has acquired and\n released the write lock. Of course, if a waiting writer abandons\n its wait, leaving one or more reader threads as the longest waiters\n in the queue with the write lock free, then those readers will be\n assigned the read lock.</p>\n\n<p> <p>A thread that tries to acquire a fair write lock (non-reentrantly)\n will block unless both the read lock and write lock are free (which\n implies there are no waiting threads).  (Note that the non-blocking\n java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.tryLock() and java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.tryLock() methods\n do not honor this fair setting and will immediately acquire the lock\n if it is possible, regardless of waiting threads.)\n </p>\n\n<p> <li><b>Reentrancy</b></li></p>\n\n<p> <p>This lock allows both readers and writers to reacquire read or\n write locks in the style of a <a href=\"#!/api/java.util.concurrent.locks.ReentrantLock\" rel=\"java.util.concurrent.locks.ReentrantLock\" class=\"docClass\">java.util.concurrent.locks.ReentrantLock</a>. Non-reentrant\n readers are not allowed until all write locks held by the writing\n thread have been released.</p>\n\n<p> <p>Additionally, a writer can acquire the read lock, but not\n vice-versa.  Among other applications, reentrancy can be useful\n when write locks are held during calls or callbacks to methods that\n perform reads under read locks.  If a reader tries to acquire the\n write lock it will never succeed.</p>\n\n<p> <li><b>Lock downgrading</b>\n <p>Reentrancy also allows downgrading from the write lock to a read lock,\n by acquiring the write lock, then the read lock and then releasing the\n write lock. However, upgrading from a read lock to the write lock is\n <b>not</b> possible.</p>\n\n<p> <li><b>Interruption of lock acquisition</b>\n <p>The read lock and write lock both support interruption during lock\n acquisition.</p>\n\n<p> <li><b><a href=\"#!/api/java.util.concurrent.locks.Condition\" rel=\"java.util.concurrent.locks.Condition\" class=\"docClass\">java.util.concurrent.locks.Condition</a> support</b>\n <p>The write lock provides a <a href=\"#!/api/java.util.concurrent.locks.Condition\" rel=\"java.util.concurrent.locks.Condition\" class=\"docClass\">java.util.concurrent.locks.Condition</a> implementation that\n behaves in the same way, with respect to the write lock, as the\n <a href=\"#!/api/java.util.concurrent.locks.Condition\" rel=\"java.util.concurrent.locks.Condition\" class=\"docClass\">java.util.concurrent.locks.Condition</a> implementation provided by\n <a href=\"#!/api/java.util.concurrent.locks.ReentrantLock-method-newCondition\" rel=\"java.util.concurrent.locks.ReentrantLock-method-newCondition\" class=\"docClass\">java.util.concurrent.locks.ReentrantLock.newCondition</a> does for <a href=\"#!/api/java.util.concurrent.locks.ReentrantLock\" rel=\"java.util.concurrent.locks.ReentrantLock\" class=\"docClass\">java.util.concurrent.locks.ReentrantLock</a>.\n This <a href=\"#!/api/java.util.concurrent.locks.Condition\" rel=\"java.util.concurrent.locks.Condition\" class=\"docClass\">java.util.concurrent.locks.Condition</a> can, of course, only be used with the write lock.</p>\n\n<p> <p>The read lock does not support a <a href=\"#!/api/java.util.concurrent.locks.Condition\" rel=\"java.util.concurrent.locks.Condition\" class=\"docClass\">java.util.concurrent.locks.Condition</a> and\n {@code readLock().newCondition()} throws\n {@code UnsupportedOperationException}.</p>\n\n<p> <li><b>Instrumentation</b>\n <p>This class supports methods to determine whether locks\n are held or contended. These methods are designed for monitoring\n system state, not for synchronization control.\n </p>\n\n<p> <p>Serialization of this class behaves in the same way as built-in\n locks: a deserialized lock is in the unlocked state, regardless of\n its state when serialized.</p>\n\n<p> <p><b>Sample usages</b>. Here is a code sketch showing how to perform\n lock downgrading after updating a cache (exception handling is\n particularly tricky when handling multiple locks in a non-nested\n fashion):</p>\n\n<p> <pre> {@code\n class CachedData {\n   Object data;\n   volatile boolean cacheValid;\n   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</pre></p>\n\n<p>   void processCachedData() {\n     rwl.readLock().lock();\n     if (!cacheValid) {\n       // Must release read lock before acquiring write lock\n       rwl.readLock().unlock();\n       rwl.writeLock().lock();\n       try {\n         // Recheck state because another thread might have\n         // acquired write lock and changed state before we did.\n         if (!cacheValid) {\n           data = ...\n           cacheValid = true;\n         }\n         // Downgrade by acquiring read lock before releasing write lock\n         rwl.readLock().lock();\n       } finally {\n         rwl.writeLock().unlock(); // Unlock write, still hold read\n       }\n     }</p>\n\n<pre><code> try {\n   use(data);\n } finally {\n   rwl.readLock().unlock();\n }\n</code></pre>\n\n<p>   }\n }}</p>\n\n<p> ReentrantReadWriteLocks can be used to improve concurrency in some\n uses of some kinds of Collections. This is typically worthwhile\n only when the collections are expected to be large, accessed by\n more reader threads than writer threads, and entail operations with\n overhead that outweighs synchronization overhead. For example, here\n is a class using a TreeMap that is expected to be large and\n concurrently accessed.</p>\n\n<p> <pre> {@code\n class RWDictionary {\n   private final Map&lt;String, Data> m = new TreeMap&lt;>();\n   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n   private final Lock r = rwl.readLock();\n   private final Lock w = rwl.writeLock();</pre></p>\n\n<p>   public Data get(String key) {\n     r.lock();\n     try { return m.get(key); }\n     finally { r.unlock(); }\n   }\n   public List<String> allKeys() {\n     r.lock();\n     try { return new ArrayList&lt;>(m.keySet()); }\n     finally { r.unlock(); }\n   }\n   public Data put(String key, Data value) {\n     w.lock();\n     try { return m.put(key, value); }\n     finally { w.unlock(); }\n   }\n   public void clear() {\n     w.lock();\n     try { m.clear(); }\n     finally { w.unlock(); }\n   }\n }}</String></p>\n\n<p> <h3>Implementation Notes</h3></p>\n\n<p> <p>This lock supports a maximum of 65535 recursive write locks\n and 65535 read locks. Attempts to exceed these limits result in\n Error throws from locking methods.</p>\n        <p>Available since: <b>1.5</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-getQueueLength' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-getQueueLength' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-getQueueLength' class='name expandable'>getQueueLength</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns an estimate of the number of threads waiting to acquire\n either the read or write lock. ...</div><div class='long'><p>Returns an estimate of the number of threads waiting to acquire\n either the read or write lock.  The value is only an estimate\n because the number of threads may change dynamically while this\n method traverses internal data structures.  This method is\n designed for use in monitoring system state, not for\n synchronization control.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the estimated number of threads waiting for this lock</p>\n</div></li></ul></div></div></div><div id='method-getReadHoldCount' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-getReadHoldCount' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-getReadHoldCount' class='name expandable'>getReadHoldCount</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries the number of reentrant read holds on this lock by the\n current thread. ...</div><div class='long'><p>Queries the number of reentrant read holds on this lock by the\n current thread.  A reader thread has a hold on a lock for\n each lock action that is not matched by an unlock action.</p>\n        <p>Available since: <b>1.6</b></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the number of holds on the read lock by the current thread,\n         or zero if the read lock is not held by the current thread</p>\n</div></li></ul></div></div></div><div id='method-getReadLockCount' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-getReadLockCount' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-getReadLockCount' class='name expandable'>getReadLockCount</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries the number of read locks held for this lock. ...</div><div class='long'><p>Queries the number of read locks held for this lock. This\n method is designed for use in monitoring system state, not for\n synchronization control.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the number of read locks held</p>\n</div></li></ul></div></div></div><div id='method-getWaitQueueLength' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-getWaitQueueLength' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-getWaitQueueLength' class='name expandable'>getWaitQueueLength</a>( <span class='pre'>condition</span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns an estimate of the number of threads waiting on the\n given condition associated with the write lock. ...</div><div class='long'><p>Returns an estimate of the number of threads waiting on the\n given condition associated with the write lock. Note that because\n timeouts and interrupts may occur at any time, the estimate\n serves only as an upper bound on the actual number of waiters.\n This method is designed for use in monitoring of the system\n state, not for synchronization control.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>condition</span> : Object {Condition}<div class='sub-desc'><p>the condition</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the estimated number of waiting threads</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalMonitorStateException if this lock is not held</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the given condition is\n         not associated with this lock</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if the condition is null</p>\n</div></li></ul></div></div></div><div id='method-getWriteHoldCount' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-getWriteHoldCount' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-getWriteHoldCount' class='name expandable'>getWriteHoldCount</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries the number of reentrant write holds on this lock by the\n current thread. ...</div><div class='long'><p>Queries the number of reentrant write holds on this lock by the\n current thread.  A writer thread has a hold on a lock for\n each lock action that is not matched by an unlock action.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the number of holds on the write lock by the current thread,\n         or zero if the write lock is not held by the current thread</p>\n</div></li></ul></div></div></div><div id='method-hasQueuedThread' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-hasQueuedThread' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-hasQueuedThread' class='name expandable'>hasQueuedThread</a>( <span class='pre'>thread</span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries whether the given thread is waiting to acquire either\n the read or write lock. ...</div><div class='long'><p>Queries whether the given thread is waiting to acquire either\n the read or write lock. Note that because cancellations may\n occur at any time, a {@code true} return does not guarantee\n that this thread will ever acquire a lock.  This method is\n designed primarily for use in monitoring of the system state.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>thread</span> : Object {Thread}<div class='sub-desc'><p>the thread</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if the given thread is queued waiting for this lock</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if the thread is null</p>\n</div></li></ul></div></div></div><div id='method-hasQueuedThreads' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-hasQueuedThreads' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-hasQueuedThreads' class='name expandable'>hasQueuedThreads</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries whether any threads are waiting to acquire the read or\n write lock. ...</div><div class='long'><p>Queries whether any threads are waiting to acquire the read or\n write lock. Note that because cancellations may occur at any\n time, a {@code true} return does not guarantee that any other\n thread will ever acquire a lock.  This method is designed\n primarily for use in monitoring of the system state.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if there may be other threads waiting to\n         acquire the lock</p>\n</div></li></ul></div></div></div><div id='method-hasWaiters' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-hasWaiters' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-hasWaiters' class='name expandable'>hasWaiters</a>( <span class='pre'>condition</span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries whether any threads are waiting on the given condition\n associated with the write lock. ...</div><div class='long'><p>Queries whether any threads are waiting on the given condition\n associated with the write lock. Note that because timeouts and\n interrupts may occur at any time, a {@code true} return does\n not guarantee that a future {@code signal} will awaken any\n threads.  This method is designed primarily for use in\n monitoring of the system state.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>condition</span> : Object {Condition}<div class='sub-desc'><p>the condition</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if there are any waiting threads</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalMonitorStateException if this lock is not held</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the given condition is\n         not associated with this lock</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if the condition is null</p>\n</div></li></ul></div></div></div><div id='method-isFair' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-isFair' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-isFair' class='name expandable'>isFair</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns {@code true} if this lock has fairness set true. ...</div><div class='long'><p>Returns {@code true} if this lock has fairness set true.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if this lock has fairness set true</p>\n</div></li></ul></div></div></div><div id='method-isWriteLocked' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-isWriteLocked' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-isWriteLocked' class='name expandable'>isWriteLocked</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries if the write lock is held by any thread. ...</div><div class='long'><p>Queries if the write lock is held by any thread. This method is\n designed for use in monitoring system state, not for\n synchronization control.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if any thread holds the write lock and\n         {@code false} otherwise</p>\n</div></li></ul></div></div></div><div id='method-isWriteLockedByCurrentThread' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-isWriteLockedByCurrentThread' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-isWriteLockedByCurrentThread' class='name expandable'>isWriteLockedByCurrentThread</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries if the write lock is held by the current thread. ...</div><div class='long'><p>Queries if the write lock is held by the current thread.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if the current thread holds the write lock and\n         {@code false} otherwise</p>\n</div></li></ul></div></div></div><div id='method-readLock' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-readLock' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-readLock' class='name expandable'>readLock</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div><div id='method-toString' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-toString' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-toString' class='name expandable'>toString</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a string identifying this lock, as well as its lock state. ...</div><div class='long'><p>Returns a string identifying this lock, as well as its lock state.\n The state, in brackets, includes the String {@code \"Write locks =\"}\n followed by the number of reentrantly held write locks, and the\n String {@code \"Read locks =\"} followed by the number of held\n read locks.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>a string identifying this lock, as well as its lock state</p>\n</div></li></ul></div></div></div><div id='method-writeLock' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.locks.ReentrantReadWriteLock'>java.util.concurrent.locks.ReentrantReadWriteLock</span><br/><a href='source/ReentrantReadWriteLock.html#java-util-concurrent-locks-ReentrantReadWriteLock-method-writeLock' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.locks.ReentrantReadWriteLock-method-writeLock' class='name expandable'>writeLock</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div></div></div></div></div>","meta":{}});