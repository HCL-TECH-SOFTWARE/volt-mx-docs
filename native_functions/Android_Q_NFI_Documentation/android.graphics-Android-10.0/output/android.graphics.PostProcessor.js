Ext.data.JsonP.android_graphics_PostProcessor({"tagname":"class","name":"android.graphics.PostProcessor","autodetected":{},"files":[{"filename":"PostProcessor.js","href":"PostProcessor.html#android-graphics-PostProcessor"}],"members":[{"name":"onPostProcess","tagname":"method","owner":"android.graphics.PostProcessor","id":"method-onPostProcess","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-android.graphics.PostProcessor","short_doc":"Helper interface for adding custom processing to an image. ...","classIcon":"icon-class","superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/PostProcessor.html#android-graphics-PostProcessor' target='_blank'>PostProcessor.js</a></div></pre><div class='doc-contents'><p>Helper interface for adding custom processing to an image.</p>\n\n<p>  <p>The image being processed may be a Drawable, a <a href=\"#!/api/android.graphics.Bitmap\" rel=\"android.graphics.Bitmap\" class=\"docClass\">android.graphics.Bitmap</a>, or\n  a frame of an AnimatedImageDrawable produced by <a href=\"#!/api/android.graphics.ImageDecoder\" rel=\"android.graphics.ImageDecoder\" class=\"docClass\">android.graphics.ImageDecoder</a>.\n  This is called before the requested object is returned.</p></p>\n\n<p>  <p>This custom processing can even be applied to images that will be returned\n  as immutable objects, such as a <a href=\"#!/api/android.graphics.Bitmap\" rel=\"android.graphics.Bitmap\" class=\"docClass\">android.graphics.Bitmap</a> with {@code Config}\n  <a href=\"#!/api/android.graphics.Bitmap.Config-property-HARDWARE\" rel=\"android.graphics.Bitmap.Config-property-HARDWARE\" class=\"docClass\">android.graphics.Bitmap.Config.HARDWARE</a> returned by <a href=\"#!/api/android.graphics.ImageDecoder\" rel=\"android.graphics.ImageDecoder\" class=\"docClass\">android.graphics.ImageDecoder</a>.</p></p>\n\n<p>  <p>On an AnimatedImageDrawable, the callback will only be called once,\n  but the drawing commands will be applied to each frame, as if the <a href=\"#!/api/android.graphics.Canvas\" rel=\"android.graphics.Canvas\" class=\"docClass\">android.graphics.Canvas</a>\n  had been returned by <a href=\"#!/api/android.graphics.Picture-method-beginRecording\" rel=\"android.graphics.Picture-method-beginRecording\" class=\"docClass\">android.graphics.Picture.beginRecording</a>.<p></p>\n\n<p>  <p>Supplied to ImageDecoder via <a href=\"#!/api/android.graphics.ImageDecoder-method-setPostProcessor\" rel=\"android.graphics.ImageDecoder-method-setPostProcessor\" class=\"docClass\">setPostProcessor</a>.</p></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-onPostProcess' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.graphics.PostProcessor'>android.graphics.PostProcessor</span><br/><a href='source/PostProcessor.html#android-graphics-PostProcessor-method-onPostProcess' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.graphics.PostProcessor-method-onPostProcess' class='name expandable'>onPostProcess</a>( <span class='pre'>canvas</span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Do any processing after (for example) decoding. ...</div><div class='long'><p>Do any processing after (for example) decoding.</p>\n\n<p>  <p>Drawing to the <a href=\"#!/api/android.graphics.Canvas\" rel=\"android.graphics.Canvas\" class=\"docClass\">android.graphics.Canvas</a> will behave as if the initial processing\n  (e.g. decoding) already exists in the Canvas. An implementation can draw\n  effects on top of this, or it can even draw behind it using\n  android.graphics.PorterDuff.Mode.DST_OVER. A common\n  effect is to add transparency to the corners to achieve rounded corners.\n  That can be done with the following code:</p></p>\n\n<p>  <pre class=\"prettyprint\">\n  Path path = new Path();\n  path.setFillType(Path.FillType.INVERSE_EVEN_ODD);\n  int width = canvas.getWidth();\n  int height = canvas.getHeight();\n  path.addRoundRect(0, 0, width, height, 20, 20, Path.Direction.CW);\n  Paint paint = new Paint();\n  paint.setAntiAlias(true);\n  paint.setColor(Color.TRANSPARENT);\n  paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));\n  canvas.drawPath(path, paint);\n  return PixelFormat.TRANSLUCENT;\n  </pre></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>canvas</span> : Object {Canvas}<div class='sub-desc'><p>The Canvas to draw to.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>Opacity of the result after drawing.\n      PixelFormat.UNKNOWN means that the\n      implementation did not change whether the image has alpha. Return\n      this unless you added transparency (e.g. with the code above, in\n      which case you should return\n      PixelFormat.TRANSLUCENT) or you\n      forced the image to be opaque (e.g. by drawing everywhere with an\n      opaque color and PorterDuff.Mode.DST_OVER,\n      in which case you should return PixelFormat.OPAQUE).\n      PixelFormat.TRANSLUCENT means that\n      the implementation added transparency. This is safe to return even\n      if the image already had transparency. This is also safe to return\n      if the result is opaque, though it may draw more slowly.\n      PixelFormat.OPAQUE means that the\n      implementation forced the image to be opaque. This is safe to return\n      even if the image was already opaque.\n      PixelFormat.TRANSPARENT (or any other\n      integer) is not allowed, and will result in throwing an\n      java.lang.IllegalArgumentException.</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});