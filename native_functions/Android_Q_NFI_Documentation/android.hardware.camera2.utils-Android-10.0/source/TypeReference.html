<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-hardware-camera2-utils-TypeReference'>/**@class android.hardware.camera2.utils.TypeReference
</span>@extends java.lang.Object

 Super type token; allows capturing generic types at runtime by forcing them to be reified.

 &lt;p&gt;Usage example: &lt;pre&gt;{@code
      // using anonymous classes (preferred)
      TypeReference&amp;lt;Integer&gt; intToken = new TypeReference&amp;lt;Integer&gt;() {{ }};

      // using named classes
      class IntTypeReference extends TypeReference&amp;lt;Integer&gt; {...}
      TypeReference&amp;lt;Integer&gt; intToken = new IntTypeReference();
 }&lt;/p&gt;&lt;/pre&gt;

 &lt;p&gt;Unlike the reference implementation, this bans nested TypeVariables; that is all
 dynamic types must equal to the static types.&lt;/p&gt;

 &lt;p&gt;See &lt;a href=&quot;http://gafter.blogspot.com/2007/05/limitation-of-super-type-tokens.html&quot;&gt;
 http://gafter.blogspot.com/2007/05/limitation-of-super-type-tokens.html&lt;/a&gt;
 for more details.&lt;/p&gt;
*/
var TypeReference = {

<span id='android-hardware-camera2-utils-TypeReference-method-getType'>/**Return the dynamic {@link Type} corresponding to the captured type {@code T}.
</span>*/
getType : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-createSpecializedTypeReference'>/**Create a specialized type reference from a dynamic class instance,
</span> bypassing the standard compile-time checks.

 &lt;p&gt;As with a regular type reference, the {@code klass} must not contain
 any type variables.&lt;/p&gt;
@param {Object {java.lang.Class}} klass a non-{@code null} {@link Class} instance
@return {Object {android.hardware.camera2.utils.TypeReference}} a type reference which captures {@code T} at runtime
@throws IllegalArgumentException if {@code T} had any type variables
*/
createSpecializedTypeReference : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-createSpecializedTypeReference'>/**Create a specialized type reference from a dynamic {@link Type} instance,
</span> bypassing the standard compile-time checks.

 &lt;p&gt;As with a regular type reference, the {@code type} must not contain
 any type variables.&lt;/p&gt;
@param {Object {Type}} type a non-{@code null} {@link Type} instance
@return {Object {android.hardware.camera2.utils.TypeReference}} a type reference which captures {@code T} at runtime
@throws IllegalArgumentException if {@code type} had any type variables
*/
createSpecializedTypeReference : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-getRawType'>/**Returns the raw type of T.
</span>
 &lt;p&gt;&lt;ul&gt;
 &lt;li&gt;If T is a Class itself, T itself is returned.
 &lt;li&gt;If T is a ParameterizedType, the raw type of the parameterized type is returned.
 &lt;li&gt;If T is a GenericArrayType, the returned type is the corresponding array class.
 For example: {@code List&lt;Integer&gt;[]} =&gt; {@code List[]}.
 &lt;li&gt;If T is a type variable or a wildcard type, the raw type of the first upper bound is
 returned. For example: {@code &lt;X extends Foo&gt;} =&gt; {@code Foo}.
 &lt;/ul&gt;
@return {Object {java.lang.Class}} the raw type of {@code T}
*/
getRawType : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-getComponentType'>/**Get the component type, e.g. {@code T} from {@code T[]}.
</span>@return {Object {android.hardware.camera2.utils.TypeReference}} component type, or {@code null} if {@code T} is not an array
*/
getComponentType : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-equals'>/**Compare two objects for equality.
</span>
 &lt;p&gt;A TypeReference is only equal to another TypeReference if their captured type {@code T}
 is also equal.&lt;/p&gt;
*/
equals : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-hashCode'>/**{@inheritDoc}
</span>*/
hashCode : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-containsTypeVariable'>/**Check if the {@code type} contains a {@link TypeVariable} recursively.
</span>
 &lt;p&gt;Intuitively, a type variable is a type in a type expression that refers to a generic
 type which is not known at the definition of the expression (commonly seen when
 type parameters are used, e.g. {@code class Foo&lt;T&gt;}).&lt;/p&gt;

 &lt;p&gt;See &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4&quot;&gt;
 http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4&lt;/a&gt;
 for a more formal definition of a type variable&lt;/p&gt;.
@param {Object {Type}} type a type object ({@code null} is allowed)
@return {Boolean} {@code true} if there were nested type variables; {@code false} otherwise
*/
containsTypeVariable : function(  ) {},

<span id='android-hardware-camera2-utils-TypeReference-method-toString'>/**{@inheritDoc}
</span>*/
toString : function(  ) {},


};</pre>
</body>
</html>
