<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-concurrent-atomic-LongAccumulator'>/**@class java.util.concurrent.atomic.LongAccumulator
</span> implements java.io.Serializable

@extends java.util.concurrent.atomic.Striped64

 One or more variables that together maintain a running {@code long}
 value updated using a supplied function.  When updates (method
 {@link #accumulate}) are contended across threads, the set of variables
 may grow dynamically to reduce contention.  Method {@link #get}
 (or, equivalently, {@link #longValue}) returns the current value
 across the variables maintaining updates.

 &lt;p&gt;This class is usually preferable to {@link java.util.concurrent.atomic.AtomicLong} when
 multiple threads update a common value that is used for purposes such
 as collecting statistics, not for fine-grained synchronization
 control.  Under low update contention, the two classes have similar
 characteristics. But under high contention, expected throughput of
 this class is significantly higher, at the expense of higher space
 consumption.

 &lt;p&gt;The order of accumulation within or across threads is not
 guaranteed and cannot be depended upon, so this class is only
 applicable to functions for which the order of accumulation does
 not matter. The supplied accumulator function should be
 side-effect-free, since it may be re-applied when attempted updates
 fail due to contention among threads. The function is applied with
 the current value as its first argument, and the given update as
 the second argument.  For example, to maintain a running maximum
 value, you could supply {@code Long::max} along with {@code
 Long.MIN_VALUE} as the identity.

 &lt;p&gt;Class {@link java.util.concurrent.atomic.LongAdder} provides analogs of the functionality of
 this class for the common special case of maintaining counts and
 sums.  The call {@code new LongAdder()} is equivalent to {@code new
 LongAccumulator((x, y) -&gt; x + y, 0L}.

 &lt;p&gt;This class extends {@link Number}, but does &lt;em&gt;not&lt;/em&gt; define
 methods such as {@code equals}, {@code hashCode} and {@code
 compareTo} because instances are expected to be mutated, and so are
 not useful as collection keys.

 @since 1.8
 @author Doug Lea
*/
var LongAccumulator = {

<span id='java-util-concurrent-atomic-LongAccumulator-method-accumulate'>/**Updates with the given value.
</span>@param {Number} x the value
*/
accumulate : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-get'>/**Returns the current value.  The returned value is &lt;em&gt;NOT&lt;/em&gt;
</span> an atomic snapshot; invocation in the absence of concurrent
 updates returns an accurate result, but concurrent updates that
 occur while the value is being calculated might not be
 incorporated.
@return {Number} the current value
*/
get : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-reset'>/**Resets variables maintaining updates to the identity value.
</span> This method may be a useful alternative to creating a new
 updater, but is only effective if there are no concurrent
 updates.  Because this method is intrinsically racy, it should
 only be used when it is known that no threads are concurrently
 updating.
*/
reset : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-getThenReset'>/**Equivalent in effect to {@link #get} followed by {@link #reset}. This method may apply for example during quiescent
</span> points between multithreaded computations.  If there are
 updates concurrent with this method, the returned value is
 &lt;em&gt;not&lt;/em&gt; guaranteed to be the final value occurring before
 the reset.
@return {Number} the value before reset
*/
getThenReset : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-toString'>/**Returns the String representation of the current value.
</span>@return {String} the String representation of the current value
*/
toString : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-longValue'>/**Equivalent to {@link #get}.
</span>@return {Number} the current value
*/
longValue : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-intValue'>/**Returns the {@linkplain #get current value} as an {@code int}
</span> after a narrowing primitive conversion.
*/
intValue : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-floatValue'>/**Returns the {@linkplain #get current value} as a {@code float}
</span> after a widening primitive conversion.
*/
floatValue : function(  ) {},

<span id='java-util-concurrent-atomic-LongAccumulator-method-doubleValue'>/**Returns the {@linkplain #get current value} as a {@code double}
</span> after a widening primitive conversion.
*/
doubleValue : function(  ) {},


};</pre>
</body>
</html>
