<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-os-storage-StorageManager'>/**@class android.os.storage.StorageManager
</span>@extends java.lang.Object

 StorageManager is the interface to the systems storage service. The storage
 manager handles storage-related items such as Opaque Binary Blobs (OBBs).
 &lt;p&gt;
 OBBs contain a filesystem that maybe be encrypted on disk and mounted
 on-demand from an application. OBBs are a good way of providing large amounts
 of binary assets without packaging them into APKs as they may be multiple
 gigabytes in size. However, due to their size, they're most likely stored in
 a shared storage pool accessible from all programs. The system does not
 guarantee the security of the OBB file itself: if any program modifies the
 OBB, there is no guarantee that a read from that OBB will produce the
 expected output.
*/
var StorageManager = {

<span id='android-os-storage-StorageManager-property-PROP_PRIMARY_PHYSICAL'>/**{@hide} */
</span>PROP_PRIMARY_PHYSICAL : &quot;ro.vold.primary_physical&quot;,
<span id='android-os-storage-StorageManager-property-PROP_HAS_ADOPTABLE'>/**{@hide} */
</span>PROP_HAS_ADOPTABLE : &quot;vold.has_adoptable&quot;,
<span id='android-os-storage-StorageManager-property-PROP_HAS_RESERVED'>/**{@hide} */
</span>PROP_HAS_RESERVED : &quot;vold.has_reserved&quot;,
<span id='android-os-storage-StorageManager-property-PROP_ADOPTABLE'>/**{@hide} */
</span>PROP_ADOPTABLE : &quot;persist.sys.adoptable&quot;,
<span id='android-os-storage-StorageManager-property-PROP_EMULATE_FBE'>/**{@hide} */
</span>PROP_EMULATE_FBE : &quot;persist.sys.emulate_fbe&quot;,
<span id='android-os-storage-StorageManager-property-PROP_SDCARDFS'>/**{@hide} */
</span>PROP_SDCARDFS : &quot;persist.sys.sdcardfs&quot;,
<span id='android-os-storage-StorageManager-property-PROP_VIRTUAL_DISK'>/**{@hide} */
</span>PROP_VIRTUAL_DISK : &quot;persist.sys.virtual_disk&quot;,
<span id='android-os-storage-StorageManager-property-PROP_ISOLATED_STORAGE'>/**{@hide} */
</span>PROP_ISOLATED_STORAGE : &quot;persist.sys.isolated_storage&quot;,
<span id='android-os-storage-StorageManager-property-PROP_ISOLATED_STORAGE_SNAPSHOT'>/**{@hide} */
</span>PROP_ISOLATED_STORAGE_SNAPSHOT : &quot;sys.isolated_storage_snapshot&quot;,
<span id='android-os-storage-StorageManager-property-UUID_PRIVATE_INTERNAL'>/**{@hide} */
</span>UUID_PRIVATE_INTERNAL : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-UUID_PRIMARY_PHYSICAL'>/**{@hide} */
</span>UUID_PRIMARY_PHYSICAL : &quot;primary_physical&quot;,
<span id='android-os-storage-StorageManager-property-UUID_SYSTEM'>/**{@hide} */
</span>UUID_SYSTEM : &quot;system&quot;,
<span id='android-os-storage-StorageManager-property-UUID_DEFAULT'>/** UUID representing the default internal storage of this device which
</span> provides {@link Environment#getDataDirectory()}.
 &lt;p&gt;
 This value is constant across all devices and it will never change, and
 thus it cannot be used to uniquely identify a particular physical device.

 @see #getUuidForPath(File)
 @see ApplicationInfo#storageUuid
*/
UUID_DEFAULT : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-UUID_PRIMARY_PHYSICAL_'>/**{@hide} */
</span>UUID_PRIMARY_PHYSICAL_ : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-UUID_SYSTEM_'>/**{@hide} */
</span>UUID_SYSTEM_ : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ACTION_MANAGE_STORAGE'>/** Activity Action: Allows the user to manage their storage. This activity
</span> provides the ability to free up space on the device by deleting data such
 as apps.
 &lt;p&gt;
 If the sending application has a specific storage device or allocation
 size in mind, they can optionally define {@link #EXTRA_UUID} or
 {@link #EXTRA_REQUESTED_BYTES}, respectively.
 &lt;p&gt;
 This intent should be launched using
 {@link Activity#startActivityForResult(Intent, int)} so that the user
 knows which app is requesting the storage space. The returned result will
 be {@link Activity#RESULT_OK} if the requested space was made available,
 or {@link Activity#RESULT_CANCELED} otherwise.
*/
ACTION_MANAGE_STORAGE : &quot;android.os.storage.action.MANAGE_STORAGE&quot;,
<span id='android-os-storage-StorageManager-property-EXTRA_UUID'>/** Extra {@link UUID} used to indicate the storage volume where an
</span> application is interested in allocating or managing disk space.

 @see #ACTION_MANAGE_STORAGE
 @see #UUID_DEFAULT
 @see #getUuidForPath(File)
 @see Intent#putExtra(String, java.io.Serializable)
*/
EXTRA_UUID : &quot;android.os.storage.extra.UUID&quot;,
<span id='android-os-storage-StorageManager-property-EXTRA_REQUESTED_BYTES'>/** Extra used to indicate the total size (in bytes) that an application is
</span> interested in allocating.
 &lt;p&gt;
 When defined, the management UI will help guide the user to free up
 enough disk space to reach this requested value.

 @see #ACTION_MANAGE_STORAGE
*/
EXTRA_REQUESTED_BYTES : &quot;android.os.storage.extra.REQUESTED_BYTES&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_ADOPTABLE_FORCE_ON'>/**{@hide} */
</span>DEBUG_ADOPTABLE_FORCE_ON : &quot;1&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_ADOPTABLE_FORCE_OFF'>/**{@hide} */
</span>DEBUG_ADOPTABLE_FORCE_OFF : &quot;2&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_EMULATE_FBE'>/**{@hide} */
</span>DEBUG_EMULATE_FBE : &quot;4&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_SDCARDFS_FORCE_ON'>/**{@hide} */
</span>DEBUG_SDCARDFS_FORCE_ON : &quot;8&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_SDCARDFS_FORCE_OFF'>/**{@hide} */
</span>DEBUG_SDCARDFS_FORCE_OFF : &quot;16&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_VIRTUAL_DISK'>/**{@hide} */
</span>DEBUG_VIRTUAL_DISK : &quot;32&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_ISOLATED_STORAGE_FORCE_ON'>/**{@hide} */
</span>DEBUG_ISOLATED_STORAGE_FORCE_ON : &quot;64&quot;,
<span id='android-os-storage-StorageManager-property-DEBUG_ISOLATED_STORAGE_FORCE_OFF'>/**{@hide} */
</span>DEBUG_ISOLATED_STORAGE_FORCE_OFF : &quot;128&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_STORAGE_DE'>/**{@hide} */
</span>FLAG_STORAGE_DE : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_STORAGE_CE'>/**{@hide} */
</span>FLAG_STORAGE_CE : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_STORAGE_EXTERNAL'>/**{@hide} */
</span>FLAG_STORAGE_EXTERNAL : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_FOR_WRITE'>/**{@hide} */
</span>FLAG_FOR_WRITE : &quot;256&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_REAL_STATE'>/**{@hide} */
</span>FLAG_REAL_STATE : &quot;512&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_INCLUDE_INVISIBLE'>/**{@hide} */
</span>FLAG_INCLUDE_INVISIBLE : &quot;1024&quot;,
<span id='android-os-storage-StorageManager-property-FSTRIM_FLAG_DEEP'>/**{@hide} */
</span>FSTRIM_FLAG_DEEP : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ENCRYPTION_STATE_NONE'>/**@hide The volume is not encrypted. */
</span>ENCRYPTION_STATE_NONE : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ENCRYPTION_STATE_OK'>/**@hide The volume has been encrypted succesfully. */
</span>ENCRYPTION_STATE_OK : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ENCRYPTION_STATE_ERROR_UNKNOWN'>/**@hide The volume is in a bad state. */
</span>ENCRYPTION_STATE_ERROR_UNKNOWN : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ENCRYPTION_STATE_ERROR_INCOMPLETE'>/**@hide Encryption is incomplete */
</span>ENCRYPTION_STATE_ERROR_INCOMPLETE : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ENCRYPTION_STATE_ERROR_INCONSISTENT'>/**@hide Encryption is incomplete and irrecoverable */
</span>ENCRYPTION_STATE_ERROR_INCONSISTENT : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-ENCRYPTION_STATE_ERROR_CORRUPT'>/**@hide Underlying data is corrupt */
</span>ENCRYPTION_STATE_ERROR_CORRUPT : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_ALLOCATE_AGGRESSIVE'>/** Flag indicating that a disk space allocation request should operate in an
</span> aggressive mode. This flag should only be rarely used in situations that
 are critical to system health or security.
 &lt;p&gt;
 When set, the system is more aggressive about the data that it considers
 for possible deletion when allocating disk space.
 &lt;p class=&quot;note&quot;&gt;
 Note: your app must hold the
 {@link android.Manifest.permission#ALLOCATE_AGGRESSIVE} permission for
 this flag to take effect.
 &lt;/p&gt;

 @see #getAllocatableBytes(UUID, int)
 @see #allocateBytes(UUID, long, int)
 @see #allocateBytes(FileDescriptor, long, int)
 @hide
*/
FLAG_ALLOCATE_AGGRESSIVE : &quot;1&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_ALLOCATE_DEFY_ALL_RESERVED'>/** Flag indicating that a disk space allocation request should be allowed to
</span> clear up to all reserved disk space.

 @hide
*/
FLAG_ALLOCATE_DEFY_ALL_RESERVED : &quot;2&quot;,
<span id='android-os-storage-StorageManager-property-FLAG_ALLOCATE_DEFY_HALF_RESERVED'>/** Flag indicating that a disk space allocation request should be allowed to
</span> clear up to half of all reserved disk space.

 @hide
*/
FLAG_ALLOCATE_DEFY_HALF_RESERVED : &quot;4&quot;,
<span id='android-os-storage-StorageManager-property-CRYPT_TYPE_PASSWORD'>/**@hide */
</span>CRYPT_TYPE_PASSWORD : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-CRYPT_TYPE_DEFAULT'>/**@hide */
</span>CRYPT_TYPE_DEFAULT : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-CRYPT_TYPE_PATTERN'>/**@hide */
</span>CRYPT_TYPE_PATTERN : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-CRYPT_TYPE_PIN'>/**@hide */
</span>CRYPT_TYPE_PIN : &quot;null&quot;,
<span id='android-os-storage-StorageManager-property-SYSTEM_LOCALE_KEY'>/**@hide */
</span>SYSTEM_LOCALE_KEY : &quot;SystemLocale&quot;,
<span id='android-os-storage-StorageManager-property-OWNER_INFO_KEY'>/**@hide */
</span>OWNER_INFO_KEY : &quot;OwnerInfo&quot;,
<span id='android-os-storage-StorageManager-property-PATTERN_VISIBLE_KEY'>/**@hide */
</span>PATTERN_VISIBLE_KEY : &quot;PatternVisible&quot;,
<span id='android-os-storage-StorageManager-property-PASSWORD_VISIBLE_KEY'>/**@hide */
</span>PASSWORD_VISIBLE_KEY : &quot;PasswordVisible&quot;,
<span id='android-os-storage-StorageManager-method-from'>/**{@hide}
</span>*/
from : function(  ) {},

<span id='android-os-storage-StorageManager-method-registerListener'>/**Registers a {@link android.os.storage.StorageEventListener StorageEventListener}.
</span>@param {Object {StorageEventListener}} listener A {@link android.os.storage.StorageEventListener StorageEventListener} object.
@hide 
*/
registerListener : function(  ) {},

<span id='android-os-storage-StorageManager-method-unregisterListener'>/**Unregisters a {@link android.os.storage.StorageEventListener StorageEventListener}.
</span>@param {Object {StorageEventListener}} listener A {@link android.os.storage.StorageEventListener StorageEventListener} object.
@hide 
*/
unregisterListener : function(  ) {},

<span id='android-os-storage-StorageManager-method-enableUsbMassStorage'>/**Enables USB Mass Storage (UMS) on the device.
</span>@hide 
*/
enableUsbMassStorage : function(  ) {},

<span id='android-os-storage-StorageManager-method-disableUsbMassStorage'>/**Disables USB Mass Storage (UMS) on the device.
</span>@hide 
*/
disableUsbMassStorage : function(  ) {},

<span id='android-os-storage-StorageManager-method-isUsbMassStorageConnected'>/**Query if a USB Mass Storage (UMS) host is connected.
</span>@return {Boolean} true if UMS host is connected.
@hide 
*/
isUsbMassStorageConnected : function(  ) {},

<span id='android-os-storage-StorageManager-method-isUsbMassStorageEnabled'>/**Query if a USB Mass Storage (UMS) is enabled on the device.
</span>@return {Boolean} true if UMS host is enabled.
@hide 
*/
isUsbMassStorageEnabled : function(  ) {},

<span id='android-os-storage-StorageManager-method-mountObb'>/**Mount an Opaque Binary Blob (OBB) file. If a &lt;code&gt;key&lt;/code&gt; is
</span> specified, it is supplied to the mounting process to be used in any
 encryption used in the OBB.
 &lt;p&gt;
 The OBB will remain mounted for as long as the StorageManager reference
 is held by the application. As soon as this reference is lost, the OBBs
 in use will be unmounted. The {@link android.os.storage.OnObbStateChangeListener} registered
 with this call will receive the success or failure of this operation.
 &lt;p&gt;
 &lt;em&gt;Note:&lt;/em&gt; you can only mount OBB files for which the OBB tag on the
 file matches a package ID that is owned by the calling program's UID.
 That is, shared UID applications can attempt to mount any other
 application's OBB that shares its UID.
@param {String} rawPath the path to the OBB file
@param {String} key secret used to encrypt the OBB; may be &lt;code&gt;null&lt;/code&gt; if no
            encryption was used on the OBB.
@param {Object {OnObbStateChangeListener}} listener will receive the success or failure of the operation
@return {Boolean} whether the mount call was successfully queued or not
*/
mountObb : function(  ) {},

<span id='android-os-storage-StorageManager-method-unmountObb'>/**Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
</span> &lt;code&gt;force&lt;/code&gt; flag is true, it will kill any application needed to
 unmount the given OBB (even the calling application).
 &lt;p&gt;
 The {@link android.os.storage.OnObbStateChangeListener} registered with this call will
 receive the success or failure of this operation.
 &lt;p&gt;
 &lt;em&gt;Note:&lt;/em&gt; you can only mount OBB files for which the OBB tag on the
 file matches a package ID that is owned by the calling program's UID.
 That is, shared UID applications can obtain access to any other
 application's OBB that shares its UID.
 &lt;p&gt;
@param {String} rawPath path to the OBB file
@param {Boolean} force whether to kill any programs using this in order to unmount
            it
@param {Object {OnObbStateChangeListener}} listener will receive the success or failure of the operation
@return {Boolean} whether the unmount call was successfully queued or not
*/
unmountObb : function(  ) {},

<span id='android-os-storage-StorageManager-method-isObbMounted'>/**Check whether an Opaque Binary Blob (OBB) is mounted or not.
</span>@param {String} rawPath path to OBB image
@return {Boolean} true if OBB is mounted; false if not mounted or on error
*/
isObbMounted : function(  ) {},

<span id='android-os-storage-StorageManager-method-getMountedObbPath'>/**Check the mounted path of an Opaque Binary Blob (OBB) file. This will
</span> give you the path to where you can obtain access to the internals of the
 OBB.
@param {String} rawPath path to OBB image
@return {String} absolute path to mounted OBB image data or &lt;code&gt;null&lt;/code&gt; if
         not mounted or exception encountered trying to read status
*/
getMountedObbPath : function(  ) {},

<span id='android-os-storage-StorageManager-method-getDisks'>/**{@hide}
</span>*/
getDisks : function(  ) {},

<span id='android-os-storage-StorageManager-method-findDiskById'>/**{@hide}
</span>*/
findDiskById : function(  ) {},

<span id='android-os-storage-StorageManager-method-findVolumeById'>/**{@hide}
</span>*/
findVolumeById : function(  ) {},

<span id='android-os-storage-StorageManager-method-findVolumeByUuid'>/**{@hide}
</span>*/
findVolumeByUuid : function(  ) {},

<span id='android-os-storage-StorageManager-method-findRecordByUuid'>/**{@hide}
</span>*/
findRecordByUuid : function(  ) {},

<span id='android-os-storage-StorageManager-method-findPrivateForEmulated'>/**{@hide}
</span>*/
findPrivateForEmulated : function(  ) {},

<span id='android-os-storage-StorageManager-method-findEmulatedForPrivate'>/**{@hide}
</span>*/
findEmulatedForPrivate : function(  ) {},

<span id='android-os-storage-StorageManager-method-findVolumeByQualifiedUuid'>/**{@hide}
</span>*/
findVolumeByQualifiedUuid : function(  ) {},

<span id='android-os-storage-StorageManager-method-getUuidForPath'>/**Return a UUID identifying the storage volume that hosts the given
</span> filesystem path.
 &lt;p&gt;
 If this path is hosted by the default internal storage of the device at
 {@link Environment#getDataDirectory()}, the returned value will be
 {@link #UUID_DEFAULT}.
@throws IOException when the storage device hosting the given path isn't
             present, or when it doesn't have a valid UUID.
*/
getUuidForPath : function(  ) {},

<span id='android-os-storage-StorageManager-method-findPathForUuid'>/**{@hide}
</span>*/
findPathForUuid : function(  ) {},

<span id='android-os-storage-StorageManager-method-isAllocationSupported'>/**Test if the given file descriptor supports allocation of disk space using
</span> {@link #allocateBytes(FileDescriptor, long)}.
*/
isAllocationSupported : function(  ) {},

<span id='android-os-storage-StorageManager-method-getVolumes'>/**{@hide}
</span>*/
getVolumes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getWritablePrivateVolumes'>/**{@hide}
</span>*/
getWritablePrivateVolumes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getVolumeRecords'>/**{@hide}
</span>*/
getVolumeRecords : function(  ) {},

<span id='android-os-storage-StorageManager-method-getBestVolumeDescription'>/**{@hide}
</span>*/
getBestVolumeDescription : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryPhysicalVolume'>/**{@hide}
</span>*/
getPrimaryPhysicalVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-mount'>/**{@hide}
</span>*/
mount : function(  ) {},

<span id='android-os-storage-StorageManager-method-unmount'>/**{@hide}
</span>*/
unmount : function(  ) {},

<span id='android-os-storage-StorageManager-method-format'>/**{@hide}
</span>*/
format : function(  ) {},

<span id='android-os-storage-StorageManager-method-benchmark'>/**{@hide}
</span>*/
benchmark : function(  ) {},

<span id='android-os-storage-StorageManager-method-benchmark'>/**{@hide}
</span>*/
benchmark : function(  ) {},

<span id='android-os-storage-StorageManager-method-partitionPublic'>/**{@hide}
</span>*/
partitionPublic : function(  ) {},

<span id='android-os-storage-StorageManager-method-partitionPrivate'>/**{@hide}
</span>*/
partitionPrivate : function(  ) {},

<span id='android-os-storage-StorageManager-method-partitionMixed'>/**{@hide}
</span>*/
partitionMixed : function(  ) {},

<span id='android-os-storage-StorageManager-method-wipeAdoptableDisks'>/**{@hide}
</span>*/
wipeAdoptableDisks : function(  ) {},

<span id='android-os-storage-StorageManager-method-setVolumeNickname'>/**{@hide}
</span>*/
setVolumeNickname : function(  ) {},

<span id='android-os-storage-StorageManager-method-setVolumeInited'>/**{@hide}
</span>*/
setVolumeInited : function(  ) {},

<span id='android-os-storage-StorageManager-method-setVolumeSnoozed'>/**{@hide}
</span>*/
setVolumeSnoozed : function(  ) {},

<span id='android-os-storage-StorageManager-method-forgetVolume'>/**{@hide}
</span>*/
forgetVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryStorageUuid'>/**This is not the API you're looking for.
</span>@see PackageManager#getPrimaryStorageCurrentVolume()
@hide 
*/
getPrimaryStorageUuid : function(  ) {},

<span id='android-os-storage-StorageManager-method-setPrimaryStorageUuid'>/**This is not the API you're looking for.
</span>@see PackageManager#movePrimaryStorage(VolumeInfo)
@hide 
*/
setPrimaryStorageUuid : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageVolume'>/**Return the {@link android.os.storage.StorageVolume} that contains the given file, or
</span> {@code null} if none.
*/
getStorageVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageVolume'>/**Return the {@link android.os.storage.StorageVolume} that contains the given
</span> {@link MediaStore} item.
*/
getStorageVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageVolume'>/**{@hide}
</span>*/
getStorageVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getVolumeState'>/**Gets the state of a volume via its mountpoint.
</span>@hide 
*/
getVolumeState : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageVolumes'>/**Return the list of shared/external storage volumes available to the
</span> current user. This includes both the primary shared storage device and
 any attached external volumes including SD cards and USB drives.
@see Environment#getExternalStorageDirectory()
@see StorageVolume#createAccessIntent(String)
*/
getStorageVolumes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryStorageVolume'>/**Return the primary shared/external storage volume available to the
</span> current user. This volume is the same storage device returned by
 {@link Environment#getExternalStorageDirectory()} and
 {@link Context#getExternalFilesDir(String)}.
*/
getPrimaryStorageVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryStoragePathAndSize'>/**{@hide}
</span>*/
getPrimaryStoragePathAndSize : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryStorageSize'>/**{@hide}
</span>*/
getPrimaryStorageSize : function(  ) {},

<span id='android-os-storage-StorageManager-method-mkdirs'>/**{@hide}
</span>*/
mkdirs : function(  ) {},

<span id='android-os-storage-StorageManager-method-getVolumeList'>/**
</span>@removed 
*/
getVolumeList : function(  ) {},

<span id='android-os-storage-StorageManager-method-getVolumeList'>/**{@hide}
</span>*/
getVolumeList : function(  ) {},

<span id='android-os-storage-StorageManager-method-getVolumePaths'>/**Returns list of paths for all mountable volumes.
</span>@hide 
*/
getVolumePaths : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryVolume'>/**
</span>@removed 
*/
getPrimaryVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getPrimaryVolume'>/**{@hide}
</span>*/
getPrimaryVolume : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageBytesUntilLow'>/**Return the number of available bytes until the given path is considered
</span> running low on storage.
@hide 
*/
getStorageBytesUntilLow : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageLowBytes'>/**Return the number of available bytes at which the given path is
</span> considered running low on storage.
@hide 
*/
getStorageLowBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageCacheBytes'>/**Return the minimum number of bytes of storage on the device that should
</span> be reserved for cached data.
@hide 
*/
getStorageCacheBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getStorageFullBytes'>/**Return the number of available bytes at which the given path is
</span> considered full.
@hide 
*/
getStorageFullBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-createUserKey'>/**{@hide}
</span>*/
createUserKey : function(  ) {},

<span id='android-os-storage-StorageManager-method-destroyUserKey'>/**{@hide}
</span>*/
destroyUserKey : function(  ) {},

<span id='android-os-storage-StorageManager-method-unlockUserKey'>/**{@hide}
</span>*/
unlockUserKey : function(  ) {},

<span id='android-os-storage-StorageManager-method-lockUserKey'>/**{@hide}
</span>*/
lockUserKey : function(  ) {},

<span id='android-os-storage-StorageManager-method-prepareUserStorage'>/**{@hide}
</span>*/
prepareUserStorage : function(  ) {},

<span id='android-os-storage-StorageManager-method-destroyUserStorage'>/**{@hide}
</span>*/
destroyUserStorage : function(  ) {},

<span id='android-os-storage-StorageManager-method-isUserKeyUnlocked'>/**{@hide}
</span>*/
isUserKeyUnlocked : function(  ) {},

<span id='android-os-storage-StorageManager-method-isEncrypted'>/**Return if data stored at or under the given path will be encrypted while
</span> at rest. This can help apps avoid the overhead of double-encrypting data.
*/
isEncrypted : function(  ) {},

<span id='android-os-storage-StorageManager-method-isEncryptable'>/**{@hide}
</span> Is this device encryptable or already encrypted?
@return {Boolean} true for encryptable or encrypted
         false not encrypted and not encryptable
*/
isEncryptable : function(  ) {},

<span id='android-os-storage-StorageManager-method-isEncrypted'>/**{@hide}
</span> Is this device already encrypted?
@return {Boolean} true for encrypted. (Implies isEncryptable() == true)
         false not encrypted
*/
isEncrypted : function(  ) {},

<span id='android-os-storage-StorageManager-method-isFileEncryptedNativeOnly'>/**{@hide}
</span> Is this device file encrypted?
@return {Boolean} true for file encrypted. (Implies isEncrypted() == true)
         false not encrypted or block encrypted
*/
isFileEncryptedNativeOnly : function(  ) {},

<span id='android-os-storage-StorageManager-method-isBlockEncrypted'>/**{@hide}
</span> Is this device block encrypted?
@return {Boolean} true for block encrypted. (Implies isEncrypted() == true)
         false not encrypted or file encrypted
*/
isBlockEncrypted : function(  ) {},

<span id='android-os-storage-StorageManager-method-isNonDefaultBlockEncrypted'>/**{@hide}
</span> Is this device block encrypted with credentials?
@return {Boolean} true for crediential block encrypted.
         (Implies isBlockEncrypted() == true)
         false not encrypted, file encrypted or default block encrypted
*/
isNonDefaultBlockEncrypted : function(  ) {},

<span id='android-os-storage-StorageManager-method-isBlockEncrypting'>/**{@hide}
</span> Is this device in the process of being block encrypted?
@return {Boolean} true for encrypting.
         false otherwise
 Whether device isEncrypted at this point is undefined
 Note that only system services and CryptKeeper will ever see this return
 true - no app will ever be launched in this state.
 Also note that this state will not change without a teardown of the
 framework, so no service needs to check for changes during their lifespan
*/
isBlockEncrypting : function(  ) {},

<span id='android-os-storage-StorageManager-method-inCryptKeeperBounce'>/**{@hide}
</span> Is this device non default block encrypted and in the process of
 prompting for credentials?
@return {Boolean} true for prompting for credentials.
         (Implies isNonDefaultBlockEncrypted() == true)
         false otherwise
 Note that only system services and CryptKeeper will ever see this return
 true - no app will ever be launched in this state.
 Also note that this state will not change without a teardown of the
 framework, so no service needs to check for changes during their lifespan
*/
inCryptKeeperBounce : function(  ) {},

<span id='android-os-storage-StorageManager-method-isFileEncryptedEmulatedOnly'>/**{@hide}
</span>*/
isFileEncryptedEmulatedOnly : function(  ) {},

<span id='android-os-storage-StorageManager-method-isFileEncryptedNativeOrEmulated'>/**{@hide}
</span> Is this device running in a file encrypted mode, either native or emulated?
@return {Boolean} true for file encrypted, false otherwise
*/
isFileEncryptedNativeOrEmulated : function(  ) {},

<span id='android-os-storage-StorageManager-method-hasAdoptable'>/**{@hide}
</span>*/
hasAdoptable : function(  ) {},

<span id='android-os-storage-StorageManager-method-hasIsolatedStorage'>/**Return if the currently booted device has the &quot;isolated storage&quot; feature
</span> flag enabled. This will eventually be fully enabled in the final
 {@link android.os.Build.VERSION_CODES#Q} release.
@hide 
*/
hasIsolatedStorage : function(  ) {},

<span id='android-os-storage-StorageManager-method-maybeTranslateEmulatedPathToInternal'>/**
</span>@deprecated disabled now that FUSE has been replaced by sdcardfs
@hide 
*/
maybeTranslateEmulatedPathToInternal : function(  ) {},

<span id='android-os-storage-StorageManager-method-translateAppToSystem'>/**Translate given shared storage path from a path in an app sandbox
</span> namespace to a path in the system namespace.
@hide 
*/
translateAppToSystem : function(  ) {},

<span id='android-os-storage-StorageManager-method-translateSystemToApp'>/**Translate given shared storage path from a path in the system namespace
</span> to a path in an app sandbox namespace.
@hide 
*/
translateSystemToApp : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionAndAppOp'>/**Check that given app holds both permission and appop.
</span>@hide 
*/
checkPermissionAndAppOp : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionAndCheckOp'>/**Check that given app holds both permission and appop but do not noteOp.
</span>@hide 
*/
checkPermissionAndCheckOp : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionReadAudio'>/**{@hide}
</span>*/
checkPermissionReadAudio : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionWriteAudio'>/**{@hide}
</span>*/
checkPermissionWriteAudio : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionReadVideo'>/**{@hide}
</span>*/
checkPermissionReadVideo : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionWriteVideo'>/**{@hide}
</span>*/
checkPermissionWriteVideo : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionReadImages'>/**{@hide}
</span>*/
checkPermissionReadImages : function(  ) {},

<span id='android-os-storage-StorageManager-method-checkPermissionWriteImages'>/**{@hide}
</span>*/
checkPermissionWriteImages : function(  ) {},

<span id='android-os-storage-StorageManager-method-openProxyFileDescriptor'>/**{@hide}
</span>*/
openProxyFileDescriptor : function(  ) {},

<span id='android-os-storage-StorageManager-method-openProxyFileDescriptor'>/**{@hide}
</span>*/
openProxyFileDescriptor : function(  ) {},

<span id='android-os-storage-StorageManager-method-openProxyFileDescriptor'>/**Opens a seekable {@link ParcelFileDescriptor} that proxies all low-level
</span> I/O requests back to the given {@link ProxyFileDescriptorCallback}.
 &lt;p&gt;
 This can be useful when you want to provide quick access to a large file
 that isn't backed by a real file on disk, such as a file on a network
 share, cloud storage service, etc. As an example, you could respond to a
 {@link ContentResolver#openFileDescriptor(android.net.Uri, String)}
 request by returning a {@link ParcelFileDescriptor} created with this
 method, and then stream the content on-demand as requested.
 &lt;p&gt;
 Another useful example might be where you have an encrypted file that
 you're willing to decrypt on-demand, but where you want to avoid
 persisting the cleartext version.
@param {Number} mode The desired access mode, must be one of
            {@link ParcelFileDescriptor#MODE_READ_ONLY},
            {@link ParcelFileDescriptor#MODE_WRITE_ONLY}, or
            {@link ParcelFileDescriptor#MODE_READ_WRITE}
@param {Object {ProxyFileDescriptorCallback}} callback Callback to process file operation requests issued on
            returned file descriptor.
@param {Object {Handler}} handler Handler that invokes callback methods.
@return {Object {android.os.ParcelFileDescriptor}} Seekable ParcelFileDescriptor.
@throws IOException
*/
openProxyFileDescriptor : function(  ) {},

<span id='android-os-storage-StorageManager-method-getProxyFileDescriptorMountPointId'>/**{@hide}
</span>*/
getProxyFileDescriptorMountPointId : function(  ) {},

<span id='android-os-storage-StorageManager-method-getCacheQuotaBytes'>/**Return quota size in bytes for all cached data belonging to the calling
</span> app on the given storage volume.
 &lt;p&gt;
 If your app goes above this quota, your cached files will be some of the
 first to be deleted when additional disk space is needed. Conversely, if
 your app stays under this quota, your cached files will be some of the
 last to be deleted when additional disk space is needed.
 &lt;p&gt;
 This quota will change over time depending on how frequently the user
 interacts with your app, and depending on how much system-wide disk space
 is used.
 &lt;p class=&quot;note&quot;&gt;
 Note: if your app uses the {@code android:sharedUserId} manifest feature,
 then cached data for all packages in your shared UID is tracked together
 as a single unit.
 &lt;/p&gt;
@param {Object {UUID}} storageUuid the UUID of the storage volume that you're interested
            in. The UUID for a specific path can be obtained using
            {@link #getUuidForPath(File)}.
@throws IOException when the storage device isn't present, or when it
             doesn't support cache quotas.
@see #getCacheSizeBytes(UUID)
*/
getCacheQuotaBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getCacheSizeBytes'>/**Return total size in bytes of all cached data belonging to the calling
</span> app on the given storage volume.
 &lt;p&gt;
 Cached data tracked by this method always includes
 {@link Context#getCacheDir()} and {@link Context#getCodeCacheDir()}, and
 it also includes {@link Context#getExternalCacheDir()} if the primary
 shared/external storage is hosted on the same storage device as your
 private data.
 &lt;p class=&quot;note&quot;&gt;
 Note: if your app uses the {@code android:sharedUserId} manifest feature,
 then cached data for all packages in your shared UID is tracked together
 as a single unit.
 &lt;/p&gt;
@param {Object {UUID}} storageUuid the UUID of the storage volume that you're interested
            in. The UUID for a specific path can be obtained using
            {@link #getUuidForPath(File)}.
@throws IOException when the storage device isn't present, or when it
             doesn't support cache quotas.
@see #getCacheQuotaBytes(UUID)
*/
getCacheSizeBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getAllocatableBytes'>/**Return the maximum number of new bytes that your app can allocate for
</span> itself on the given storage volume. This value is typically larger than
 {@link File#getUsableSpace()}, since the system may be willing to delete
 cached files to satisfy an allocation request. You can then allocate
 space for yourself using {@link #allocateBytes(UUID, long)} or
 {@link #allocateBytes(FileDescriptor, long)}.
 &lt;p&gt;
 This method is best used as a pre-flight check, such as deciding if there
 is enough space to store an entire music album before you allocate space
 for each audio file in the album. Attempts to allocate disk space beyond
 the returned value will fail.
 &lt;p&gt;
 If the returned value is not large enough for the data you'd like to
 persist, you can launch {@link #ACTION_MANAGE_STORAGE} with the
 {@link #EXTRA_UUID} and {@link #EXTRA_REQUESTED_BYTES} options to help
 involve the user in freeing up disk space.
 &lt;p&gt;
 If you're progressively allocating an unbounded amount of storage space
 (such as when recording a video) you should avoid calling this method
 more than once every 30 seconds.
 &lt;p class=&quot;note&quot;&gt;
 Note: if your app uses the {@code android:sharedUserId} manifest feature,
 then allocatable space for all packages in your shared UID is tracked
 together as a single unit.
 &lt;/p&gt;
@param {Object {UUID}} storageUuid the UUID of the storage volume where you're
            considering allocating disk space, since allocatable space can
            vary widely depending on the underlying storage device. The
            UUID for a specific path can be obtained using
            {@link #getUuidForPath(File)}.
@return {Number} the maximum number of new bytes that the calling app can allocate
         using {@link #allocateBytes(UUID, long)} or
         {@link #allocateBytes(FileDescriptor, long)}.
@throws IOException when the storage device isn't present, or when it
             doesn't support allocating space.
*/
getAllocatableBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-getAllocatableBytes'>/**
</span>@hide 
*/
getAllocatableBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-allocateBytes'>/**Allocate the requested number of bytes for your application to use on the
</span> given storage volume. This will cause the system to delete any cached
 files necessary to satisfy your request.
 &lt;p&gt;
 Attempts to allocate disk space beyond the value returned by
 {@link #getAllocatableBytes}(UUID) will fail.
 &lt;p&gt;
 Since multiple apps can be running simultaneously, this method may be
 subject to race conditions. If possible, consider using
 {@link #allocateBytes(FileDescriptor, long)} which will guarantee
 that bytes are allocated to an opened file.
 &lt;p&gt;
 If you're progressively allocating an unbounded amount of storage space
 (such as when recording a video) you should avoid calling this method
 more than once every 60 seconds.
@param {Object {UUID}} storageUuid the UUID of the storage volume where you'd like to
            allocate disk space. The UUID for a specific path can be
            obtained using {@link #getUuidForPath(File)}.
@param {Number} bytes the number of bytes to allocate.
@throws IOException when the storage device isn't present, or when it
             doesn't support allocating space, or if the device had
             trouble allocating the requested space.
@see #getAllocatableBytes(UUID)
*/
allocateBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-allocateBytes'>/**
</span>@hide 
*/
allocateBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-allocateBytes'>/**Allocate the requested number of bytes for your application to use in the
</span> given open file. This will cause the system to delete any cached files
 necessary to satisfy your request.
 &lt;p&gt;
 Attempts to allocate disk space beyond the value returned by
 {@link #getAllocatableBytes}(UUID) will fail.
 &lt;p&gt;
 This method guarantees that bytes have been allocated to the opened file,
 otherwise it will throw if fast allocation is not possible. Fast
 allocation is typically only supported in private app data directories,
 and on shared/external storage devices which are emulated.
 &lt;p&gt;
 If you're progressively allocating an unbounded amount of storage space
 (such as when recording a video) you should avoid calling this method
 more than once every 60 seconds.
@param {Object {FileDescriptor}} fd the open file that you'd like to allocate disk space for.
@param {Number} bytes the number of bytes to allocate. This is the desired final
            size of the open file. If the open file is smaller than this
            requested size, it will be extended without modifying any
            existing contents. If the open file is larger than this
            requested size, it will be truncated.
@throws IOException when the storage device isn't present, or when it
             doesn't support allocating space, or if the device had
             trouble allocating the requested space.
@see #isAllocationSupported(FileDescriptor)
@see Environment#isExternalStorageEmulated(File)
*/
allocateBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-allocateBytes'>/**
</span>@hide 
*/
allocateBytes : function(  ) {},

<span id='android-os-storage-StorageManager-method-setCacheBehaviorGroup'>/**Enable or disable special cache behavior that treats this directory and
</span> its contents as an entire group.
 &lt;p&gt;
 When enabled and this directory is considered for automatic deletion by
 the OS, all contained files will either be deleted together, or not at
 all. This is useful when you have a directory that contains several
 related metadata files that depend on each other, such as movie file and
 a subtitle file.
 &lt;p&gt;
 When enabled, the &lt;em&gt;newest&lt;/em&gt; {@link File#lastModified()} value of
 any contained files is considered the modified time of the entire
 directory.
 &lt;p&gt;
 This behavior can only be set on a directory, and it applies recursively
 to all contained files and directories.
*/
setCacheBehaviorGroup : function(  ) {},

<span id='android-os-storage-StorageManager-method-isCacheBehaviorGroup'>/**Read the current value set by
</span> {@link #setCacheBehaviorGroup(File, boolean)}.
*/
isCacheBehaviorGroup : function(  ) {},

<span id='android-os-storage-StorageManager-method-setCacheBehaviorTombstone'>/**Enable or disable special cache behavior that leaves deleted cache files
</span> intact as tombstones.
 &lt;p&gt;
 When enabled and a file contained in this directory is automatically
 deleted by the OS, the file will be truncated to have a length of 0 bytes
 instead of being fully deleted. This is useful if you need to distinguish
 between a file that was deleted versus one that never existed.
 &lt;p&gt;
 This behavior can only be set on a directory, and it applies recursively
 to all contained files and directories.
 &lt;p class=&quot;note&quot;&gt;
 Note: this behavior is ignored completely if the user explicitly requests
 that all cached data be cleared.
 &lt;/p&gt;
*/
setCacheBehaviorTombstone : function(  ) {},

<span id='android-os-storage-StorageManager-method-isCacheBehaviorTombstone'>/**Read the current value set by
</span> {@link #setCacheBehaviorTombstone(File, boolean)}.
*/
isCacheBehaviorTombstone : function(  ) {},

<span id='android-os-storage-StorageManager-method-convert'>/**{@hide}
</span>*/
convert : function(  ) {},

<span id='android-os-storage-StorageManager-method-convert'>/**{@hide}
</span>*/
convert : function(  ) {},


};</pre>
</body>
</html>
