<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-renderscript-ProgramFragment'>/**@class android.renderscript.ProgramFragment
</span>@extends android.renderscript.Program

 @hide
 @deprecated in API 16
 &lt;p&gt;The RenderScript fragment program, also known as fragment shader is responsible
 for manipulating pixel data in a user defined way. It's constructed from a GLSL
 shader string containing the program body, textures inputs, and a Type object
 that describes the constants used by the program. Similar to the vertex programs,
 when an allocation with constant input values is bound to the shader, its values
 are sent to the graphics program automatically.&lt;/p&gt;
 &lt;p&gt; The values inside the allocation are not explicitly tracked. If they change between two draw
 calls using the same program object, the runtime needs to be notified of that
 change by calling rsgAllocationSyncAll so it could send the new values to hardware.
 Communication between the vertex and fragment programs is handled internally in the
 GLSL code. For example, if the fragment program is expecting a varying input called
 varTex0, the GLSL code inside the program vertex must provide it.
 &lt;/p&gt;

*/
var ProgramFragment = {


};</pre>
</body>
</html>
