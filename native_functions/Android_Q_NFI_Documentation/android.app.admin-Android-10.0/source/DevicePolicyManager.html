<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-app-admin-DevicePolicyManager'>/**@class android.app.admin.DevicePolicyManager
</span>@extends java.lang.Object

 Public interface for managing policies enforced on a device. Most clients of this class must be
 registered with the system as a &lt;a href=&quot;{@docRoot}guide/topics/admin/device-admin.html&quot;&gt;device
 administrator&lt;/a&gt;. Additionally, a device administrator may be registered as either a profile or
 device owner. A given method is accessible to all device administrators unless the documentation
 for that method specifies that it is restricted to either device or profile owners. Any
 application calling an api may only pass as an argument a device administrator component it
 owns. Otherwise, a {@link SecurityException} will be thrown.
 &lt;div class=&quot;special reference&quot;&gt;
 &lt;h3&gt;Developer Guides&lt;/h3&gt;
 &lt;p&gt;
 For more information about managing policies for device administration, read the &lt;a href=
 &quot;{@docRoot}guide/topics/admin/device-admin.html&quot;&gt;Device Administration&lt;/a&gt; developer
 guide. &lt;/div&gt;
*/
var DevicePolicyManager = {

<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISION_MANAGED_PROFILE'>/** Activity action: Starts the provisioning flow which sets up a managed profile.
</span>
 &lt;p&gt;A managed profile allows data separation for example for the usage of a
 device as a personal and corporate device. The user which provisioning is started from and
 the managed profile share a launcher.

 &lt;p&gt;This intent will typically be sent by a mobile device management application (MDM).
 Provisioning adds a managed profile and sets the MDM as the profile owner who has full
 control over the profile.

 &lt;p&gt;It is possible to check if provisioning is allowed or not by querying the method
 {@link #isProvisioningAllowed}(String).

 &lt;p&gt;In version {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this intent must contain the
 extra {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}.
 As of {@link android.os.Build.VERSION_CODES#M}, it should contain the extra
 {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} instead, although specifying only
 {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} is still supported.

 &lt;p&gt;The intent may also contain the following extras:
 &lt;ul&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}, optional &lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional, supported from
 {@link android.os.Build.VERSION_CODES#N}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOGO_URI}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_USER_CONSENT}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DISCLAIMERS}, optional&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;When managed provisioning has completed, broadcasts are sent to the application specified
 in the provisioning intent. The
 {@link android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} broadcast is sent in the
 managed profile and the {@link #ACTION_MANAGED_PROFILE_PROVISIONED} broadcast is sent in
 the primary profile.

 &lt;p&gt;From version {@link android.os.Build.VERSION_CODES#O}, when managed provisioning has
 completed, along with the above broadcast, activity intent
 {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the profile owner.

 &lt;p&gt;If provisioning fails, the managedProfile is removed so the device returns to its
 previous state.

 &lt;p&gt;If launched with {@link android.app.Activity#startActivityForResult(Intent, int)} a
 result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part of
 the provisioning flow was successful, although this doesn't guarantee the full flow will
 succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies
 that the user backed-out of provisioning, or some precondition for provisioning wasn't met.
*/
ACTION_PROVISION_MANAGED_PROFILE : &quot;android.app.action.PROVISION_MANAGED_PROFILE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISION_MANAGED_USER'>/** Activity action: Starts the provisioning flow which sets up a managed user.
</span>
 &lt;p&gt;This intent will typically be sent by a mobile device management application (MDM).
 Provisioning configures the user as managed user and sets the MDM as the profile
 owner who has full control over the user. Provisioning can only happen before user setup has
 been completed. Use {@link #isProvisioningAllowed}(String) to check if provisioning is
 allowed.

 &lt;p&gt;The intent contains the following extras:
 &lt;ul&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOGO_URI}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;If provisioning fails, the device returns to its previous state.

 &lt;p&gt;If launched with {@link android.app.Activity#startActivityForResult(Intent, int)} a
 result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part of
 the provisioning flow was successful, although this doesn't guarantee the full flow will
 succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies
 that the user backed-out of provisioning, or some precondition for provisioning wasn't met.

 @hide
*/
ACTION_PROVISION_MANAGED_USER : &quot;android.app.action.PROVISION_MANAGED_USER&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISION_MANAGED_DEVICE'>/** Activity action: Starts the provisioning flow which sets up a managed device.
</span> Must be started with {@link android.app.Activity#startActivityForResult(Intent, int)}.

 &lt;p&gt; During device owner provisioning a device admin app is set as the owner of the device.
 A device owner has full control over the device. The device owner can not be modified by the
 user.

 &lt;p&gt; A typical use case would be a device that is owned by a company, but used by either an
 employee or client.

 &lt;p&gt; An intent with this action can be sent only on an unprovisioned device.
 It is possible to check if provisioning is allowed or not by querying the method
 {@link #isProvisioningAllowed}(String).

 &lt;p&gt;The intent contains the following extras:
 &lt;ul&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOGO_URI}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DISCLAIMERS}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}, optional&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;When device owner provisioning has completed, an intent of the type
 {@link android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcast to the
 device owner.

 &lt;p&gt;From version {@link android.os.Build.VERSION_CODES#O}, when device owner provisioning has
 completed, along with the above broadcast, activity intent
 {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the device owner.

 &lt;p&gt;If provisioning fails, the device is factory reset.

 &lt;p&gt;A result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part
 of the provisioning flow was successful, although this doesn't guarantee the full flow will
 succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies
 that the user backed-out of provisioning, or some precondition for provisioning wasn't met.
*/
ACTION_PROVISION_MANAGED_DEVICE : &quot;android.app.action.PROVISION_MANAGED_DEVICE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_STATE_USER_SETUP_COMPLETE'>/** Activity action: launch when user provisioning completed, i.e.
</span> {@link #getUserProvisioningState}() returns one of the complete state.

 &lt;p&gt; Please note that the API behavior is not necessarily consistent across various releases,
 and devices, as it's contract between SetupWizard and ManagedProvisioning. The default
 implementation is that ManagedProvisioning launches SetupWizard in NFC provisioning only.

 &lt;p&gt; The activity must be protected by permission
 {@link android.Manifest.permission#BIND_DEVICE_ADMIN}, and the process must hold
 {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE} to be launched.
 Only one {@link ComponentName} in the entire system should be enabled, and the rest of the
 components are not started by this intent.
 @hide
*/
ACTION_STATE_USER_SETUP_COMPLETE : &quot;android.app.action.STATE_USER_SETUP_COMPLETE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE'>/** Activity action: Starts the provisioning flow which sets up a managed device.
</span>
 &lt;p&gt;During device owner provisioning, a device admin app is downloaded and set as the owner of
 the device. A device owner has full control over the device. The device owner can not be
 modified by the user and the only way of resetting the device is via factory reset.

 &lt;p&gt;From version {@link android.os.Build.VERSION_CODES#Q}, the admin app can choose
 whether to set up a fully managed device or a work profile. For the admin app to support
 this, it must have an activity with intent filter {@link #ACTION_GET_PROVISIONING_MODE} and
 another one with intent filter {@link #ACTION_ADMIN_POLICY_COMPLIANCE}. For example:
 &lt;pre&gt;
 &amp;lt;activity
     android:name=&quot;.GetProvisioningModeActivity&quot;
     android:label=&quot;@string/app_name&quot;
     android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&amp;gt;
     &amp;lt;intent-filter&amp;gt;
         &amp;lt;action
             android:name=&quot;android.app.action.GET_PROVISIONING_MODE&quot; /&amp;gt;
         &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;
     &amp;lt;/intent-filter&amp;gt;
 &amp;lt;/activity&amp;gt;

 &amp;lt;activity
     android:name=&quot;.PolicyComplianceActivity&quot;
     android:label=&quot;@string/app_name&quot;
     android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&amp;gt;
     &amp;lt;intent-filter&amp;gt;
         &amp;lt;action
             android:name=&quot;android.app.action.ADMIN_POLICY_COMPLIANCE&quot; /&amp;gt;
         &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;
     &amp;lt;/intent-filter&amp;gt;
 &amp;lt;/activity&amp;gt;&lt;/pre&gt;

 &lt;p&gt;A typical use case would be a device that is owned by a company, but used by either an
 employee or client.

 &lt;p&gt;The provisioning message should be sent to an unprovisioned device.

 &lt;p&gt;Unlike {@link #ACTION_PROVISION_MANAGED_DEVICE}, the provisioning message can only be sent
 by a privileged app with the permission
 {@link android.Manifest.permission#DISPATCH_PROVISIONING_MESSAGE}.

 &lt;p&gt;The provisioning intent contains the following properties:
 &lt;ul&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOCALE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SUPPORT_URL}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ORGANIZATION_NAME}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_USE_MOBILE_DATA}, optional &lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS}, optional - when not used for
 cloud enrollment, NFC or QR provisioning&lt;/li&gt;
 &lt;/ul&gt;

 @hide
*/
ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE : &quot;android.app.action.PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE'>/** Activity action: Starts the provisioning flow which sets up a managed device.
</span> Must be started with {@link android.app.Activity#startActivityForResult(Intent, int)}.

 &lt;p&gt;NOTE: This is only supported on split system user devices, and puts the device into a
 management state that is distinct from that reached by
 {@link #ACTION_PROVISION_MANAGED_DEVICE} - specifically the device owner runs on the system
 user, and only has control over device-wide policies, not individual users and their data.
 The primary benefit is that multiple non-system users are supported when provisioning using
 this form of device management.

 &lt;p&gt;During device owner provisioning a device admin app is set as the owner of the device.
 A device owner has full control over the device. The device owner can not be modified by the
 user.

 &lt;p&gt;A typical use case would be a device that is owned by a company, but used by either an
 employee or client.

 &lt;p&gt;An intent with this action can be sent only on an unprovisioned device.
 It is possible to check if provisioning is allowed or not by querying the method
 {@link #isProvisioningAllowed}(String).

 &lt;p&gt;The intent contains the following extras:
 &lt;ul&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_SKIP_ENCRYPTION}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOGO_URI}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_MAIN_COLOR}, optional&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;When device owner provisioning has completed, an intent of the type
 {@link android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} is broadcast to the
 device owner.

 &lt;p&gt;From version {@link android.os.Build.VERSION_CODES#O}, when device owner provisioning has
 completed, along with the above broadcast, activity intent
 {@link #ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the device owner.

 &lt;p&gt;If provisioning fails, the device is factory reset.

 &lt;p&gt;A result code of {@link android.app.Activity#RESULT_OK} implies that the synchronous part
 of the provisioning flow was successful, although this doesn't guarantee the full flow will
 succeed. Conversely a result code of {@link android.app.Activity#RESULT_CANCELED} implies
 that the user backed-out of provisioning, or some precondition for provisioning wasn't met.

 @hide
*/
ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE : &quot;android.app.action.PROVISION_MANAGED_SHAREABLE_DEVICE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISION_FINALIZATION'>/** Activity action: Finalizes management provisioning, should be used after user-setup
</span> has been completed and {@link #getUserProvisioningState}() returns one of:
 &lt;ul&gt;
 &lt;li&gt;{@link #STATE_USER_SETUP_INCOMPLETE}&lt;/li&gt;
 &lt;li&gt;{@link #STATE_USER_SETUP_COMPLETE}&lt;/li&gt;
 &lt;li&gt;{@link #STATE_USER_PROFILE_COMPLETE}&lt;/li&gt;
 &lt;/ul&gt;

 @hide
*/
ACTION_PROVISION_FINALIZATION : &quot;android.app.action.PROVISION_FINALIZATION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_BUGREPORT_SHARING_ACCEPTED'>/** Action: Bugreport sharing with device owner has been accepted by the user.
</span>
 @hide
*/
ACTION_BUGREPORT_SHARING_ACCEPTED : &quot;com.android.server.action.REMOTE_BUGREPORT_SHARING_ACCEPTED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_BUGREPORT_SHARING_DECLINED'>/** Action: Bugreport sharing with device owner has been declined by the user.
</span>
 @hide
*/
ACTION_BUGREPORT_SHARING_DECLINED : &quot;com.android.server.action.REMOTE_BUGREPORT_SHARING_DECLINED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_REMOTE_BUGREPORT_DISPATCH'>/** Action: Bugreport has been collected and is dispatched to {@code DevicePolicyManagerService}.
</span>
 @hide
*/
ACTION_REMOTE_BUGREPORT_DISPATCH : &quot;android.intent.action.REMOTE_BUGREPORT_DISPATCH&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_REMOTE_BUGREPORT_HASH'>/** Extra for shared bugreport's SHA-256 hash.
</span>
 @hide
*/
EXTRA_REMOTE_BUGREPORT_HASH : &quot;android.intent.extra.REMOTE_BUGREPORT_HASH&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_BUGREPORT_NOTIFICATION_TYPE'>/** Extra for remote bugreport notification shown type.
</span>
 @hide
*/
EXTRA_BUGREPORT_NOTIFICATION_TYPE : &quot;android.app.extra.bugreport_notification_type&quot;,
<span id='android-app-admin-DevicePolicyManager-property-NOTIFICATION_BUGREPORT_STARTED'>/** Notification type for a started remote bugreport flow.
</span>
 @hide
*/
NOTIFICATION_BUGREPORT_STARTED : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-NOTIFICATION_BUGREPORT_ACCEPTED_NOT_FINISHED'>/** Notification type for a bugreport that has already been accepted to be shared, but is still
</span> being taken.

 @hide
*/
NOTIFICATION_BUGREPORT_ACCEPTED_NOT_FINISHED : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED'>/** Notification type for a bugreport that has been taken and can be shared or declined.
</span>
 @hide
*/
NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED : &quot;3&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DEFAULT_STRONG_AUTH_TIMEOUT_MS'>/** Default and maximum timeout in milliseconds after which unlocking with weak auth times out,
</span> i.e. the user has to use a strong authentication method like password, PIN or pattern.

 @hide
*/
DEFAULT_STRONG_AUTH_TIMEOUT_MS : &quot;259200000&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE'>/** A {@link android.os.Parcelable} extra of type {@link android.os.PersistableBundle} that
</span> allows a mobile device management application or NFC programmer application which starts
 managed provisioning to pass data to the management application instance after provisioning.
 &lt;p&gt;
 If used with {@link #ACTION_PROVISION_MANAGED_PROFILE} it can be used by the application that
 sends the intent to pass data to itself on the newly created profile.
 If used with {@link #ACTION_PROVISION_MANAGED_DEVICE} it allows passing data to the same
 instance of the app on the primary user.
 Starting from {@link android.os.Build.VERSION_CODES#M}, if used with
 {@link #MIME_TYPE_PROVISIONING_NFC} as part of NFC managed device provisioning, the NFC
 message should contain a stringified {@link java.util.Properties} instance, whose string
 properties will be converted into a {@link android.os.PersistableBundle} and passed to the
 management application after provisioning.

 &lt;p&gt;
 In both cases the application receives the data in
 {@link android.app.admin.DeviceAdminReceiver#onProfileProvisioningComplete} via an intent with the action
 {@link android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE}. The bundle is not changed
 during the managed provisioning.
*/
EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE : &quot;android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME'>/** A String extra holding the package name of the mobile device management application that
</span> will be set as the profile owner or device owner.

 &lt;p&gt;If an application starts provisioning directly via an intent with action
 {@link #ACTION_PROVISION_MANAGED_PROFILE} this package has to match the package name of the
 application that started provisioning. The package will be set as profile owner in that case.

 &lt;p&gt;This package is set as device owner when device owner provisioning is started by an NFC
 message containing an NFC record with MIME type {@link #MIME_TYPE_PROVISIONING_NFC}.

 &lt;p&gt; When this extra is set, the application must have exactly one device admin receiver.
 This receiver will be set as the profile or device owner and active admin.

 @see DeviceAdminReceiver
 @deprecated Use {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME}. This extra is still
 supported, but only if there is only one device admin receiver in the package that requires
 the permission {@link android.Manifest.permission#BIND_DEVICE_ADMIN}.
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME'>/** A ComponentName extra indicating the device admin receiver of the mobile device management
</span> application that will be set as the profile owner or device owner and active admin.

 &lt;p&gt;If an application starts provisioning directly via an intent with action
 {@link #ACTION_PROVISION_MANAGED_PROFILE} or
 {@link #ACTION_PROVISION_MANAGED_DEVICE} the package name of this
 component has to match the package name of the application that started provisioning.

 &lt;p&gt;This component is set as device owner and active admin when device owner provisioning is
 started by an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE} or by an NFC
 message containing an NFC record with MIME type
 {@link #MIME_TYPE_PROVISIONING_NFC}. For the NFC record, the component name must be
 flattened to a string, via {@link ComponentName#flattenToShortString()}.

 @see DeviceAdminReceiver
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE'>/** An {@link android.accounts.Account} extra holding the account to migrate during managed
</span> profile provisioning. If the account supplied is present in the primary user, it will be
 copied, along with its credentials to the managed profile and removed from the primary user.

 Use with {@link #ACTION_PROVISION_MANAGED_PROFILE}.
*/
EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE : &quot;android.app.extra.PROVISIONING_ACCOUNT_TO_MIGRATE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION'>/** Boolean extra to indicate that the migrated account should be kept. This is used in
</span> conjunction with {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}. If it's set to {@code true},
 the account will not be removed from the primary user after it is migrated to the newly
 created user or profile.

 &lt;p&gt; Defaults to {@code false}

 &lt;p&gt; Use with {@link #ACTION_PROVISION_MANAGED_PROFILE} and
 {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}
*/
EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION : &quot;android.app.extra.PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_EMAIL_ADDRESS'>/** @deprecated From {@link android.os.Build.VERSION_CODES#O}, never used while provisioning the
</span> device.
*/
EXTRA_PROVISIONING_EMAIL_ADDRESS : &quot;android.app.extra.PROVISIONING_EMAIL_ADDRESS&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_MAIN_COLOR'>/** A integer extra indicating the predominant color to show during the provisioning.
</span> Refer to {@link android.graphics.Color} for how the color is represented.

 &lt;p&gt;Use with {@link #ACTION_PROVISION_MANAGED_PROFILE} or
 {@link #ACTION_PROVISION_MANAGED_DEVICE}.
*/
EXTRA_PROVISIONING_MAIN_COLOR : &quot;android.app.extra.PROVISIONING_MAIN_COLOR&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED'>/** A Boolean extra that can be used by the mobile device management application to skip the
</span> disabling of system apps during provisioning when set to {@code true}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} or an intent with action
 {@link #ACTION_PROVISION_MANAGED_DEVICE} that starts device owner provisioning.
*/
EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED : &quot;android.app.extra.PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_TIME_ZONE'>/** A String extra holding the time zone {@link android.app.AlarmManager} that the device
</span> will be set to.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_TIME_ZONE : &quot;android.app.extra.PROVISIONING_TIME_ZONE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_LOCAL_TIME'>/** A Long extra holding the wall clock time (in milliseconds) to be set on the device's
</span> {@link android.app.AlarmManager}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_LOCAL_TIME : &quot;android.app.extra.PROVISIONING_LOCAL_TIME&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_LOCALE'>/** A String extra holding the {@link java.util.Locale} that the device will be set to.
</span> Format: xx_yy, where xx is the language code, and yy the country code.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_LOCALE : &quot;android.app.extra.PROVISIONING_LOCALE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_SSID'>/** A String extra holding the ssid of the wifi network that should be used during nfc device
</span> owner provisioning for downloading the mobile device management application.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_SSID : &quot;android.app.extra.PROVISIONING_WIFI_SSID&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_HIDDEN'>/** A boolean extra indicating whether the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}
</span> is hidden or not.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_HIDDEN : &quot;android.app.extra.PROVISIONING_WIFI_HIDDEN&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_SECURITY_TYPE'>/** A String extra indicating the security type of the wifi network in
</span> {@link #EXTRA_PROVISIONING_WIFI_SSID} and could be one of {@code NONE}, {@code WPA},
 {@code WEP} or {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_SECURITY_TYPE : &quot;android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_PASSWORD'>/** A String extra holding the password of the wifi network in
</span> {@link #EXTRA_PROVISIONING_WIFI_SSID}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_PASSWORD : &quot;android.app.extra.PROVISIONING_WIFI_PASSWORD&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_EAP_METHOD'>/** The EAP method of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}
</span> and could be one of {@code PEAP}, {@code TLS}, {@code TTLS}, {@code PWD}, {@code SIM},
 {@code AKA} or {@code AKA_PRIME}. This is only used if the
 {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_EAP_METHOD : &quot;android.app.extra.PROVISIONING_WIFI_EAP_METHOD&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_PHASE2_AUTH'>/** The phase 2 authentication of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}
</span> and could be one of {@code NONE}, {@code PAP}, {@code MSCHAP}, {@code MSCHAPV2}, {@code GTC},
 {@code SIM}, {@code AKA} or {@code AKA_PRIME}. This is only used if the
 {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_PHASE2_AUTH : &quot;android.app.extra.PROVISIONING_WIFI_PHASE2_AUTH&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE'>/** The CA certificate of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This should
</span> be an X.509 certificate Base64 encoded DER format, ie. PEM representation of a certificate
 without header, footer and line breaks. &lt;a href=
 &quot;https://tools.ietf.org/html/rfc7468&quot;&gt; More information&lt;/a&gt; This is only
 used if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE : &quot;android.app.extra.PROVISIONING_WIFI_CA_CERTIFICATE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE'>/** The user certificate of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This
</span> should be an X.509 certificate and private key Base64 encoded DER format, ie. PEM
 representation of a certificate and key without header, footer and line breaks. &lt;a href=
 &quot;https://tools.ietf.org/html/rfc7468&quot;&gt; More information&lt;/a&gt; This is only
 used if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE : &quot;android.app.extra.PROVISIONING_WIFI_USER_CERTIFICATE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_IDENTITY'>/** The identity of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is only used
</span> if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_IDENTITY : &quot;android.app.extra.PROVISIONING_WIFI_IDENTITY&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY'>/** The anonymous identity of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is
</span> only used if the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY : &quot;android.app.extra.PROVISIONING_WIFI_ANONYMOUS_IDENTITY&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_DOMAIN'>/** The domain of the wifi network in {@link #EXTRA_PROVISIONING_WIFI_SSID}. This is only used if
</span> the {@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE} is {@code EAP}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump. It can also be used for QR code provisioning.
*/
EXTRA_PROVISIONING_WIFI_DOMAIN : &quot;android.app.extra.PROVISIONING_WIFI_DOMAIN&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_PROXY_HOST'>/** A String extra holding the proxy host for the wifi network in
</span> {@link #EXTRA_PROVISIONING_WIFI_SSID}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_PROXY_HOST : &quot;android.app.extra.PROVISIONING_WIFI_PROXY_HOST&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_PROXY_PORT'>/** An int extra holding the proxy port for the wifi network in
</span> {@link #EXTRA_PROVISIONING_WIFI_SSID}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_PROXY_PORT : &quot;android.app.extra.PROVISIONING_WIFI_PROXY_PORT&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_PROXY_BYPASS'>/** A String extra holding the proxy bypass for the wifi network in
</span> {@link #EXTRA_PROVISIONING_WIFI_SSID}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_PROXY_BYPASS : &quot;android.app.extra.PROVISIONING_WIFI_PROXY_BYPASS&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_WIFI_PAC_URL'>/** A String extra holding the proxy auto-config (PAC) URL for the wifi network in
</span> {@link #EXTRA_PROVISIONING_WIFI_SSID}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_WIFI_PAC_URL : &quot;android.app.extra.PROVISIONING_WIFI_PAC_URL&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION'>/** A String extra holding a url that specifies the download location of the device admin
</span> package. When not provided it is assumed that the device admin package is already installed.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_ORGANIZATION_NAME'>/** A String extra holding the localized name of the organization under management.
</span>
 The name is displayed only during provisioning.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}

 @hide
*/
EXTRA_PROVISIONING_ORGANIZATION_NAME : &quot;android.app.extra.PROVISIONING_ORGANIZATION_NAME&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_SUPPORT_URL'>/** A String extra holding a url to the website of the device provider so the user can open it
</span> during provisioning. If the url is not HTTPS, an error will be shown.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}

 @hide
*/
EXTRA_PROVISIONING_SUPPORT_URL : &quot;android.app.extra.PROVISIONING_SUPPORT_URL&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL'>/** A String extra holding the localized name of the device admin package. It should be the same
</span> as the app label of the package.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}

 @hide
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_LABEL&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI'>/** A {@link Uri} extra pointing to the app icon of device admin package. This image will be
</span> shown during the provisioning.
 &lt;h5&gt;The following URI schemes are accepted:&lt;/h5&gt;
 &lt;ul&gt;
 &lt;li&gt;content ({@link android.content.ContentResolver#SCHEME_CONTENT})&lt;/li&gt;
 &lt;li&gt;android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt; It is the responsibility of the caller to provide an image with a reasonable
 pixel density for the device.

 &lt;p&gt; If a content: URI is passed, the intent should have the flag
 {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the
 {@link android.content.ClipData} of the intent too.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}

 @hide
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_ICON_URI&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE'>/** An int extra holding a minimum required version code for the device admin package. If the
</span> device admin is already installed on the device, it will only be re-downloaded from
 {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION} if the version of the
 installed package is less than this version code.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER'>/** A String extra holding a http cookie header which should be used in the http request to the
</span> url specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM'>/** A String extra holding the URL-safe base64 encoded SHA-256 hash of the file at download
</span> location specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.

 &lt;p&gt;Either this extra or {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM} must be
 present. The provided checksum must match the checksum of the file at the download
 location. If the checksum doesn't match an error will be shown to the user and the user will
 be asked to factory reset the device.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; for devices running {@link android.os.Build.VERSION_CODES#LOLLIPOP}
 and {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} only SHA-1 hash is supported.
 Starting from {@link android.os.Build.VERSION_CODES#M}, this parameter accepts SHA-256 in
 addition to SHA-1. From {@link android.os.Build.VERSION_CODES#Q}, only SHA-256 hash is
 supported.
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM'>/** A String extra holding the URL-safe base64 encoded SHA-256 checksum of any signature of the
</span> android package archive at the download location specified in {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}.

 &lt;p&gt;The signatures of an android package archive can be obtained using
 {@link android.content.pm.PackageManager#getPackageArchiveInfo} with flag
 {@link android.content.pm.PackageManager#GET_SIGNATURES}.

 &lt;p&gt;Either this extra or {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM} must be
 present. The provided checksum must match the checksum of any signature of the file at
 the download location. If the checksum does not match an error will be shown to the user and
 the user will be asked to factory reset the device.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.
*/
EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM : &quot;android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_MANAGED_PROFILE_PROVISIONED'>/** Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile
</span> has completed successfully.

 &lt;p&gt;The broadcast is limited to the primary profile, to the app specified in the provisioning
 intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}.

 &lt;p&gt;This intent will contain the following extras
 &lt;ul&gt;
 &lt;li&gt;{@link Intent#EXTRA_USER}, corresponds to the {@link UserHandle} of the managed
 profile.&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE}, corresponds to the account requested to
 be migrated at provisioning time, if any.&lt;/li&gt;
 &lt;/ul&gt;
*/
ACTION_MANAGED_PROFILE_PROVISIONED : &quot;android.app.action.MANAGED_PROFILE_PROVISIONED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROVISIONING_SUCCESSFUL'>/** Activity action: This activity action is sent to indicate that provisioning of a managed
</span> profile or managed device has completed successfully. It'll be sent at the same time as
 {@link android.app.admin.DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE} broadcast but this will be
 delivered faster as it's an activity intent.

 &lt;p&gt;The intent is only sent to the new device or profile owner.

 @see #ACTION_PROVISION_MANAGED_PROFILE
 @see #ACTION_PROVISION_MANAGED_DEVICE
*/
ACTION_PROVISIONING_SUCCESSFUL : &quot;android.app.action.PROVISIONING_SUCCESSFUL&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_SKIP_ENCRYPTION'>/** A boolean extra indicating whether device encryption can be skipped as part of device owner
</span> or managed profile provisioning.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} or an intent with action
 {@link #ACTION_PROVISION_MANAGED_DEVICE} that starts device owner provisioning.

 &lt;p&gt;From {@link android.os.Build.VERSION_CODES#N} onwards, this is also supported for an
 intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE}.
*/
EXTRA_PROVISIONING_SKIP_ENCRYPTION : &quot;android.app.extra.PROVISIONING_SKIP_ENCRYPTION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_LOGO_URI'>/** A {@link Uri} extra pointing to a logo image. This image will be shown during the
</span> provisioning. If this extra is not passed, a default image will be shown.
 &lt;h5&gt;The following URI schemes are accepted:&lt;/h5&gt;
 &lt;ul&gt;
 &lt;li&gt;content ({@link android.content.ContentResolver#SCHEME_CONTENT})&lt;/li&gt;
 &lt;li&gt;android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt; It is the responsibility of the caller to provide an image with a reasonable
 pixel density for the device.

 &lt;p&gt; If a content: URI is passed, the intent should have the flag
 {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the
 {@link android.content.ClipData} of the intent too.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE} or
 {@link #ACTION_PROVISION_MANAGED_DEVICE}
*/
EXTRA_PROVISIONING_LOGO_URI : &quot;android.app.extra.PROVISIONING_LOGO_URI&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DISCLAIMERS'>/** A {@link Bundle}[] extra consisting of list of disclaimer headers and disclaimer contents.
</span> Each {@link Bundle} must have both {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER}
 as disclaimer header, and {@link #EXTRA_PROVISIONING_DISCLAIMER_CONTENT} as disclaimer
 content.

 &lt;p&gt; The extra typically contains one disclaimer from the company of mobile device
 management application (MDM), and one disclaimer from the organization.

 &lt;p&gt; Call {@link Bundle#putParcelableArray(String, Parcelable[])} to put the {@link Bundle}[]

 &lt;p&gt; Maximum 3 key-value pairs can be specified. The rest will be ignored.

 &lt;p&gt; Use in an intent with action {@link #ACTION_PROVISION_MANAGED_PROFILE} or
 {@link #ACTION_PROVISION_MANAGED_DEVICE}
*/
EXTRA_PROVISIONING_DISCLAIMERS : &quot;android.app.extra.PROVISIONING_DISCLAIMERS&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DISCLAIMER_HEADER'>/** A String extra of localized disclaimer header.
</span>
 &lt;p&gt; The extra is typically the company name of mobile device management application (MDM)
 or the organization name.

 &lt;p&gt; Use in Bundle {@link #EXTRA_PROVISIONING_DISCLAIMERS}

 &lt;p&gt; System app, i.e. application with {@link ApplicationInfo#FLAG_SYSTEM}, can also insert a
 disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.
 Must use it with {@link #EXTRA_PROVISIONING_DISCLAIMER_CONTENT}. Here is the example:

 &lt;pre&gt;
  &amp;lt;meta-data
      android:name=&quot;android.app.extra.PROVISIONING_DISCLAIMER_HEADER&quot;
      android:resource=&quot;@string/disclaimer_header&quot;
 /&amp;gt;&lt;/pre&gt;
*/
EXTRA_PROVISIONING_DISCLAIMER_HEADER : &quot;android.app.extra.PROVISIONING_DISCLAIMER_HEADER&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_DISCLAIMER_CONTENT'>/** A {@link Uri} extra pointing to disclaimer content.
</span>
 &lt;h5&gt;The following URI schemes are accepted:&lt;/h5&gt;
 &lt;ul&gt;
 &lt;li&gt;content ({@link android.content.ContentResolver#SCHEME_CONTENT})&lt;/li&gt;
 &lt;li&gt;android.resource ({@link android.content.ContentResolver#SCHEME_ANDROID_RESOURCE})&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt; Styled text is supported in the disclaimer content. The content is parsed by
 {@link android.text.Html#fromHtml(String)} and displayed in a
 {@link android.widget.TextView}.

 &lt;p&gt; If a &lt;code&gt;content:&lt;/code&gt; URI is passed, URI is passed, the intent should have the flag
 {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and the uri should be added to the
 {@link android.content.ClipData} of the intent too.

 &lt;p&gt; Use in Bundle {@link #EXTRA_PROVISIONING_DISCLAIMERS}

 &lt;p&gt; System app, i.e. application with {@link ApplicationInfo#FLAG_SYSTEM}, can also insert a
 disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.
 Must use it with {@link #EXTRA_PROVISIONING_DISCLAIMER_HEADER}. Here is the example:

 &lt;pre&gt;
  &amp;lt;meta-data
      android:name=&quot;android.app.extra.PROVISIONING_DISCLAIMER_CONTENT&quot;
      android:resource=&quot;@string/disclaimer_content&quot;
 /&amp;gt;&lt;/pre&gt;
*/
EXTRA_PROVISIONING_DISCLAIMER_CONTENT : &quot;android.app.extra.PROVISIONING_DISCLAIMER_CONTENT&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_SKIP_USER_SETUP'>/** A boolean extra indicating if user setup should be skipped, for when provisioning is started
</span> during setup-wizard.

 &lt;p&gt;If unspecified, defaults to {@code true} to match the behavior in
 {@link android.os.Build.VERSION_CODES#M} and earlier.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE} or
 {@link #ACTION_PROVISION_MANAGED_USER}.

 @hide
*/
EXTRA_PROVISIONING_SKIP_USER_SETUP : &quot;android.app.extra.PROVISIONING_SKIP_USER_SETUP&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_SKIP_USER_CONSENT'>/** A boolean extra indicating if the user consent steps from the provisioning flow should be
</span> skipped. If unspecified, defaults to {@code false}.

 It can only be used by an existing device owner trying to create a managed profile via
 {@link #ACTION_PROVISION_MANAGED_PROFILE}. Otherwise it is ignored.
*/
EXTRA_PROVISIONING_SKIP_USER_CONSENT : &quot;android.app.extra.PROVISIONING_SKIP_USER_CONSENT&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS'>/** A boolean extra indicating if the education screens from the provisioning flow should be
</span> skipped. If unspecified, defaults to {@code false}.

 &lt;p&gt;This extra can be set in the following ways:
 &lt;ul&gt;
 &lt;li&gt;By the admin app when performing the admin-integrated
 provisioning flow as a result of the {@link #ACTION_GET_PROVISIONING_MODE} activity&lt;/li&gt;
 &lt;li&gt;With intent action {@link #ACTION_PROVISION_MANAGED_DEVICE}&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;If the education screens are skipped, it is the admin application's responsibility
 to display its own user education screens.
*/
EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS : &quot;android.app.extra.PROVISIONING_SKIP_EDUCATION_SCREENS&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_USE_MOBILE_DATA'>/** A boolean extra indicating if mobile data should be used during NFC device owner provisioning
</span> for downloading the mobile device management application. If {@link #EXTRA_PROVISIONING_WIFI_SSID} is also specified, wifi network will be used instead.

 &lt;p&gt;Use in an NFC record with {@link #MIME_TYPE_PROVISIONING_NFC} that starts device owner
 provisioning via an NFC bump.

 @hide
*/
EXTRA_PROVISIONING_USE_MOBILE_DATA : &quot;android.app.extra.PROVISIONING_USE_MOBILE_DATA&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_TRIGGER'>/** A String extra holding the provisioning trigger. It could be one of
</span> {@link #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT}, {@link #PROVISIONING_TRIGGER_QR_CODE},
 {@link #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER} or {@link #PROVISIONING_TRIGGER_UNSPECIFIED}.

 &lt;p&gt;Use in an intent with action {@link #ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE}.
 @hide
*/
EXTRA_PROVISIONING_TRIGGER : &quot;android.app.extra.PROVISIONING_TRIGGER&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROVISIONING_TRIGGER_UNSPECIFIED'>/** A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning
</span> trigger has not been specified.
 @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT
 @see #PROVISIONING_TRIGGER_QR_CODE
 @see #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER
 @hide
*/
PROVISIONING_TRIGGER_UNSPECIFIED : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROVISIONING_TRIGGER_CLOUD_ENROLLMENT'>/** A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning
</span> trigger is cloud enrollment.
 @see #PROVISIONING_TRIGGER_QR_CODE
 @see #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER
 @see #PROVISIONING_TRIGGER_UNSPECIFIED
 @hide
*/
PROVISIONING_TRIGGER_CLOUD_ENROLLMENT : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROVISIONING_TRIGGER_QR_CODE'>/** A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning
</span> trigger is the QR code scanner.
 @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT
 @see #PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER
 @see #PROVISIONING_TRIGGER_UNSPECIFIED
 @hide
*/
PROVISIONING_TRIGGER_QR_CODE : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER'>/** A value for {@link #EXTRA_PROVISIONING_TRIGGER} indicating that the provisioning
</span> trigger is persistent device owner enrollment.
 @see #PROVISIONING_TRIGGER_CLOUD_ENROLLMENT
 @see #PROVISIONING_TRIGGER_QR_CODE
 @see #PROVISIONING_TRIGGER_UNSPECIFIED
 @hide
*/
PROVISIONING_TRIGGER_PERSISTENT_DEVICE_OWNER : &quot;3&quot;,
<span id='android-app-admin-DevicePolicyManager-property-MIME_TYPE_PROVISIONING_NFC'>/** This MIME type is used for starting the device owner provisioning.
</span>
 &lt;p&gt;During device owner provisioning a device admin app is set as the owner of the device.
 A device owner has full control over the device. The device owner can not be modified by the
 user and the only way of resetting the device is if the device owner app calls a factory
 reset.

 &lt;p&gt; A typical use case would be a device that is owned by a company, but used by either an
 employee or client.

 &lt;p&gt; The NFC message must be sent to an unprovisioned device.

 &lt;p&gt;The NFC record must contain a serialized {@link java.util.Properties} object which
 contains the following properties:
 &lt;ul&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOCAL_TIME} (convert to String), optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_TIME_ZONE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_LOCALE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_SSID}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_HIDDEN} (convert to String), optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_SECURITY_TYPE}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PASSWORD}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PROXY_HOST}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PROXY_PORT} (convert to String), optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PROXY_BYPASS}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PAC_URL}, optional&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}, optional, supported from {@link android.os.Build.VERSION_CODES#M} &lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_EAP_METHOD}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_PHASE2_AUTH}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_CA_CERTIFICATE}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_USER_CERTIFICATE}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_IDENTITY}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_ANONYMOUS_IDENTITY}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;
 &lt;li&gt;{@link #EXTRA_PROVISIONING_WIFI_DOMAIN}, optional, supported from {@link android.os.Build.VERSION_CODES#Q}&lt;/li&gt;&lt;/ul&gt;

 &lt;p&gt;
 As of {@link android.os.Build.VERSION_CODES#M}, the properties should contain
 {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME} instead of
 {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME}, (although specifying only
 {@link #EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME} is still supported).
*/
MIME_TYPE_PROVISIONING_NFC : &quot;application/com.android.managedprovisioning&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_ADD_DEVICE_ADMIN'>/** Activity action: ask the user to add a new device administrator to the system.
</span> The desired policy is the ComponentName of the policy in the
 {@link #EXTRA_DEVICE_ADMIN} extra field.  This will invoke a UI to
 bring the user through adding the device administrator to the system (or
 allowing them to reject it).

 &lt;p&gt;You can optionally include the {@link #EXTRA_ADD_EXPLANATION}
 field to provide the user with additional explanation (in addition
 to your component's description) about what is being added.

 &lt;p&gt;If your administrator is already active, this will ordinarily return immediately (without
 user intervention).  However, if your administrator has been updated and is requesting
 additional uses-policy flags, the user will be presented with the new list.  New policies
 will not be available to the updated administrator until the user has accepted the new list.
*/
ACTION_ADD_DEVICE_ADMIN : &quot;android.app.action.ADD_DEVICE_ADMIN&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_SET_PROFILE_OWNER'>/** @hide
</span> Activity action: ask the user to add a new device administrator as the profile owner
 for this user. Only system apps can launch this intent.

 &lt;p&gt;The ComponentName of the profile owner admin is passed in the {@link #EXTRA_DEVICE_ADMIN}
 extra field. This will invoke a UI to bring the user through adding the profile owner admin
 to remotely control restrictions on the user.

 &lt;p&gt;The intent must be invoked via {@link Activity#startActivityForResult} to receive the
 result of whether or not the user approved the action. If approved, the result will
 be {@link Activity#RESULT_OK} and the component will be set as an active admin as well
 as a profile owner.

 &lt;p&gt;You can optionally include the {@link #EXTRA_ADD_EXPLANATION}
 field to provide the user with additional explanation (in addition
 to your component's description) about what is being added.

 &lt;p&gt;If there is already a profile owner active or the caller is not a system app, the
 operation will return a failure result.
*/
ACTION_SET_PROFILE_OWNER : &quot;android.app.action.SET_PROFILE_OWNER&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROFILE_OWNER_NAME'>/** @hide
</span> Name of the profile owner admin that controls the user.
*/
EXTRA_PROFILE_OWNER_NAME : &quot;android.app.extra.PROFILE_OWNER_NAME&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED'>/** Broadcast action: send when any policy admin changes a policy.
</span> This is generally used to find out when a new policy is in effect.

 @hide
*/
ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED : &quot;android.app.action.DEVICE_POLICY_MANAGER_STATE_CHANGED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_DEVICE_OWNER_CHANGED'>/** Broadcast action: sent when the device owner is set, changed or cleared.
</span>
 This broadcast is sent only to the primary user.
 @see #ACTION_PROVISION_MANAGED_DEVICE
 @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)
*/
ACTION_DEVICE_OWNER_CHANGED : &quot;android.app.action.DEVICE_OWNER_CHANGED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_DEVICE_ADMIN'>/** The ComponentName of the administrator component.
</span>
 @see #ACTION_ADD_DEVICE_ADMIN
*/
EXTRA_DEVICE_ADMIN : &quot;android.app.extra.DEVICE_ADMIN&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_ADD_EXPLANATION'>/** An optional CharSequence providing additional explanation for why the
</span> admin is being added.

 @see #ACTION_ADD_DEVICE_ADMIN
*/
EXTRA_ADD_EXPLANATION : &quot;android.app.extra.ADD_EXPLANATION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-POLICY_DISABLE_CAMERA'>/** Constant to indicate the feature of disabling the camera. Used as argument to
</span> {@link #createAdminSupportIntent}(String).
 @see #setCameraDisabled(ComponentName, boolean)
*/
POLICY_DISABLE_CAMERA : &quot;policy_disable_camera&quot;,
<span id='android-app-admin-DevicePolicyManager-property-POLICY_DISABLE_SCREEN_CAPTURE'>/** Constant to indicate the feature of disabling screen captures. Used as argument to
</span> {@link #createAdminSupportIntent}(String).
 @see #setScreenCaptureDisabled(ComponentName, boolean)
*/
POLICY_DISABLE_SCREEN_CAPTURE : &quot;policy_disable_screen_capture&quot;,
<span id='android-app-admin-DevicePolicyManager-property-POLICY_SUSPEND_PACKAGES'>/** Constant to indicate the feature of suspending app. Use it as the value of
</span> {@link #EXTRA_RESTRICTION}.
 @hide
*/
POLICY_SUSPEND_PACKAGES : &quot;policy_suspend_packages&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_RESTRICTION'>/** A String indicating a specific restricted feature. Can be a user restriction from the
</span> {@link UserManager}, e.g. {@link UserManager#DISALLOW_ADJUST_VOLUME}, or one of the values
 {@link #POLICY_DISABLE_CAMERA} or {@link #POLICY_DISABLE_SCREEN_CAPTURE}.
 @see #createAdminSupportIntent(String)
 @hide
*/
EXTRA_RESTRICTION : &quot;android.app.extra.RESTRICTION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_SET_NEW_PASSWORD'>/** Activity action: have the user enter a new password.
</span>
 &lt;p&gt;For admin apps, this activity should be launched after using {@link #setPasswordQuality(ComponentName, int)}, or {@link #setPasswordMinimumLength(ComponentName, int)} to have the user enter a new password that
 meets the current requirements. You can use {@link #isActivePasswordSufficient}() to
 determine whether you need to have the user select a new password in order to meet the
 current constraints. Upon being resumed from this activity, you can check the new
 password characteristics to see if they are sufficient.

 &lt;p&gt;Non-admin apps can use {@link #getPasswordComplexity}() to check the current screen lock
 complexity, and use this activity with extra {@link #EXTRA_PASSWORD_COMPLEXITY} to suggest
 to users how complex the app wants the new screen lock to be. Note that both {@link #getPasswordComplexity}() and the extra {@link #EXTRA_PASSWORD_COMPLEXITY} require the
 calling app to have the permission {@link permission#REQUEST_PASSWORD_COMPLEXITY}.

 &lt;p&gt;If the intent is launched from within a managed profile with a profile
 owner built against {@link android.os.Build.VERSION_CODES#M} or before,
 this will trigger entering a new password for the parent of the profile.
 For all other cases it will trigger entering a new password for the user
 or profile it is launched from.

 @see #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD
*/
ACTION_SET_NEW_PASSWORD : &quot;android.app.action.SET_NEW_PASSWORD&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PASSWORD_COMPLEXITY'>/** An integer indicating the complexity level of the new password an app would like the user to
</span> set when launching the action {@link #ACTION_SET_NEW_PASSWORD}.

 &lt;p&gt;Must be one of
 &lt;ul&gt;
     &lt;li&gt;{@link #PASSWORD_COMPLEXITY_HIGH}
     &lt;li&gt;{@link #PASSWORD_COMPLEXITY_MEDIUM}
     &lt;li&gt;{@link #PASSWORD_COMPLEXITY_LOW}
     &lt;li&gt;{@link #PASSWORD_COMPLEXITY_NONE}
 &lt;/ul&gt;

 &lt;p&gt;If an invalid value is used, it will be treated as {@link #PASSWORD_COMPLEXITY_NONE}.
*/
EXTRA_PASSWORD_COMPLEXITY : &quot;android.app.extra.PASSWORD_COMPLEXITY&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_COMPLEXITY_NONE'>/** Constant for {@link #getPasswordComplexity}(): no password.
</span>
 &lt;p&gt;Note that these complexity constants are ordered so that higher values are more complex.
*/
PASSWORD_COMPLEXITY_NONE : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_COMPLEXITY_LOW'>/** Constant for {@link #getPasswordComplexity}(): password satisfies one of the following:
</span> &lt;ul&gt;
 &lt;li&gt;pattern
 &lt;li&gt;PIN with repeating (4444) or ordered (1234, 4321, 2468) sequences
 &lt;/ul&gt;

 &lt;p&gt;Note that these complexity constants are ordered so that higher values are more complex.

 @see #PASSWORD_QUALITY_SOMETHING
 @see #PASSWORD_QUALITY_NUMERIC
*/
PASSWORD_COMPLEXITY_LOW : &quot;65536&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_COMPLEXITY_MEDIUM'>/** Constant for {@link #getPasswordComplexity}(): password satisfies one of the following:
</span> &lt;ul&gt;
 &lt;li&gt;PIN with &lt;b&gt;no&lt;/b&gt; repeating (4444) or ordered (1234, 4321, 2468) sequences, length at
 least 4
 &lt;li&gt;alphabetic, length at least 4
 &lt;li&gt;alphanumeric, length at least 4
 &lt;/ul&gt;

 &lt;p&gt;Note that these complexity constants are ordered so that higher values are more complex.

 @see #PASSWORD_QUALITY_NUMERIC_COMPLEX
 @see #PASSWORD_QUALITY_ALPHABETIC
 @see #PASSWORD_QUALITY_ALPHANUMERIC
*/
PASSWORD_COMPLEXITY_MEDIUM : &quot;196608&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_COMPLEXITY_HIGH'>/** Constant for {@link #getPasswordComplexity}(): password satisfies one of the following:
</span> &lt;ul&gt;
 &lt;li&gt;PIN with &lt;b&gt;no&lt;/b&gt; repeating (4444) or ordered (1234, 4321, 2468) sequences, length at
 least 8
 &lt;li&gt;alphabetic, length at least 6
 &lt;li&gt;alphanumeric, length at least 6
 &lt;/ul&gt;

 &lt;p&gt;Note that these complexity constants are ordered so that higher values are more complex.

 @see #PASSWORD_QUALITY_NUMERIC_COMPLEX
 @see #PASSWORD_QUALITY_ALPHABETIC
 @see #PASSWORD_QUALITY_ALPHANUMERIC
*/
PASSWORD_COMPLEXITY_HIGH : &quot;327680&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_SET_NEW_PARENT_PROFILE_PASSWORD'>/** Activity action: have the user enter a new password for the parent profile.
</span> If the intent is launched from within a managed profile, this will trigger
 entering a new password for the parent of the profile. In all other cases
 the behaviour is identical to {@link #ACTION_SET_NEW_PASSWORD}.
*/
ACTION_SET_NEW_PARENT_PROFILE_PASSWORD : &quot;android.app.action.SET_NEW_PARENT_PROFILE_PASSWORD&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_SHOW_DEVICE_MONITORING_DIALOG'>/** Broadcast action: Tell the status bar to open the device monitoring dialog, e.g. when
</span> Network logging was enabled and the user tapped the notification.
 &lt;p class=&quot;note&quot;&gt;This is a protected intent that can only be sent by the system.&lt;/p&gt;
 @hide
*/
ACTION_SHOW_DEVICE_MONITORING_DIALOG : &quot;android.app.action.SHOW_DEVICE_MONITORING_DIALOG&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED'>/** Broadcast Action: Sent after application delegation scopes are changed. The new delegation
</span> scopes will be sent in an {@code ArrayList&lt;String&gt;} extra identified by the
 {@link #EXTRA_DELEGATION_SCOPES} key.

 &lt;p class=”note”&gt; Note: This is a protected intent that can only be sent by the system.&lt;/p&gt;
*/
ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED : &quot;android.app.action.APPLICATION_DELEGATION_SCOPES_CHANGED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_DELEGATION_SCOPES'>/** An {@code ArrayList&lt;String&gt;} corresponding to the delegation scopes given to an app in the
</span> {@link #ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED} broadcast.
*/
EXTRA_DELEGATION_SCOPES : &quot;android.app.extra.DELEGATION_SCOPES&quot;,
<span id='android-app-admin-DevicePolicyManager-property-FLAG_PARENT_CAN_ACCESS_MANAGED'>/** Flag used by {@link #addCrossProfileIntentFilter} to allow activities in
</span> the parent profile to access intents sent from the managed profile.
 That is, when an app in the managed profile calls
 {@link Activity#startActivity(Intent)}, the intent can be resolved by a
 matching activity in the parent profile.
*/
FLAG_PARENT_CAN_ACCESS_MANAGED : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-FLAG_MANAGED_CAN_ACCESS_PARENT'>/** Flag used by {@link #addCrossProfileIntentFilter} to allow activities in
</span> the managed profile to access intents sent from the parent profile.
 That is, when an app in the parent profile calls
 {@link Activity#startActivity(Intent)}, the intent can be resolved by a
 matching activity in the managed profile.
*/
FLAG_MANAGED_CAN_ACCESS_PARENT : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_SYSTEM_UPDATE_POLICY_CHANGED'>/** Broadcast action: notify that a new local system update policy has been set by the device
</span> owner. The new policy can be retrieved by {@link #getSystemUpdatePolicy}().
*/
ACTION_SYSTEM_UPDATE_POLICY_CHANGED : &quot;android.app.action.SYSTEM_UPDATE_POLICY_CHANGED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_DATA_SHARING_RESTRICTION_CHANGED'>/** Broadcast action to notify ManagedProvisioning that
</span> {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE} restriction has changed.
 @hide
*/
ACTION_DATA_SHARING_RESTRICTION_CHANGED : &quot;android.app.action.DATA_SHARING_RESTRICTION_CHANGED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_DATA_SHARING_RESTRICTION_APPLIED'>/** Broadcast action from ManagedProvisioning to notify that the latest change to
</span> {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE} restriction has been successfully
 applied (cross profile intent filters updated). Only usesd for CTS tests.
 @hide
*/
ACTION_DATA_SHARING_RESTRICTION_APPLIED : &quot;android.app.action.DATA_SHARING_RESTRICTION_APPLIED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PERMISSION_POLICY_PROMPT'>/** Permission policy to prompt user for new permission requests for runtime permissions.
</span> Already granted or denied permissions are not affected by this.
*/
PERMISSION_POLICY_PROMPT : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PERMISSION_POLICY_AUTO_GRANT'>/** Permission policy to always grant new permission requests for runtime permissions.
</span> Already granted or denied permissions are not affected by this.
*/
PERMISSION_POLICY_AUTO_GRANT : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PERMISSION_POLICY_AUTO_DENY'>/** Permission policy to always deny new permission requests for runtime permissions.
</span> Already granted or denied permissions are not affected by this.
*/
PERMISSION_POLICY_AUTO_DENY : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PERMISSION_GRANT_STATE_DEFAULT'>/** Runtime permission state: The user can manage the permission
</span> through the UI.
*/
PERMISSION_GRANT_STATE_DEFAULT : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PERMISSION_GRANT_STATE_GRANTED'>/** Runtime permission state: The permission is granted to the app
</span> and the user cannot manage the permission through the UI.
*/
PERMISSION_GRANT_STATE_GRANTED : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PERMISSION_GRANT_STATE_DENIED'>/** Runtime permission state: The permission is denied to the app
</span> and the user cannot manage the permission through the UI.
*/
PERMISSION_GRANT_STATE_DENIED : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_CERT_INSTALL'>/** Delegation of certificate installation and management. This scope grants access to the
</span> {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},
 {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair} APIs.
*/
DELEGATION_CERT_INSTALL : &quot;delegation-cert-install&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_APP_RESTRICTIONS'>/** Delegation of application restrictions management. This scope grants access to the
</span> {@link #setApplicationRestrictions} and {@link #getApplicationRestrictions} APIs.
*/
DELEGATION_APP_RESTRICTIONS : &quot;delegation-app-restrictions&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_BLOCK_UNINSTALL'>/** Delegation of application uninstall block. This scope grants access to the
</span> {@link #setUninstallBlocked} API.
*/
DELEGATION_BLOCK_UNINSTALL : &quot;delegation-block-uninstall&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_PERMISSION_GRANT'>/** Delegation of permission policy and permission grant state. This scope grants access to the
</span> {@link #setPermissionPolicy}, {@link #getPermissionGrantState},
 and {@link #setPermissionGrantState} APIs.
*/
DELEGATION_PERMISSION_GRANT : &quot;delegation-permission-grant&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_PACKAGE_ACCESS'>/** Delegation of package access state. This scope grants access to the
</span> {@link #isApplicationHidden}, {@link #setApplicationHidden}, {@link #isPackageSuspended}, and
 {@link #setPackagesSuspended} APIs.
*/
DELEGATION_PACKAGE_ACCESS : &quot;delegation-package-access&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_ENABLE_SYSTEM_APP'>/** Delegation for enabling system apps. This scope grants access to the {@link #enableSystemApp}
</span> API.
*/
DELEGATION_ENABLE_SYSTEM_APP : &quot;delegation-enable-system-app&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_INSTALL_EXISTING_PACKAGE'>/** Delegation for installing existing packages. This scope grants access to the
</span> {@link #installExistingPackage} API.
*/
DELEGATION_INSTALL_EXISTING_PACKAGE : &quot;delegation-install-existing-package&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_KEEP_UNINSTALLED_PACKAGES'>/** Delegation of management of uninstalled packages. This scope grants access to the
</span> {@link #setKeepUninstalledPackages} and {@link #getKeepUninstalledPackages} APIs.
*/
DELEGATION_KEEP_UNINSTALLED_PACKAGES : &quot;delegation-keep-uninstalled-packages&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_NETWORK_LOGGING'>/** Grants access to {@link #setNetworkLoggingEnabled}, {@link #isNetworkLoggingEnabled} and
</span> {@link #retrieveNetworkLogs}. Once granted the delegated app will start receiving
 DelegatedAdminReceiver.onNetworkLogsAvailable() callback, and Device owner will no longer
 receive the DeviceAdminReceiver.onNetworkLogsAvailable() callback.
 There can be at most one app that has this delegation.
 If another app already had delegated network logging access,
 it will lose the delegation when a new app is delegated.

 &lt;p&gt; Can only be granted by Device Owner.
*/
DELEGATION_NETWORK_LOGGING : &quot;delegation-network-logging&quot;,
<span id='android-app-admin-DevicePolicyManager-property-DELEGATION_CERT_SELECTION'>/** Grants access to selection of KeyChain certificates on behalf of requesting apps.
</span> Once granted the app will start receiving
 DelegatedAdminReceiver.onChoosePrivateKeyAlias. The caller (PO/DO) will
 no longer receive {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.
 There can be at most one app that has this delegation.
 If another app already had delegated certificate selection access,
 it will lose the delegation when a new app is delegated.

 &lt;p&gt; Can be granted by Device Owner or Profile Owner.
*/
DELEGATION_CERT_SELECTION : &quot;delegation-cert-selection&quot;,
<span id='android-app-admin-DevicePolicyManager-property-STATE_USER_UNMANAGED'>/** No management for current user in-effect. This is the default.
</span> @hide
*/
STATE_USER_UNMANAGED : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-STATE_USER_SETUP_INCOMPLETE'>/** Management partially setup, user setup needs to be completed.
</span> @hide
*/
STATE_USER_SETUP_INCOMPLETE : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-STATE_USER_SETUP_COMPLETE'>/** Management partially setup, user setup completed.
</span> @hide
*/
STATE_USER_SETUP_COMPLETE : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-STATE_USER_SETUP_FINALIZED'>/** Management setup and active on current user.
</span> @hide
*/
STATE_USER_SETUP_FINALIZED : &quot;3&quot;,
<span id='android-app-admin-DevicePolicyManager-property-STATE_USER_PROFILE_COMPLETE'>/** Management partially setup on a managed profile.
</span> @hide
*/
STATE_USER_PROFILE_COMPLETE : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_OK'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},
 {@link #ACTION_PROVISION_MANAGED_PROFILE}, {@link #ACTION_PROVISION_MANAGED_USER} and
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when provisioning is allowed.

 @hide
*/
CODE_OK : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_HAS_DEVICE_OWNER'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when the device already has a device
 owner.

 @hide
*/
CODE_HAS_DEVICE_OWNER : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_USER_HAS_PROFILE_OWNER'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when the user has a profile owner and for
 {@link #ACTION_PROVISION_MANAGED_PROFILE} when the profile owner is already set.

 @hide
*/
CODE_USER_HAS_PROFILE_OWNER : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_USER_NOT_RUNNING'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} when the user isn't running.

 @hide
*/
CODE_USER_NOT_RUNNING : &quot;3&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_USER_SETUP_COMPLETED'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} if the device has already been setup and
 for {@link #ACTION_PROVISION_MANAGED_USER} if the user has already been setup.

 @hide
*/
CODE_USER_SETUP_COMPLETED : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_NONSYSTEM_USER_EXISTS'>/** Code used to indicate that the device also has a user other than the system user.
</span>
 @hide
*/
CODE_NONSYSTEM_USER_EXISTS : &quot;5&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_ACCOUNTS_NOT_EMPTY'>/** Code used to indicate that device has an account that prevents provisioning.
</span>
 @hide
*/
CODE_ACCOUNTS_NOT_EMPTY : &quot;6&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_NOT_SYSTEM_USER'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE} and
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} if the user is not a system user.

 @hide
*/
CODE_NOT_SYSTEM_USER : &quot;7&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_HAS_PAIRED'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} and {@link #ACTION_PROVISION_MANAGED_USER}
 when the device is a watch and is already paired.

 @hide
*/
CODE_HAS_PAIRED : &quot;8&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_MANAGED_USERS_NOT_SUPPORTED'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} and
 {@link #ACTION_PROVISION_MANAGED_USER} on devices which do not support managed users.

 @see {@link PackageManager#FEATURE_MANAGED_USERS}
 @hide
*/
CODE_MANAGED_USERS_NOT_SUPPORTED : &quot;9&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_SYSTEM_USER'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_USER} if the user is a system user.

 @hide
*/
CODE_SYSTEM_USER : &quot;10&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_CANNOT_ADD_MANAGED_PROFILE'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} when the user cannot have more
 managed profiles.

 @hide
*/
CODE_CANNOT_ADD_MANAGED_PROFILE : &quot;11&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_NOT_SYSTEM_USER_SPLIT'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_USER} and
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} on devices not running with split system
 user.

 @hide
*/
CODE_NOT_SYSTEM_USER_SPLIT : &quot;12&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_DEVICE_ADMIN_NOT_SUPPORTED'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_DEVICE},
 {@link #ACTION_PROVISION_MANAGED_PROFILE}, {@link #ACTION_PROVISION_MANAGED_USER} and
 {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE} on devices which do no support device
 admins.

 @hide
*/
CODE_DEVICE_ADMIN_NOT_SUPPORTED : &quot;13&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_SPLIT_SYSTEM_USER_DEVICE_SYSTEM_USER'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} when the device the user is a
 system user on a split system user device.

 @hide
*/
CODE_SPLIT_SYSTEM_USER_DEVICE_SYSTEM_USER : &quot;14&quot;,
<span id='android-app-admin-DevicePolicyManager-property-CODE_ADD_MANAGED_PROFILE_DISALLOWED'>/** Result code for {@link #checkProvisioningPreCondition}.
</span>
 &lt;p&gt;Returned for {@link #ACTION_PROVISION_MANAGED_PROFILE} when adding a managed profile is
 disallowed by {@link UserManager#DISALLOW_ADD_MANAGED_PROFILE}.

 @hide
*/
CODE_ADD_MANAGED_PROFILE_DISALLOWED : &quot;15&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_NONE'>/** Disable all configurable SystemUI features during LockTask mode. This includes,
</span> &lt;ul&gt;
     &lt;li&gt;system info area in the status bar (connectivity icons, clock, etc.)
     &lt;li&gt;notifications (including alerts, icons, and the notification shade)
     &lt;li&gt;Home button
     &lt;li&gt;Recents button and UI
     &lt;li&gt;global actions menu (i.e. power button menu)
     &lt;li&gt;keyguard
 &lt;/ul&gt;

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_NONE : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_SYSTEM_INFO'>/** Enable the system info area in the status bar during LockTask mode. The system info area
</span> usually occupies the right side of the status bar (although this can differ across OEMs). It
 includes all system information indicators, such as date and time, connectivity, battery,
 vibration mode, etc.

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_SYSTEM_INFO : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_NOTIFICATIONS'>/** Enable notifications during LockTask mode. This includes notification icons on the status
</span> bar, heads-up notifications, and the expandable notification shade. Note that the Quick
 Settings panel remains disabled. This feature flag can only be used in combination with
 {@link #LOCK_TASK_FEATURE_HOME}. {@link #setLockTaskFeatures(ComponentName, int)}
 throws an {@link IllegalArgumentException} if this feature flag is defined without
 {@link #LOCK_TASK_FEATURE_HOME}.

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_NOTIFICATIONS : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_HOME'>/** Enable the Home button during LockTask mode. Note that if a custom launcher is used, it has
</span> to be registered as the default launcher with
 {@link #addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}, and its
 package needs to be whitelisted for LockTask with
 {@link #setLockTaskPackages(ComponentName, String[])}.

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_HOME : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_OVERVIEW'>/** Enable the Overview button and the Overview screen during LockTask mode. This feature flag
</span> can only be used in combination with {@link #LOCK_TASK_FEATURE_HOME}, and
 {@link #setLockTaskFeatures(ComponentName, int)} will throw an
 {@link IllegalArgumentException} if this feature flag is defined without
 {@link #LOCK_TASK_FEATURE_HOME}.

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_OVERVIEW : &quot;8&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_GLOBAL_ACTIONS'>/** Enable the global actions dialog during LockTask mode. This is the dialog that shows up when
</span> the user long-presses the power button, for example. Note that the user may not be able to
 power off the device if this flag is not set.

 &lt;p&gt;This flag is enabled by default until {@link #setLockTaskFeatures(ComponentName, int)} is
 called for the first time.

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_GLOBAL_ACTIONS : &quot;16&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LOCK_TASK_FEATURE_KEYGUARD'>/** Enable the keyguard during LockTask mode. Note that if the keyguard is already disabled with
</span> {@link #setKeyguardDisabled(ComponentName, boolean)}, setting this flag will have no effect.
 If this flag is not set, the keyguard will not be shown even if the user has a lock screen
 credential.

 @see #setLockTaskFeatures(ComponentName, int)
*/
LOCK_TASK_FEATURE_KEYGUARD : &quot;32&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_DEVICE_ADMIN_SERVICE'>/** Service action: Action for a service that device owner and profile owner can optionally
</span> own.  If a device owner or a profile owner has such a service, the system tries to keep
 a bound connection to it, in order to keep their process always running.
 The service must be protected with the {@link android.Manifest.permission#BIND_DEVICE_ADMIN}
 permission.
*/
ACTION_DEVICE_ADMIN_SERVICE : &quot;android.app.action.DEVICE_ADMIN_SERVICE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ID_TYPE_BASE_INFO'>/** Specifies that the device should attest its manufacturer details. For use with
</span> {@link #generateKeyPair}.

 @see #generateKeyPair
*/
ID_TYPE_BASE_INFO : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ID_TYPE_SERIAL'>/** Specifies that the device should attest its serial number. For use with
</span> {@link #generateKeyPair}.

 @see #generateKeyPair
*/
ID_TYPE_SERIAL : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ID_TYPE_IMEI'>/** Specifies that the device should attest its IMEI. For use with {@link #generateKeyPair}.
</span>
 @see #generateKeyPair
*/
ID_TYPE_IMEI : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ID_TYPE_MEID'>/** Specifies that the device should attest its MEID. For use with {@link #generateKeyPair}.
</span>
 @see #generateKeyPair
*/
ID_TYPE_MEID : &quot;8&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEY_GEN_STRONGBOX_UNAVAILABLE'>/** Service-specific error code for {@link #generateKeyPair}:
</span> Indicates the call has failed due to StrongBox unavailability.
 @hide
*/
KEY_GEN_STRONGBOX_UNAVAILABLE : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-INSTALLKEY_REQUEST_CREDENTIALS_ACCESS'>/** Specifies that the calling app should be granted access to the installed credentials
</span> immediately. Otherwise, access to the credentials will be gated by user approval.
 For use with {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)}

 @see #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
*/
INSTALLKEY_REQUEST_CREDENTIALS_ACCESS : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-INSTALLKEY_SET_USER_SELECTABLE'>/** Specifies that a user can select the key via the Certificate Selection prompt.
</span> If this flag is not set when calling {@link #installKeyPair}, the key can only be granted
 access by implementing {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.
 For use with {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)}

 @see #installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
*/
INSTALLKEY_SET_USER_SELECTABLE : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_PROFILE_OWNER_CHANGED'>/** Broadcast action: sent when the profile owner is set, changed or cleared.
</span>
 This broadcast is sent only to the user managed by the new profile owner.
 @see DevicePolicyManager#transferOwnership(ComponentName, ComponentName, PersistableBundle)
*/
ACTION_PROFILE_OWNER_CHANGED : &quot;android.app.action.PROFILE_OWNER_CHANGED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_MODE_UNKNOWN'>/** Specifies that the Private DNS setting is in an unknown state.
</span>*/
PRIVATE_DNS_MODE_UNKNOWN : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_MODE_OFF'>/** Specifies that Private DNS was turned off completely.
</span>*/
PRIVATE_DNS_MODE_OFF : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_MODE_OPPORTUNISTIC'>/** Specifies that the device owner requested opportunistic DNS over TLS
</span>*/
PRIVATE_DNS_MODE_OPPORTUNISTIC : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_MODE_PROVIDER_HOSTNAME'>/** Specifies that the device owner configured a specific host to use for Private DNS.
</span>*/
PRIVATE_DNS_MODE_PROVIDER_HOSTNAME : &quot;3&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_SET_NO_ERROR'>/** The selected mode has been set successfully. If the mode is
</span> {@code PRIVATE_DNS_MODE_PROVIDER_HOSTNAME} then it implies the supplied host is valid
 and reachable.
*/
PRIVATE_DNS_SET_NO_ERROR : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING'>/** If the {@code privateDnsHost} provided was of a valid hostname but that host was found
</span> to not support DNS-over-TLS.
*/
PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PRIVATE_DNS_SET_ERROR_FAILURE_SETTING'>/** General failure to set the Private DNS mode, not due to one of the reasons listed above.
</span>*/
PRIVATE_DNS_SET_ERROR_FAILURE_SETTING : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_GET_PROVISIONING_MODE'>/** Activity action: Starts the administrator to get the mode for the provisioning.
</span> This intent may contain the following extras:
 &lt;ul&gt;
     &lt;li&gt;{@link #EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE}&lt;/li&gt;
     &lt;li&gt;{@link #EXTRA_PROVISIONING_IMEI}&lt;/li&gt;
     &lt;li&gt;{@link #EXTRA_PROVISIONING_SERIAL_NUMBER}&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;The target activity should return one of the following values in
 {@link #EXTRA_PROVISIONING_MODE} as result:
 &lt;ul&gt;
     &lt;li&gt;{@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE}&lt;/li&gt;
     &lt;li&gt;{@link #PROVISIONING_MODE_MANAGED_PROFILE}&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;If performing fully-managed device provisioning and the admin app desires to show its
 own education screens, the target activity can additionally return
 {@link #EXTRA_PROVISIONING_SKIP_EDUCATION_SCREENS} set to &lt;code&gt;true&lt;/code&gt;.

 &lt;p&gt;The target activity may also return the account that needs to be migrated from primary
 user to managed profile in case of a profile owner provisioning in
 {@link #EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE} as result.
*/
ACTION_GET_PROVISIONING_MODE : &quot;android.app.action.GET_PROVISIONING_MODE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_IMEI'>/** A string extra holding the IMEI (International Mobile Equipment Identity) of the device.
</span>*/
EXTRA_PROVISIONING_IMEI : &quot;android.app.extra.PROVISIONING_IMEI&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_SERIAL_NUMBER'>/** A string extra holding the serial number of the device.
</span>*/
EXTRA_PROVISIONING_SERIAL_NUMBER : &quot;android.app.extra.PROVISIONING_SERIAL_NUMBER&quot;,
<span id='android-app-admin-DevicePolicyManager-property-EXTRA_PROVISIONING_MODE'>/** An intent extra holding the provisioning mode returned by the administrator.
</span> The value for this extra should be one of the following:
 &lt;ul&gt;
     &lt;li&gt;{@link #PROVISIONING_MODE_FULLY_MANAGED_DEVICE}&lt;/li&gt;
     &lt;li&gt;{@link #PROVISIONING_MODE_MANAGED_PROFILE}&lt;/li&gt;
 &lt;/ul&gt;
*/
EXTRA_PROVISIONING_MODE : &quot;android.app.extra.PROVISIONING_MODE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROVISIONING_MODE_FULLY_MANAGED_DEVICE'>/** The provisioning mode for fully managed device.
</span>*/
PROVISIONING_MODE_FULLY_MANAGED_DEVICE : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROVISIONING_MODE_MANAGED_PROFILE'>/** The provisioning mode for managed profile.
</span>*/
PROVISIONING_MODE_MANAGED_PROFILE : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_ADMIN_POLICY_COMPLIANCE'>/** Activity action: Starts the administrator to show policy compliance for the provisioning.
</span>*/
ACTION_ADMIN_POLICY_COMPLIANCE : &quot;android.app.action.ADMIN_POLICY_COMPLIANCE&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_UNSPECIFIED'>/** Constant for {@link #setPasswordQuality}: the policy has no requirements
</span> for the password.  Note that quality constants are ordered so that higher
 values are more restrictive.
*/
PASSWORD_QUALITY_UNSPECIFIED : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_BIOMETRIC_WEAK'>/** Constant for {@link #setPasswordQuality}: the policy allows for low-security biometric
</span> recognition technology.  This implies technologies that can recognize the identity of
 an individual to about a 3 digit PIN (false detection is less than 1 in 1,000).
 Note that quality constants are ordered so that higher values are more restrictive.
*/
PASSWORD_QUALITY_BIOMETRIC_WEAK : &quot;32768&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_SOMETHING'>/** Constant for {@link #setPasswordQuality}: the policy requires some kind
</span> of password or pattern, but doesn't care what it is. Note that quality constants
 are ordered so that higher values are more restrictive.
*/
PASSWORD_QUALITY_SOMETHING : &quot;65536&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_NUMERIC'>/** Constant for {@link #setPasswordQuality}: the user must have entered a
</span> password containing at least numeric characters.  Note that quality
 constants are ordered so that higher values are more restrictive.
*/
PASSWORD_QUALITY_NUMERIC : &quot;131072&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_NUMERIC_COMPLEX'>/** Constant for {@link #setPasswordQuality}: the user must have entered a
</span> password containing at least numeric characters with no repeating (4444)
 or ordered (1234, 4321, 2468) sequences.  Note that quality
 constants are ordered so that higher values are more restrictive.
*/
PASSWORD_QUALITY_NUMERIC_COMPLEX : &quot;196608&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_ALPHABETIC'>/** Constant for {@link #setPasswordQuality}: the user must have entered a
</span> password containing at least alphabetic (or other symbol) characters.
 Note that quality constants are ordered so that higher values are more
 restrictive.
*/
PASSWORD_QUALITY_ALPHABETIC : &quot;262144&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_ALPHANUMERIC'>/** Constant for {@link #setPasswordQuality}: the user must have entered a
</span> password containing at least &lt;em&gt;both&gt;&lt;/em&gt; numeric &lt;em&gt;and&lt;/em&gt;
 alphabetic (or other symbol) characters.  Note that quality constants are
 ordered so that higher values are more restrictive.
*/
PASSWORD_QUALITY_ALPHANUMERIC : &quot;327680&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_COMPLEX'>/** Constant for {@link #setPasswordQuality}: the user must have entered a
</span> password containing at least a letter, a numerical digit and a special
 symbol, by default. With this password quality, passwords can be
 restricted to contain various sets of characters, like at least an
 uppercase letter, etc. These are specified using various methods,
 like {@link #setPasswordMinimumLowerCase(ComponentName, int)}. Note
 that quality constants are ordered so that higher values are more
 restrictive.
*/
PASSWORD_QUALITY_COMPLEX : &quot;393216&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PASSWORD_QUALITY_MANAGED'>/** Constant for {@link #setPasswordQuality}: the user is not allowed to
</span> modify password. In case this password quality is set, the password is
 managed by a profile owner. The profile owner can set any password,
 as if {@link #PASSWORD_QUALITY_UNSPECIFIED} is used. Note
 that quality constants are ordered so that higher values are more
 restrictive. The value of {@link #PASSWORD_QUALITY_MANAGED} is
 the highest.
 @hide
*/
PASSWORD_QUALITY_MANAGED : &quot;524288&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED'>/** @hide
</span>
 adb shell dpm set-{device,profile}-owner will normally not allow installing an owner to
 a user with accounts.  {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED}
 and {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED} are the account features
 used by authenticator to exempt their accounts from this:

 &lt;ul&gt;
     &lt;li&gt;Non-test-only DO/PO still can't be installed when there are accounts.
     &lt;p&gt;In order to make an apk test-only, add android:testOnly=&quot;true&quot; to the
     &amp;lt;application&amp;gt; tag in the manifest.

     &lt;li&gt;Test-only DO/PO can be installed even when there are accounts, as long as all the
     accounts have the {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED} feature.
     Some authenticators claim to have any features, so to detect it, we also check
     {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED} and disallow installing
     if any of the accounts have it.
 &lt;/ul&gt;
*/
ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED : &quot;android.account.DEVICE_OR_PROFILE_OWNER_ALLOWED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED'>/**@hide See {@link #ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED} */
</span>ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED : &quot;android.account.DEVICE_OR_PROFILE_OWNER_DISALLOWED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-RESET_PASSWORD_REQUIRE_ENTRY'>/** Flag for {@link #resetPasswordWithToken} and {@link #resetPassword}: don't allow other admins
</span> to change the password again until the user has entered it.
*/
RESET_PASSWORD_REQUIRE_ENTRY : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT'>/** Flag for {@link #resetPasswordWithToken} and {@link #resetPassword}: don't ask for user
</span> credentials on device boot.
 If the flag is set, the device can be booted without asking for user password.
 The absence of this flag does not change the current boot requirements. This flag
 can be set by the device owner only. If the app is not the device owner, the flag
 is ignored. Once the flag is set, it cannot be reverted back without resetting the
 device to factory defaults.
*/
RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY'>/** Flag for {@link #lockNow}(int): also evict the user's credential encryption key from the
</span> keyring. The user's credential will need to be entered again in order to derive the
 credential encryption key that will be stored back in the keyring for future use.
 &lt;p&gt;
 This flag can only be used by a profile owner when locking a managed profile when
 {@link #getStorageEncryptionStatus} returns {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.
 &lt;p&gt;
 In order to secure user data, the user will be stopped and restarted so apps should wait
 until they are next run to perform further actions.
*/
FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-WIPE_EXTERNAL_STORAGE'>/** Flag for {@link #wipeData}(int): also erase the device's external
</span> storage (such as SD cards).
*/
WIPE_EXTERNAL_STORAGE : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-WIPE_RESET_PROTECTION_DATA'>/** Flag for {@link #wipeData}(int): also erase the factory reset protection
</span> data.

 &lt;p&gt;This flag may only be set by device owner admins; if it is set by
 other admins a {@link SecurityException} will be thrown.
*/
WIPE_RESET_PROTECTION_DATA : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-WIPE_EUICC'>/** Flag for {@link #wipeData}(int): also erase the device's eUICC data.
</span>*/
WIPE_EUICC : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-WIPE_SILENTLY'>/** Flag for {@link #wipeData}(int): won't show reason for wiping to the user.
</span>*/
WIPE_SILENTLY : &quot;8&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ENCRYPTION_STATUS_UNSUPPORTED'>/** Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
</span> indicating that encryption is not supported.
*/
ENCRYPTION_STATUS_UNSUPPORTED : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ENCRYPTION_STATUS_INACTIVE'>/** Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
</span> indicating that encryption is supported, but is not currently active.
*/
ENCRYPTION_STATUS_INACTIVE : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ENCRYPTION_STATUS_ACTIVATING'>/** Result code for {@link #getStorageEncryptionStatus}:
</span> indicating that encryption is not currently active, but is currently
 being activated.  This is only reported by devices that support
 encryption of data and only when the storage is currently
 undergoing a process of becoming encrypted.  A device that must reboot and/or wipe data
 to become encrypted will never return this value.
*/
ENCRYPTION_STATUS_ACTIVATING : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ENCRYPTION_STATUS_ACTIVE'>/** Result code for {@link #setStorageEncryption} and {@link #getStorageEncryptionStatus}:
</span> indicating that encryption is active.
 &lt;p&gt;
 Also see {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.
*/
ENCRYPTION_STATUS_ACTIVE : &quot;3&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY'>/** Result code for {@link #getStorageEncryptionStatus}:
</span> indicating that encryption is active, but an encryption key has not
 been set by the user.
*/
ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ENCRYPTION_STATUS_ACTIVE_PER_USER'>/** Result code for {@link #getStorageEncryptionStatus}:
</span> indicating that encryption is active and the encryption key is tied to the user or profile.
 &lt;p&gt;
 This value is only returned to apps targeting API level 24 and above. For apps targeting
 earlier API levels, {@link #ENCRYPTION_STATUS_ACTIVE} is returned, even if the
 encryption key is specific to the user or profile.
*/
ENCRYPTION_STATUS_ACTIVE_PER_USER : &quot;5&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_START_ENCRYPTION'>/** Activity action: begin the process of encrypting data on the device.  This activity should
</span> be launched after using {@link #setStorageEncryption} to request encryption be activated.
 After resuming from this activity, use {@link #getStorageEncryption}
 to check encryption status.  However, on some devices this activity may never return, as
 it may trigger a reboot and in some cases a complete data wipe of the device.
*/
ACTION_START_ENCRYPTION : &quot;android.app.action.START_ENCRYPTION&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ACTION_MANAGED_USER_CREATED'>/** Broadcast action: notify managed provisioning that new managed user is created.
</span>
 @hide
*/
ACTION_MANAGED_USER_CREATED : &quot;android.app.action.MANAGED_USER_CREATED&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_FEATURES_NONE'>/** Widgets are enabled in keyguard
</span>*/
KEYGUARD_DISABLE_FEATURES_NONE : &quot;0&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_WIDGETS_ALL'>/** Disable all keyguard widgets. Has no effect starting from
</span> {@link android.os.Build.VERSION_CODES#LOLLIPOP} since keyguard widget is only supported
 on Android versions lower than 5.0.
*/
KEYGUARD_DISABLE_WIDGETS_ALL : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_SECURE_CAMERA'>/** Disable the camera on secure keyguard screens (e.g. PIN/Pattern/Password)
</span>*/
KEYGUARD_DISABLE_SECURE_CAMERA : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_SECURE_NOTIFICATIONS'>/** Disable showing all notifications on secure keyguard screens (e.g. PIN/Pattern/Password)
</span>*/
KEYGUARD_DISABLE_SECURE_NOTIFICATIONS : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS'>/** Only allow redacted notifications on secure keyguard screens (e.g. PIN/Pattern/Password)
</span>*/
KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS : &quot;8&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_TRUST_AGENTS'>/** Disable trust agents on secure keyguard screens (e.g. PIN/Pattern/Password).
</span> By setting this flag alone, all trust agents are disabled. If the admin then wants to
 whitelist specific features of some trust agent, {@link #setTrustAgentConfiguration} can be
 used in conjuction to set trust-agent-specific configurations.
*/
KEYGUARD_DISABLE_TRUST_AGENTS : &quot;16&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_FINGERPRINT'>/** Disable fingerprint authentication on keyguard secure screens (e.g. PIN/Pattern/Password).
</span>*/
KEYGUARD_DISABLE_FINGERPRINT : &quot;32&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_REMOTE_INPUT'>/** Disable text entry into notifications on secure keyguard screens (e.g. PIN/Pattern/Password).
</span> This flag has no effect starting from version {@link android.os.Build.VERSION_CODES#N}
*/
KEYGUARD_DISABLE_REMOTE_INPUT : &quot;64&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_FACE'>/** Disable face authentication on keyguard secure screens (e.g. PIN/Pattern/Password).
</span>*/
KEYGUARD_DISABLE_FACE : &quot;128&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_IRIS'>/** Disable iris authentication on keyguard secure screens (e.g. PIN/Pattern/Password).
</span>*/
KEYGUARD_DISABLE_IRIS : &quot;256&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_BIOMETRICS'>/** Disable all biometric authentication on keyguard secure screens (e.g. PIN/Pattern/Password).
</span>*/
KEYGUARD_DISABLE_BIOMETRICS : &quot;416&quot;,
<span id='android-app-admin-DevicePolicyManager-property-KEYGUARD_DISABLE_FEATURES_ALL'>/** Disable all current and future keyguard customizations.
</span>*/
KEYGUARD_DISABLE_FEATURES_ALL : &quot;2147483647&quot;,
<span id='android-app-admin-DevicePolicyManager-property-PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER'>/** Keyguard features that when set on a managed profile that doesn't have its own challenge will
</span> affect the profile's parent user. These can also be set on the managed profile's parent
 {@link android.app.admin.DevicePolicyManager} instance.

 @hide
*/
PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER : &quot;432&quot;,
<span id='android-app-admin-DevicePolicyManager-property-ERROR_VPN_PACKAGE_NOT_FOUND'>/** Service-specific error code used in implementation of {@code setAlwaysOnVpnPackage} methods.
</span> @hide
*/
ERROR_VPN_PACKAGE_NOT_FOUND : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-SKIP_SETUP_WIZARD'>/** Flag used by {@link #createAndManageUser} to skip setup wizard after creating a new user.
</span>*/
SKIP_SETUP_WIZARD : &quot;1&quot;,
<span id='android-app-admin-DevicePolicyManager-property-MAKE_USER_EPHEMERAL'>/** Flag used by {@link #createAndManageUser} to specify that the user should be created
</span> ephemeral. Ephemeral users will be removed after switching to another user or rebooting the
 device.
*/
MAKE_USER_EPHEMERAL : &quot;2&quot;,
<span id='android-app-admin-DevicePolicyManager-property-MAKE_USER_DEMO'>/** Flag used by {@link #createAndManageUser} to specify that the user should be created as a
</span> demo user.
 @hide
*/
MAKE_USER_DEMO : &quot;4&quot;,
<span id='android-app-admin-DevicePolicyManager-property-LEAVE_ALL_SYSTEM_APPS_ENABLED'>/** Flag used by {@link #createAndManageUser} to specify that the newly created user should skip
</span> the disabling of system apps during provisioning.
*/
LEAVE_ALL_SYSTEM_APPS_ENABLED : &quot;16&quot;,
<span id='android-app-admin-DevicePolicyManager-method-isAdminActive'>/**Return true if the given administrator component is currently active (enabled) in the system.
</span>@param {Object {ComponentName}} admin The administrator component to check for.
@return {Boolean} {@code true} if {@code admin} is currently enabled in the system, {@code false}
         otherwise
*/
isAdminActive : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isAdminActiveAsUser'>/**
</span>@see #isAdminActive(ComponentName)
@hide 
*/
isAdminActiveAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isRemovingAdmin'>/**Return true if the given administrator component is currently being removed
</span> for the user.
@hide 
*/
isRemovingAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getActiveAdmins'>/**Return a list of all currently active device administrators' component
</span> names.  If there are no administrators {@code null} may be
 returned.
*/
getActiveAdmins : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getActiveAdminsAsUser'>/**
</span>@see #getActiveAdmins()
@hide 
*/
getActiveAdminsAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-packageHasActiveAdmins'>/**Used by package administration code to determine if a package can be stopped
</span> or uninstalled.
@hide 
*/
packageHasActiveAdmins : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-packageHasActiveAdmins'>/**Used by package administration code to determine if a package can be stopped
</span> or uninstalled.
@hide 
*/
packageHasActiveAdmins : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-removeActiveAdmin'>/**Remove a current administration component.  This can only be called
</span> by the application that owns the administration component; if you
 try to remove someone else's component, a security exception will be
 thrown.

 &lt;p&gt;Note that the operation is not synchronous and the admin might still be active (as
 indicated by {@link #getActiveAdmins}()) by the time this method returns.
@param {Object {ComponentName}} admin The administration compononent to remove.
@throws SecurityException if the caller is not in the owner application of {@code admin}.
*/
removeActiveAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-hasGrantedPolicy'>/**Returns true if an administrator has been granted a particular device policy. This can be
</span> used to check whether the administrator was activated under an earlier set of policies, but
 requires additional policies after an upgrade.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with. Must be an
            active administrator, or an exception will be thrown.
@param {Number} usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.
@throws SecurityException if {@code admin} is not an active administrator.
*/
hasGrantedPolicy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isSeparateProfileChallengeAllowed'>/**Returns true if the Profile Challenge is available to use for the given profile user.
</span>@hide 
*/
isSeparateProfileChallengeAllowed : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordQuality'>/**Called by an application that is administering the device to set the password restrictions it
</span> is imposing. After setting this, the user will not be able to enter a new password that is
 not at least as restrictive as what has been set. Note that the current password will remain
 until the user has set a new one, so the change does not take place immediately. To prompt
 the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after calling this method.
 &lt;p&gt;
 Quality constants are ordered so that higher values are more restrictive; thus the highest
 requested quality constant (between the policy set here, the user's preference, and any other
 considerations) is the one that is in effect.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} quality The new desired quality. One of {@link #PASSWORD_QUALITY_UNSPECIFIED},
            {@link #PASSWORD_QUALITY_SOMETHING}, {@link #PASSWORD_QUALITY_NUMERIC},
            {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},
            {@link #PASSWORD_QUALITY_ALPHANUMERIC} or {@link #PASSWORD_QUALITY_COMPLEX}.
@throws SecurityException if {@code admin} is not an active administrator or if {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordQuality : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordQuality'>/**Retrieve the current minimum password quality for a particular admin or all admins that set
</span> restrictions on this user and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.

 &lt;p&gt;Note: on devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,
 the password is always treated as empty.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate
 all admins.
*/
getPasswordQuality : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordQuality'>/**
</span>@hide per-user version
*/
getPasswordQuality : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumLength'>/**Called by an application that is administering the device to set the minimum allowed password
</span> length. After setting this, the user will not be able to enter a new password that is not at
 least as restrictive as what has been set. Note that the current password will remain until
 the user has set a new one, so the change does not take place immediately. To prompt the user
 for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 only imposed if the administrator has also requested either {@link #PASSWORD_QUALITY_NUMERIC}
 , {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},
 {@link #PASSWORD_QUALITY_ALPHANUMERIC}, or {@link #PASSWORD_QUALITY_COMPLEX} with
 {@link #setPasswordQuality}.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum password length. A value of 0 means there is no
            restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumLength'>/**Retrieve the current minimum password length for a particular admin or all admins that set
</span> restrictions on this user and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate
 all admins.
*/
getPasswordMinimumLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumLength'>/**
</span>@hide per-user version
*/
getPasswordMinimumLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumUpperCase'>/**Called by an application that is administering the device to set the minimum number of upper
</span> case letters required in the password. After setting this, the user will not be able to enter
 a new password that is not at least as restrictive as what has been set. Note that the
 current password will remain until the user has set a new one, so the change does not take
 place immediately. To prompt the user for a new password, use
 {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 setting this value. This constraint is only imposed if the administrator has also requested
 {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 0.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum number of upper case letters required in the password.
            A value of 0 means there is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumUpperCase : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumUpperCase'>/**Retrieve the current number of upper case letters required in the password
</span> for a particular admin or all admins that set restrictions on this user and
 its participating profiles. Restrictions on profiles that have a separate challenge
 are not taken into account.
 This is the same value as set by
 {@link #setPasswordMinimumUpperCase(ComponentName, int)}
 and only applies when the password quality is
 {@link #PASSWORD_QUALITY_COMPLEX}.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to
            aggregate all admins.
@return {Number} The minimum number of upper case letters required in the
         password.
*/
getPasswordMinimumUpperCase : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumUpperCase'>/**
</span>@hide per-user version
*/
getPasswordMinimumUpperCase : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumLowerCase'>/**Called by an application that is administering the device to set the minimum number of lower
</span> case letters required in the password. After setting this, the user will not be able to enter
 a new password that is not at least as restrictive as what has been set. Note that the
 current password will remain until the user has set a new one, so the change does not take
 place immediately. To prompt the user for a new password, use
 {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 setting this value. This constraint is only imposed if the administrator has also requested
 {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 0.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum number of lower case letters required in the password.
            A value of 0 means there is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumLowerCase : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumLowerCase'>/**Retrieve the current number of lower case letters required in the password
</span> for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by
 {@link #setPasswordMinimumLowerCase(ComponentName, int)}
 and only applies when the password quality is
 {@link #PASSWORD_QUALITY_COMPLEX}.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to
            aggregate all admins.
@return {Number} The minimum number of lower case letters required in the
         password.
*/
getPasswordMinimumLowerCase : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumLowerCase'>/**
</span>@hide per-user version
*/
getPasswordMinimumLowerCase : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumLetters'>/**Called by an application that is administering the device to set the minimum number of
</span> letters required in the password. After setting this, the user will not be able to enter a
 new password that is not at least as restrictive as what has been set. Note that the current
 password will remain until the user has set a new one, so the change does not take place
 immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 {@link #setPasswordQuality}. The default value is 1.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum number of letters required in the password. A value of
            0 means there is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumLetters : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumLetters'>/**Retrieve the current number of letters required in the password
</span> for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by
 {@link #setPasswordMinimumLetters(ComponentName, int)}
 and only applies when the password quality is
 {@link #PASSWORD_QUALITY_COMPLEX}.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to
            aggregate all admins.
@return {Number} The minimum number of letters required in the password.
*/
getPasswordMinimumLetters : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumLetters'>/**
</span>@hide per-user version
*/
getPasswordMinimumLetters : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumNumeric'>/**Called by an application that is administering the device to set the minimum number of
</span> numerical digits required in the password. After setting this, the user will not be able to
 enter a new password that is not at least as restrictive as what has been set. Note that the
 current password will remain until the user has set a new one, so the change does not take
 place immediately. To prompt the user for a new password, use
 {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 setting this value. This constraint is only imposed if the administrator has also requested
 {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 1.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum number of numerical digits required in the password. A
            value of 0 means there is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumNumeric : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumNumeric'>/**Retrieve the current number of numerical digits required in the password
</span> for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by
 {@link #setPasswordMinimumNumeric(ComponentName, int)}
 and only applies when the password quality is
 {@link #PASSWORD_QUALITY_COMPLEX}.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to
            aggregate all admins.
@return {Number} The minimum number of numerical digits required in the password.
*/
getPasswordMinimumNumeric : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumNumeric'>/**
</span>@hide per-user version
*/
getPasswordMinimumNumeric : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumSymbols'>/**Called by an application that is administering the device to set the minimum number of
</span> symbols required in the password. After setting this, the user will not be able to enter a
 new password that is not at least as restrictive as what has been set. Note that the current
 password will remain until the user has set a new one, so the change does not take place
 immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 {@link #setPasswordQuality}. The default value is 1.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum number of symbols required in the password. A value of
            0 means there is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumSymbols : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumSymbols'>/**Retrieve the current number of symbols required in the password
</span> for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account. This is the same value as
 set by {@link #setPasswordMinimumSymbols(ComponentName, int)}
 and only applies when the password quality is
 {@link #PASSWORD_QUALITY_COMPLEX}.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to
            aggregate all admins.
@return {Number} The minimum number of symbols required in the password.
*/
getPasswordMinimumSymbols : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumSymbols'>/**
</span>@hide per-user version
*/
getPasswordMinimumSymbols : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordMinimumNonLetter'>/**Called by an application that is administering the device to set the minimum number of
</span> non-letter characters (numerical digits or symbols) required in the password. After setting
 this, the user will not be able to enter a new password that is not at least as restrictive
 as what has been set. Note that the current password will remain until the user has set a new
 one, so the change does not take place immediately. To prompt the user for a new password,
 use {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 setting this value. This constraint is only imposed if the administrator has also requested
 {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 0.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired minimum number of letters required in the password. A value of
            0 means there is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordMinimumNonLetter : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumNonLetter'>/**Retrieve the current number of non-letter characters required in the password
</span> for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.
 This is the same value as set by
 {@link #setPasswordMinimumNonLetter(ComponentName, int)}
 and only applies when the password quality is
 {@link #PASSWORD_QUALITY_COMPLEX}.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to
            aggregate all admins.
@return {Number} The minimum number of letters required in the password.
*/
getPasswordMinimumNonLetter : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMinimumNonLetter'>/**
</span>@hide per-user version
*/
getPasswordMinimumNonLetter : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordHistoryLength'>/**Called by an application that is administering the device to set the length of the password
</span> history. After setting this, the user will not be able to enter a new password that is the
 same as any password in the history. Note that the current password will remain until the
 user has set a new one, so the change does not take place immediately. To prompt the user for
 a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 only imposed if the administrator has also requested either {@link #PASSWORD_QUALITY_NUMERIC}
 , {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX} {@link #PASSWORD_QUALITY_ALPHABETIC}, or
 {@link #PASSWORD_QUALITY_ALPHANUMERIC} with {@link #setPasswordQuality}.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password history length is always 0.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} length The new desired length of password history. A value of 0 means there is no
            restriction.
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
*/
setPasswordHistoryLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPasswordExpirationTimeout'>/**Called by a device admin to set the password expiration timeout. Calling this method will
</span> restart the countdown for password expiration for the given admin, as will changing the
 device password (for all admins).
 &lt;p&gt;
 The provided timeout is the time delta in ms and will be added to the current time. For
 example, to have the password expire 5 days from now, timeout would be 5 * 86400 * 1000 =
 432000000 ms for timeout.
 &lt;p&gt;
 To disable password expiration, a value of 0 may be used for timeout.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password expiration is always disabled.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
 &lt;p&gt;
 Note that setting the password will automatically reset the expiration time for all active
 admins. Active admins do not need to explicitly call this method in that case.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} timeout The limit (in ms) that a password can remain in effect. A value of 0 means
            there is no restriction (unlimited).
@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
             does not use {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD}
*/
setPasswordExpirationTimeout : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordExpirationTimeout'>/**Get the password expiration timeout for the given admin. The expiration timeout is the
</span> recurring expiration timeout provided in the call to
 {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the
 aggregate of all participating policy administrators if {@code admin} is null. Admins that
 have set restrictions on profiles that have a separate challenge are not taken into account.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password expiration is always disabled and this method always returns 0.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate all admins.
@return {Number} The timeout for the given admin or the minimum of all timeouts
*/
getPasswordExpirationTimeout : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordExpiration'>/**Get the current password expiration time for a particular admin or all admins that set
</span> restrictions on this user and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account. If admin is {@code null}, then a composite
 of all expiration times is returned - which will be the minimum of all of them.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 the password expiration for the parent profile.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password expiration is always disabled and this method always returns 0.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate all admins.
@return {Number} The password expiration time, in milliseconds since epoch.
*/
getPasswordExpiration : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordHistoryLength'>/**Retrieve the current password history length for a particular admin or all admins that
</span> set restrictions on this user and its participating profiles. Restrictions on profiles that
 have a separate challenge are not taken into account.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password history length is always 0.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate
 all admins.
@return {Number} The length of the password history
*/
getPasswordHistoryLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordHistoryLength'>/**
</span>@hide per-user version
*/
getPasswordHistoryLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordMaximumLength'>/**Return the maximum password length that the device supports for a
</span> particular password quality.
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always empty and this method always returns 0.
@param {Number} quality The quality being interrogated.
@return {Number} Returns the maximum length that the user can enter.
*/
getPasswordMaximumLength : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isActivePasswordSufficient'>/**Determines whether the calling user's current password meets policy requirements
</span> (e.g. quality, minimum length). The user must be unlocked to perform this check.

 &lt;p&gt;Policy requirements which affect this check can be set by admins of the user, but also
 by the admin of a managed profile associated with the calling user (when the managed profile
 doesn't have a separate work challenge). When a managed profile has a separate work
 challenge, its policy requirements only affect the managed profile.

 &lt;p&gt;Depending on the user, this method checks the policy requirement against one of the
 following passwords:
 &lt;ul&gt;
 &lt;li&gt;For the primary user or secondary users: the personal keyguard password.
 &lt;li&gt;For managed profiles: a work challenge if set, otherwise the parent user's personal
     keyguard password.
 &lt;ul/&gt;
 In other words, it's always checking the requirement against the password that is protecting
 the calling user.

 &lt;p&gt;Note that this method considers all policy requirements targeting the password in
 question. For example a profile owner might set a requirement on the parent profile i.e.
 personal keyguard but not on the profile itself. When the device has a weak personal keyguard
 password and no separate work challenge, calling this method will return {@code false}
 despite the profile owner not setting a policy on the profile itself. This is because the
 profile's current password is the personal keyguard password, and it does not meet all policy
 requirements.

 &lt;p&gt;Device admins must request {@link android.app.admin.DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} before
 calling this method. Note, this policy type is deprecated for device admins in Android 9.0
 (API level 28) or higher.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to determine if the password set on
 the parent profile is sufficient.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always treated as empty - i.e. this method will always return false on such
 devices, provided any password requirements were set.
@return {Boolean} {@code true} if the password meets the policy requirements, {@code false} otherwise
@throws SecurityException if the calling application isn't an active admin that uses
     {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
@throws IllegalStateException if the user isn't unlocked
*/
isActivePasswordSufficient : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPasswordComplexity'>/**Returns how complex the current user's screen lock is.
</span>
 &lt;p&gt;Note that when called from a profile which uses an unified challenge with its parent, the
 screen lock complexity of the parent will be returned. However, this API does not support
 explicitly querying the parent profile screen lock complexity via {@link #getParentProfileInstance}.
@throws IllegalStateException if the user is not unlocked.
@throws SecurityException if the calling application does not have the permission
                           {@link permission#REQUEST_PASSWORD_COMPLEXITY}
*/
getPasswordComplexity : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isUsingUnifiedPassword'>/**When called by a profile owner of a managed profile returns true if the profile uses unified
</span> challenge with its parent user.

 &lt;strong&gt;Note&lt;/strong&gt;: This method is not concerned with password quality and will return
 false if the profile has empty password as a separate challenge.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a profile owner of a managed profile.
@see UserManager#DISALLOW_UNIFIED_PASSWORD
*/
isUsingUnifiedPassword : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isProfileActivePasswordSufficientForParent'>/**Determine whether the current profile password the user has set is sufficient
</span> to meet the policy requirements (e.g. quality, minimum length) that have been
 requested by the admins of the parent user and its profiles.
@param {Number} userHandle the userId of the profile to check the password for.
@return {Boolean} Returns true if the password would meet the current requirements, else false.
@throws SecurityException if {@code userHandle} is not a managed profile.
@hide 
*/
isProfileActivePasswordSufficientForParent : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCurrentFailedPasswordAttempts'>/**Retrieve the number of times the user has failed at entering a password since that last
</span> successful password entry.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to retrieve the number of failed
 password attemts for the parent user.
 &lt;p&gt;
 The calling device admin must have requested {@link android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}
 to be able to call this method; if it has not, a security exception will be thrown.
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always empty and this method always returns 0.
@return {Number} The number of times user has entered an incorrect password since the last correct
         password entry.
@throws SecurityException if the calling application does not own an active administrator
             that uses {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}
*/
getCurrentFailedPasswordAttempts : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCurrentFailedPasswordAttempts'>/**Retrieve the number of times the given user has failed at entering a
</span> password since that last successful password entry.

 &lt;p&gt;The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call this method; if it has
 not and it is not the system uid, a security exception will be thrown.
@hide 
*/
getCurrentFailedPasswordAttempts : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDoNotAskCredentialsOnBoot'>/**Queries whether {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT} flag is set.
</span>@return {Boolean} true if RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT flag is set.
@hide 
*/
getDoNotAskCredentialsOnBoot : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setMaximumFailedPasswordsForWipe'>/**Setting this to a value greater than zero enables a built-in policy that will perform a
</span> device or profile wipe after too many incorrect device-unlock passwords have been entered.
 This built-in policy combines watching for failed passwords and wiping the device, and
 requires that you request both {@link android.app.admin.DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 &lt;p&gt;
 To implement any other policy (e.g. wiping data for a particular application only, erasing or
 revoking credentials, or reporting the failure to a server), you should implement
 {@link android.app.admin.DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)} instead. Do not
 use this API, because if the maximum count is reached, the device or profile will be wiped
 immediately, and your callback will not be invoked.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set a value on the parent
 profile.
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always empty and this method has no effect - i.e. the policy is not set.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} num The number of failed password attempts at which point the device or profile will
            be wiped.
@throws SecurityException if {@code admin} is not an active administrator or does not use
             both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
             {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}.
*/
setMaximumFailedPasswordsForWipe : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getMaximumFailedPasswordsForWipe'>/**Retrieve the current maximum number of login attempts that are allowed before the device
</span> or profile is wiped, for a particular admin or all admins that set restrictions on this user
 and its participating profiles. Restrictions on profiles that have a separate challenge are
 not taken into account.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 the value for the parent profile.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 password is always empty and this method returns a default value (0) indicating that the
 policy is not set.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate
 all admins.
*/
getMaximumFailedPasswordsForWipe : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getMaximumFailedPasswordsForWipe'>/**
</span>@hide per-user version
*/
getMaximumFailedPasswordsForWipe : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getProfileWithMinimumFailedPasswordsForWipe'>/**Returns the profile with the smallest maximum failed passwords for wipe,
</span> for the given user. So for primary user, it might return the primary or
 a managed profile. For a secondary user, it would be the same as the
 user passed in.
@hide Used only by Keyguard
*/
getProfileWithMinimumFailedPasswordsForWipe : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-resetPassword'>/**Force a new password for device unlock (the password needed to access the entire device) or
</span> the work profile challenge on the current user. This takes effect immediately.
 &lt;p&gt;
 &lt;em&gt;For device owner and profile owners targeting SDK level
 {@link android.os.Build.VERSION_CODES#O} or above, this API is no longer available and will
 throw {@link SecurityException}. Please use the new API {@link #resetPasswordWithToken}
 instead. &lt;/em&gt;
 &lt;p&gt;
 &lt;em&gt;Note: This API has been limited as of {@link android.os.Build.VERSION_CODES#N} for
 device admins that are not device owner and not profile owner.
 The password can now only be changed if there is currently no password set.  Device owner
 and profile owner can still do this when user is unlocked and does not have a managed
 profile.&lt;/em&gt;
 &lt;p&gt;
 The given password must be sufficient for the current password quality and length constraints
 as returned by {@link #getPasswordQuality}(ComponentName) and
 {@link #getPasswordMinimumLength}(ComponentName); if it does not meet these constraints, then
 it will be rejected and false returned. Note that the password may be a stronger quality
 (containing alphanumeric characters when the requested quality is only numeric), in which
 case the currently active quality will be increased to match.
 &lt;p&gt;
 Calling with a null or empty password will clear any existing PIN, pattern or password if the
 current password constraints allow it. &lt;em&gt;Note: This will not work in
 {@link android.os.Build.VERSION_CODES#N} and later for managed profiles, or for device admins
 that are not device owner or profile owner.  Once set, the password cannot be changed to null
 or empty except by these admins.&lt;/em&gt;
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, this
 methods does nothing.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call this method; if it has
 not, a security exception will be thrown.
@param {String} password The new password for the user. Null or empty clears the password.
@param {Number} flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and
            {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.
@return {Boolean} Returns true if the password was applied, or false if it is not acceptable for the
         current constraints or if the user has not been decrypted yet.
@throws SecurityException if the calling application does not own an active administrator
             that uses {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD}
@throws IllegalStateException if the calling user is locked or has a managed profile.
*/
resetPassword : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setResetPasswordToken'>/**Called by a profile or device owner to provision a token which can later be used to reset the
</span> device lockscreen password (if called by device owner), or managed profile challenge (if
 called by profile owner), via {@link #resetPasswordWithToken}.
 &lt;p&gt;
 If the user currently has a lockscreen password, the provisioned token will not be
 immediately usable; it only becomes active after the user performs a confirm credential
 operation, which can be triggered by {@link KeyguardManager#createConfirmDeviceCredentialIntent}.
 If the user has no lockscreen password, the token is activated immediately. In all cases,
 the active state of the current token can be checked by {@link #isResetPasswordTokenActive}.
 For security reasons, un-activated tokens are only stored in memory and will be lost once
 the device reboots. In this case a new token needs to be provisioned again.
 &lt;p&gt;
 Once provisioned and activated, the token will remain effective even if the user changes
 or clears the lockscreen password.
 &lt;p&gt;
 &lt;em&gt;This token is highly sensitive and should be treated at the same level as user
 credentials. In particular, NEVER store this token on device in plaintext. Do not store
 the plaintext token in device-encrypted storage if it will be needed to reset password on
 file-based encryption devices before user unlocks. Consider carefully how any password token
 will be stored on your server and who will need access to them. Tokens may be the subject of
 legal access requests.
 &lt;/em&gt;
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 reset token is not set and this method returns false.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {byte[]}} token a secure token a least 32-byte long, which must be generated by a
        cryptographically strong random number generator.
@return {Boolean} true if the operation is successful, false otherwise.
@throws SecurityException if admin is not a device or profile owner.
@throws IllegalArgumentException if the supplied token is invalid.
*/
setResetPasswordToken : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearResetPasswordToken'>/**Called by a profile or device owner to revoke the current password reset token.
</span>
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, this
 method has no effect - the reset token should not have been set in the first place - and
 false is returned.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Boolean} true if the operation is successful, false otherwise.
@throws SecurityException if admin is not a device or profile owner.
*/
clearResetPasswordToken : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isResetPasswordTokenActive'>/**Called by a profile or device owner to check if the current reset password token is active.
</span>
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,
 false is always returned.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Boolean} true if the token is active, false otherwise.
@throws SecurityException if admin is not a device or profile owner.
@throws IllegalStateException if no token has been set.
*/
isResetPasswordTokenActive : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-resetPasswordWithToken'>/**Called by device or profile owner to force set a new device unlock password or a managed
</span> profile challenge on current user. This takes effect immediately.
 &lt;p&gt;
 Unlike {@link #resetPassword}, this API can change the password even before the user or
 device is unlocked or decrypted. The supplied token must have been previously provisioned via
 {@link #setResetPasswordToken}, and in active state {@link #isResetPasswordTokenActive}.
 &lt;p&gt;
 The given password must be sufficient for the current password quality and length constraints
 as returned by {@link #getPasswordQuality}(ComponentName) and
 {@link #getPasswordMinimumLength}(ComponentName); if it does not meet these constraints, then
 it will be rejected and false returned. Note that the password may be a stronger quality, for
 example, a password containing alphanumeric characters when the requested quality is only
 numeric.
 &lt;p&gt;
 Calling with a {@code null} or empty password will clear any existing PIN, pattern or
 password if the current password constraints allow it.
 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,
 calling this methods has no effect - the password is always empty - and false is returned.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} password The new password for the user. {@code null} or empty clears the password.
@param {Object {byte[]}} token the password reset token previously provisioned by
        {@link #setResetPasswordToken}.
@param {Number} flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and
        {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.
@return {Boolean} Returns true if the password was applied, or false if it is not acceptable for the
         current constraints.
@throws SecurityException if admin is not a device or profile owner.
@throws IllegalStateException if the provided token is not valid.
*/
resetPasswordWithToken : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setMaximumTimeToLock'>/**Called by an application that is administering the device to set the maximum time for user
</span> activity until the device will lock. This limits the length that the user can set. It takes
 effect immediately.
 &lt;p&gt;
 The calling device admin must have requested {@link android.app.admin.DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 to be able to call this method; if it has not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} timeMs The new desired maximum time to lock in milliseconds. A value of 0 means there
            is no restriction.
@throws SecurityException if {@code admin} is not an active administrator or it does not use
             {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
*/
setMaximumTimeToLock : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getMaximumTimeToLock'>/**Retrieve the current maximum time to unlock for a particular admin or all admins that set
</span> restrictions on this user and its participating profiles. Restrictions on profiles that have
 a separate challenge are not taken into account.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate
 all admins.
@return {Number} time in milliseconds for the given admin or the minimum value (strictest) of
 all admins if admin is null. Returns 0 if there are no restrictions.
*/
getMaximumTimeToLock : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getMaximumTimeToLock'>/**
</span>@hide per-user version
*/
getMaximumTimeToLock : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setRequiredStrongAuthTimeout'>/**Called by a device/profile owner to set the timeout after which unlocking with secondary, non
</span> strong auth (e.g. fingerprint, face, trust agents) times out, i.e. the user has to use a
 strong authentication method like password, pin or pattern.

 &lt;p&gt;This timeout is used internally to reset the timer to require strong auth again after
 specified timeout each time it has been successfully used.

 &lt;p&gt;Fingerprint can also be disabled altogether using {@link #KEYGUARD_DISABLE_FINGERPRINT}.

 &lt;p&gt;Trust agents can also be disabled altogether using {@link #KEYGUARD_DISABLE_TRUST_AGENTS}.

 &lt;p&gt;The calling device admin must be a device or profile owner. If it is not,
 a {@link SecurityException} will be thrown.

 &lt;p&gt;The calling device admin can verify the value it has set by calling
 {@link #getRequiredStrongAuthTimeout}(ComponentName) and passing in its instance.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,
 calling this methods has no effect - i.e. the timeout is not set.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} timeoutMs The new timeout in milliseconds, after which the user will have to unlock
         with strong authentication method. A value of 0 means the admin is not participating
         in controlling the timeout.
         The minimum and maximum timeouts are platform-defined and are typically 1 hour and
         72 hours, respectively. Though discouraged, the admin may choose to require strong
         auth at all times using {@link #KEYGUARD_DISABLE_FINGERPRINT} and/or
         {@link #KEYGUARD_DISABLE_TRUST_AGENTS}.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setRequiredStrongAuthTimeout : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getRequiredStrongAuthTimeout'>/**Determine for how long the user will be able to use secondary, non strong auth for
</span> authentication, since last strong method authentication (password, pin or pattern) was used.
 After the returned timeout the user is required to use strong authentication method.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.

 &lt;p&gt;On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature,
 0 is returned to indicate that no timeout is configured.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to aggregate
         across all participating admins.
@return {Number} The timeout in milliseconds or 0 if not configured for the provided admin.
*/
getRequiredStrongAuthTimeout : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getRequiredStrongAuthTimeout'>/**
</span>@hide per-user version
*/
getRequiredStrongAuthTimeout : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-lockNow'>/**Make the device lock immediately, as if the lock screen timeout has expired at the point of
</span> this call.
 &lt;p&gt;
 The calling device admin must have requested {@link android.app.admin.DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 to be able to call this method; if it has not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to lock the parent profile.
 &lt;p&gt;
 Equivalent to calling {@link #lockNow}(int) with no flags.
@throws SecurityException if the calling application does not own an active administrator
             that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
*/
lockNow : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-lockNow'>/**Make the device lock immediately, as if the lock screen timeout has expired at the point of
</span> this call.
 &lt;p&gt;
 The calling device admin must have requested {@link android.app.admin.DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 to be able to call this method; if it has not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to lock the parent profile.
@param {Number} flags May be 0 or {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY}.
@throws SecurityException if the calling application does not own an active administrator
             that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} or the
             {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag is passed by an application
             that is not a profile
             owner of a managed profile.
@throws IllegalArgumentException if the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY} flag is
             passed when locking the parent profile.
@throws UnsupportedOperationException if the {@link #FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY}
             flag is passed when {@link #getStorageEncryptionStatus} does not return
             {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.
*/
lockNow : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-wipeData'>/**Ask that all user data be wiped. If called as a secondary user, the user will be removed and
</span> other users will remain unaffected. Calling from the primary user will cause the device to
 reboot, erasing all device data - including all the secondary users and their data - while
 booting up.
 &lt;p&gt;
 The calling device admin must have requested {@link android.app.admin.DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 be able to call this method; if it has not, a security exception will be thrown.
@param {Number} flags Bit mask of additional options: currently supported flags are
            {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA},
            {@link #WIPE_EUICC} and {@link #WIPE_SILENTLY}.
@throws SecurityException if the calling application does not own an active administrator
            that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
*/
wipeData : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-wipeData'>/**Ask that all user data be wiped. If called as a secondary user, the user will be removed and
</span> other users will remain unaffected, the provided reason for wiping data can be shown to
 user. Calling from the primary user will cause the device to reboot, erasing all device data
 - including all the secondary users and their data - while booting up. In this case, we don't
 show the reason to the user since the device would be factory reset.
 &lt;p&gt;
 The calling device admin must have requested {@link android.app.admin.DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 be able to call this method; if it has not, a security exception will be thrown.
@param {Number} flags Bit mask of additional options: currently supported flags are
            {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA} and
            {@link #WIPE_EUICC}.
@param {Object {CharSequence}} reason a string that contains the reason for wiping data, which can be
            presented to the user.
@throws SecurityException if the calling application does not own an active administrator
            that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
@throws IllegalArgumentException if the input reason string is null or empty, or if
            {@link #WIPE_SILENTLY} is set.
*/
wipeData : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setGlobalProxy'>/**Called by an application that is administering the device to set the
</span> global proxy and exclusion list.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call
 this method; if it has not, a security exception will be thrown.
 Only the first device admin can set the proxy. If a second admin attempts
 to set the proxy, the {@link ComponentName} of the admin originally setting the
 proxy will be returned. If successful in setting the proxy, {@code null} will
 be returned.
 The method can be called repeatedly by the device admin alrady setting the
 proxy to update the proxy and exclusion list.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {Proxy}} proxySpec the global proxy desired. Must be an HTTP Proxy.
            Pass Proxy.NO_PROXY to reset the proxy.
@param {Object {java.util.List}} exclusionList a list of domains to be excluded from the global proxy.
@return {Object {android.content.ComponentName}} {@code null} if the proxy was successfully set, or otherwise a {@link ComponentName}
            of the device admin that sets the proxy.
@hide 
*/
setGlobalProxy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setRecommendedGlobalProxy'>/**Set a network-independent global HTTP proxy. This is not normally what you want for typical
</span> HTTP proxies - they are generally network dependent. However if you're doing something
 unusual like general internal filtering this may be useful. On a private network where the
 proxy is not accessible, you may break HTTP using this.
 &lt;p&gt;
 This method requires the caller to be the device owner.
 &lt;p&gt;
 This proxy is only a recommendation and it is possible that some apps will ignore it.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {ProxyInfo}} proxyInfo The a {@link ProxyInfo} object defining the new global HTTP proxy. A
            {@code null} value will clear the global HTTP proxy.
@param proxyInfo The a {@link ProxyInfo} object defining the new global HTTP proxy. A
            {@code null} value will clear the global HTTP proxy.
@throws SecurityException if {@code admin} is not the device owner.
*/
setRecommendedGlobalProxy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getGlobalProxyAdmin'>/**Returns the component name setting the global proxy.
</span>@return {Object {android.content.ComponentName}} ComponentName object of the device admin that set the global proxy, or {@code null}
         if no admin has set the proxy.
@hide 
*/
getGlobalProxyAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setStorageEncryption'>/**Called by an application that is administering the device to request that the storage system
</span> be encrypted. Does nothing if the caller is on a secondary user or a managed profile.
 &lt;p&gt;
 When multiple device administrators attempt to control device encryption, the most secure,
 supported setting will always be used. If any device administrator requests device
 encryption, it will be enabled; Conversely, if a device administrator attempts to disable
 device encryption while another device administrator has enabled it, the call to disable will
 fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 &lt;p&gt;
 This policy controls encryption of the secure (application data) storage area. Data written
 to other storage areas may or may not be encrypted, and this policy does not require or
 control the encryption of any other storage areas. There is one exception: If
 {@link android.os.Environment#isExternalStorageEmulated()} is {@code true}, then the
 directory returned by {@link android.os.Environment#getExternalStorageDirectory()} must be
 written to disk within the encrypted storage area.
 &lt;p&gt;
 Important Note: On some devices, it is possible to encrypt storage without requiring the user
 to create a device PIN or Password. In this case, the storage is encrypted, but the
 encryption key may not be fully secured. For maximum security, the administrator should also
 require (and check for) a pattern, PIN, or password.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} encrypt true to request encryption, false to release any previous request
@return {Number} the new total request status (for all active admins), or {@link
         DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED} if called for a non-system user.
         Will be one of {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link
         #ENCRYPTION_STATUS_INACTIVE}, or {@link #ENCRYPTION_STATUS_ACTIVE}. This is the value
         of the requests; use {@link #getStorageEncryptionStatus()} to query the actual device
         state.
@throws SecurityException if {@code admin} is not an active administrator or does not use
             {@link DeviceAdminInfo#USES_ENCRYPTED_STORAGE}
*/
setStorageEncryption : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getStorageEncryption'>/**Called by an application that is administering the device to
</span> determine the requested setting for secure storage.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,
 this will return the requested encryption setting as an aggregate of all active
 administrators.
@return {Boolean} true if the admin(s) are requesting encryption, false if not.
*/
getStorageEncryption : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getStorageEncryptionStatus'>/**Called by an application that is administering the device to
</span> determine the current encryption status of the device.
 &lt;p&gt;
 Depending on the returned status code, the caller may proceed in different
 ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the
 storage system does not support encryption.  If the
 result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the
 storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, the
 storage system has enabled encryption but no password is set so further action
 may be required.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING},
 {@link #ENCRYPTION_STATUS_ACTIVE} or {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER},
 no further action is required.
@return {Number} current status of encryption. The value will be one of
 {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},
 {@link #ENCRYPTION_STATUS_ACTIVATING}, {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY},
 {@link #ENCRYPTION_STATUS_ACTIVE}, or {@link #ENCRYPTION_STATUS_ACTIVE_PER_USER}.
*/
getStorageEncryptionStatus : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getStorageEncryptionStatus'>/**
</span>@hide per-user version
*/
getStorageEncryptionStatus : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-approveCaCert'>/**Mark a CA certificate as approved by the device user. This means that they have been notified
</span> of the installation, were made aware of the risks, viewed the certificate and still wanted to
 keep the certificate on the device.

 Calling with {@param approval} as {@code true} will cancel any ongoing warnings related to
 this certificate.
@hide 
*/
approveCaCert : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isCaCertApproved'>/**Check whether a CA certificate has been approved by the device user.
</span>@hide 
*/
isCaCertApproved : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-installCaCert'>/**Installs the given certificate as a user CA.
</span> &lt;p&gt;
 Inserted user CAs aren't automatically trusted by apps in Android 7.0 (API level 24) and
 higher. App developers can change the default behavior for an app by adding a
 &lt;a href=&quot;{@docRoot}training/articles/security-config.html&quot;&gt;Security Configuration
 File&lt;/a&gt; to the app manifest file.

 The caller must be a profile or device owner on that user, or a delegate package given the
 {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a
 security exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
              {@code null} if calling from a delegated certificate installer.
@param {Object {byte[]}} certBuffer encoded form of the certificate to install.
@return {Boolean} false if the certBuffer cannot be parsed or installation is
         interrupted, true otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
@see #setDelegatedScopes
@see #DELEGATION_CERT_INSTALL
*/
installCaCert : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-uninstallCaCert'>/**Uninstalls the given certificate from trusted user CAs, if present.
</span>
 The caller must be a profile or device owner on that user, or a delegate package given the
 {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a
 security exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
              {@code null} if calling from a delegated certificate installer.
@param {Object {byte[]}} certBuffer encoded form of the certificate to remove.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
@see #setDelegatedScopes
@see #DELEGATION_CERT_INSTALL
*/
uninstallCaCert : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getInstalledCaCerts'>/**Returns all CA certificates that are currently trusted, excluding system CA certificates.
</span> If a user has installed any certificates by other means than device policy these will be
 included too.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
              {@code null} if calling from a delegated certificate installer.
@return {Object {java.util.List}} a List of byte[] arrays, each encoding one user CA certificate.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
*/
getInstalledCaCerts : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-uninstallAllUserCaCerts'>/**Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
</span> means other than device policy will also be removed, except for system CA certificates.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
              {@code null} if calling from a delegated certificate installer.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
*/
uninstallAllUserCaCerts : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-hasCaCertInstalled'>/**Returns whether this certificate is installed as a trusted CA.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
              {@code null} if calling from a delegated certificate installer.
@param {Object {byte[]}} certBuffer encoded form of the certificate to look up.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
*/
hasCaCertInstalled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-installKeyPair'>/**Called by a device or profile owner, or delegated certificate installer, to install a
</span> certificate and corresponding private key. All apps within the profile will be able to access
 the certificate and use the private key, given direct user approval.

 &lt;p&gt;Access to the installed credentials will not be granted to the caller of this API without
 direct user approval. This is for security - should a certificate installer become
 compromised, certificates it had already installed will be protected.

 &lt;p&gt;If the installer must have access to the credentials, call
 {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, boolean)} instead.

 &lt;p&gt;Note: If the provided {@code alias} is of an existing alias, all former grants that apps
 have been given to access the key and certificates associated with this alias will be
 revoked.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if calling from a delegated certificate installer.
@param {Object {PrivateKey}} privKey The private key to install.
@param {Object {Certificate}} cert The certificate to install.
@param {String} alias The private key alias under which to install the certificate. If a certificate
 with that alias already exists, it will be overwritten.
@return {Boolean} {@code true} if the keys were installed, {@code false} otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
@see #setDelegatedScopes
@see #DELEGATION_CERT_INSTALL
*/
installKeyPair : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-installKeyPair'>/**Called by a device or profile owner, or delegated certificate installer, to install a
</span> certificate chain and corresponding private key for the leaf certificate. All apps within the
 profile will be able to access the certificate chain and use the private key, given direct
 user approval.

 &lt;p&gt;The caller of this API may grant itself access to the certificate and private key
 immediately, without user approval. It is a best practice not to request this unless strictly
 necessary since it opens up additional security vulnerabilities.

 &lt;p&gt;Note: If the provided {@code alias} is of an existing alias, all former grants that apps
 have been given to access the key and certificates associated with this alias will be
 revoked.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
        {@code null} if calling from a delegated certificate installer.
@param {Object {PrivateKey}} privKey The private key to install.
@param {Object {java.security.cert.Certificate[]}} certs The certificate chain to install. The chain should start with the leaf
        certificate and include the chain of trust in order. This will be returned by
        {@link android.security.KeyChain#getCertificateChain}.
@param {String} alias The private key alias under which to install the certificate. If a certificate
        with that alias already exists, it will be overwritten.
@param {Boolean} requestAccess {@code true} to request that the calling app be granted access to the
        credentials immediately. Otherwise, access to the credentials will be gated by user
        approval.
@return {Boolean} {@code true} if the keys were installed, {@code false} otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
@see android.security.KeyChain#getCertificateChain
@see #setDelegatedScopes
@see #DELEGATION_CERT_INSTALL
*/
installKeyPair : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-installKeyPair'>/**Called by a device or profile owner, or delegated certificate installer, to install a
</span> certificate chain and corresponding private key for the leaf certificate. All apps within the
 profile will be able to access the certificate chain and use the private key, given direct
 user approval (if the user is allowed to select the private key).

 &lt;p&gt;The caller of this API may grant itself access to the certificate and private key
 immediately, without user approval. It is a best practice not to request this unless strictly
 necessary since it opens up additional security vulnerabilities.

 &lt;p&gt;Include {@link #INSTALLKEY_SET_USER_SELECTABLE} in the {@code flags} argument to allow
 the user to select the key from a dialog.

 &lt;p&gt;Note: If the provided {@code alias} is of an existing alias, all former grants that apps
 have been given to access the key and certificates associated with this alias will be
 revoked.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
        {@code null} if calling from a delegated certificate installer.
@param {Object {PrivateKey}} privKey The private key to install.
@param {Object {java.security.cert.Certificate[]}} certs The certificate chain to install. The chain should start with the leaf
        certificate and include the chain of trust in order. This will be returned by
        {@link android.security.KeyChain#getCertificateChain}.
@param {String} alias The private key alias under which to install the certificate. If a certificate
        with that alias already exists, it will be overwritten.
@param {Number} flags Flags to request that the calling app be granted access to the credentials
        and set the key to be user-selectable. See {@link #INSTALLKEY_SET_USER_SELECTABLE} and
        {@link #INSTALLKEY_REQUEST_CREDENTIALS_ACCESS}.
@return {Boolean} {@code true} if the keys were installed, {@code false} otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
@see android.security.KeyChain#getCertificateChain
@see #setDelegatedScopes
@see #DELEGATION_CERT_INSTALL
*/
installKeyPair : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-removeKeyPair'>/**Called by a device or profile owner, or delegated certificate installer, to remove a
</span> certificate and private key pair installed under a given alias.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
        {@code null} if calling from a delegated certificate installer.
@param {String} alias The private key alias under which the certificate is installed.
@return {Boolean} {@code true} if the private key alias no longer exists, {@code false} otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner.
@see #setDelegatedScopes
@see #DELEGATION_CERT_INSTALL
*/
removeKeyPair : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-generateKeyPair'>/**Called by a device or profile owner, or delegated certificate installer, to generate a
</span> new private/public key pair. If the device supports key generation via secure hardware,
 this method is useful for creating a key in KeyChain that never left the secure hardware.
 Access to the key is controlled the same way as in {@link #installKeyPair}.

 &lt;p&gt;Because this method might take several seconds to complete, it should only be called from
 a worker thread. This method returns {@code null} when called from the main thread.

 &lt;p&gt;Note: If the provided {@code alias} is of an existing alias, all former grants that apps
 have been given to access the key and certificates associated with this alias will be
 revoked.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if calling from a delegated certificate installer.
@param {String} algorithm The key generation algorithm, see {@link java.security.KeyPairGenerator}.
@param {Object {KeyGenParameterSpec}} keySpec Specification of the key to generate, see
 {@link java.security.KeyPairGenerator}.
@param {Number} idAttestationFlags A bitmask of all the identifiers that should be included in the
        attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},
        {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), or {@code 0} if no device
        identification is required in the attestation record.
        Device owner, profile owner and their delegated certificate installer can use
        {@link #ID_TYPE_BASE_INFO} to request inclusion of the general device information
        including manufacturer, model, brand, device and product in the attestation record.
        Only device owner and their delegated certificate installer can use
        {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID} to request
        unique device identifiers to be attested.
        &lt;p&gt;
        If any of {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID}
        is set, it is implicitly assumed that {@link #ID_TYPE_BASE_INFO} is also set.
        &lt;p&gt;
        If any flag is specified, then an attestation challenge must be included in the
        {@code keySpec}.
@return {Object {android.security.AttestedKeyPair}} A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner. If Device ID attestation is requested (using {@link #ID_TYPE_SERIAL},
         {@link #ID_TYPE_IMEI} or {@link #ID_TYPE_MEID}), the caller must be the Device Owner
         or the Certificate Installer delegate.
@throws IllegalArgumentException if the alias in {@code keySpec} is empty, if the
         algorithm specification in {@code keySpec} is not {@code RSAKeyGenParameterSpec}
         or {@code ECGenParameterSpec}, or if Device ID attestation was requested but the
         {@code keySpec} does not contain an attestation challenge.
@throws UnsupportedOperationException if Device ID attestation was requested but the
         underlying hardware does not support it.
@throws StrongBoxUnavailableException if the use of StrongBox for key generation was
         specified in {@code keySpec} but the device does not have one.
@see KeyGenParameterSpec.Builder#setAttestationChallenge(byte[])
*/
generateKeyPair : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceIdAttestationSupported'>/**Returns {@code true} if the device supports attestation of device identifiers in addition
</span> to key attestation.
@return {Boolean} {@code true} if Device ID attestation is supported.
*/
isDeviceIdAttestationSupported : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setKeyPairCertificate'>/**Called by a device or profile owner, or delegated certificate installer, to associate
</span> certificates with a key pair that was generated using {@link #generateKeyPair}, and
 set whether the key is available for the user to choose in the certificate selection
 prompt.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if calling from a delegated certificate installer.
@param {String} alias The private key alias under which to install the certificate. The {@code alias}
        should denote an existing private key. If a certificate with that alias already
        exists, it will be overwritten.
@param {Object {java.util.List}} certs The certificate chain to install. The chain should start with the leaf
        certificate and include the chain of trust in order. This will be returned by
        {@link android.security.KeyChain#getCertificateChain}.
@param {Boolean} isUserSelectable {@code true} to indicate that a user can select this key via the
        certificate selection prompt, {@code false} to indicate that this key can only be
        granted access by implementing
        {@link android.app.admin.DeviceAdminReceiver#onChoosePrivateKeyAlias}.
@return {Boolean} {@code true} if the provided {@code alias} exists and the certificates has been
        successfully associated with it, {@code false} otherwise.
@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
         owner, or {@code admin} is null but the calling application is not a delegated
         certificate installer.
*/
setKeyPairCertificate : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setCertInstallerPackage'>/**Called by a profile owner or device owner to grant access to privileged certificate
</span> manipulation APIs to a third-party certificate installer app. Granted APIs include
 {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},
 {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair}.
 &lt;p&gt;
 Delegated certificate installer is a per-user state. The delegated access is persistent until
 it is later cleared by calling this method with a null value or uninstallling the certificate
 installer.
 &lt;p&gt;
 &lt;b&gt;Note:&lt;/b&gt;Starting from {@link android.os.Build.VERSION_CODES#N}, if the caller
 application's target SDK version is {@link android.os.Build.VERSION_CODES#N} or newer, the
 supplied certificate installer package must be installed when calling this API, otherwise an
 {@link IllegalArgumentException} will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} installerPackage The package name of the certificate installer which will be given
            access. If {@code null} is given the current package will be cleared.
@throws SecurityException if {@code admin} is not a device or a profile owner.
@deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #setDelegatedScopes}
 with the {@link #DELEGATION_CERT_INSTALL} scope instead.
*/
setCertInstallerPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCertInstallerPackage'>/**Called by a profile owner or device owner to retrieve the certificate installer for the user,
</span> or {@code null} if none is set. If there are multiple delegates this function will return one
 of them.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {String} The package name of the current delegated certificate installer, or {@code null} if
         none is set.
@throws SecurityException if {@code admin} is not a device or a profile owner.
@deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatePackages}
 with the {@link #DELEGATION_CERT_INSTALL} scope instead.
*/
getCertInstallerPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDelegatedScopes'>/**Called by a profile owner or device owner to grant access to privileged APIs to another app.
</span> Granted APIs are determined by {@code scopes}, which is a list of the {@code DELEGATION_*}
 constants.
 &lt;p&gt;
 A broadcast with the {@link #ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED} action will be
 sent to the {@code delegatePackage} with its new scopes in an {@code ArrayList&lt;String&gt;} extra
 under the {@link #EXTRA_DELEGATION_SCOPES} key. The broadcast is sent with the
 {@link Intent#FLAG_RECEIVER_REGISTERED_ONLY} flag.
 &lt;p&gt;
 Delegated scopes are a per-user state. The delegated access is persistent until it is later
 cleared by calling this method with an empty {@code scopes} list or uninstalling the
 {@code delegatePackage}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} delegatePackage The package name of the app which will be given access.
@param {Object {java.util.List}} scopes The groups of privileged APIs whose access should be granted to
            {@code delegatedPackage}.
@throws SecurityException if {@code admin} is not a device or a profile owner.
*/
setDelegatedScopes : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDelegatedScopes'>/**Called by a profile owner or device owner to retrieve a list of the scopes given to a
</span> delegate package. Other apps can use this method to retrieve their own delegated scopes by
 passing {@code null} for {@code admin} and their own package name as
 {@code delegatedPackage}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is {@code delegatedPackage}.
@param {String} delegatedPackage The package name of the app whose scopes should be retrieved.
@return {Object {java.util.List}} A list containing the scopes given to {@code delegatedPackage}.
@throws SecurityException if {@code admin} is not a device or a profile owner.
*/
getDelegatedScopes : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDelegatePackages'>/**Called by a profile owner or device owner to retrieve a list of delegate packages that were
</span> granted a delegation scope.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} delegationScope The scope whose delegates should be retrieved.
@return {Object {java.util.List}} A list of package names of the current delegated packages for
               {@code delegationScope}.
@throws SecurityException if {@code admin} is not a device or a profile owner.
*/
getDelegatePackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setAlwaysOnVpnPackage'>/**Called by a device or profile owner to configure an always-on VPN connection through a
</span> specific application for the current user. This connection is automatically granted and
 persisted after a reboot.
 &lt;p&gt; To support the always-on feature, an app must
 &lt;ul&gt;
     &lt;li&gt;declare a {@link android.net.VpnService} in its manifest, guarded by
         {@link android.Manifest.permission#BIND_VPN_SERVICE};&lt;/li&gt;
     &lt;li&gt;target {@link android.os.Build.VERSION_CODES#N API 24} or above; and&lt;/li&gt;
     &lt;li&gt;&lt;i&gt;not&lt;/i&gt; explicitly opt out of the feature through
         {@link android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON}.&lt;/li&gt;
 &lt;/ul&gt;
 The call will fail if called with the package name of an unsupported VPN app.
 &lt;p&gt; Enabling lockdown via {@code lockdownEnabled} argument carries the risk that any failure
 of the VPN provider could break networking for all apps. This method clears any lockdown
 whitelist set by {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)}.
@param {Object {ComponentName}} vpnPackage The package name for an installed VPN app on the device, or {@code null} to
        remove an existing always-on VPN configuration.
@param {String} lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
        {@code false} otherwise. This has no effect when clearing.
@throws SecurityException if {@code admin} is not a device or a profile owner.
@throws NameNotFoundException if {@code vpnPackage} is not installed.
@throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being
         set as always-on, or if always-on VPN is not available.
@see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)
*/
setAlwaysOnVpnPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setAlwaysOnVpnPackage'>/**A version of {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} that allows the
</span> admin to specify a set of apps that should be able to access the network directly when VPN
 is not connected. When VPN connects these apps switch over to VPN if allowed to use that VPN.
 System apps can always bypass VPN.
 &lt;p&gt; Note that the system doesn't update the whitelist when packages are installed or
 uninstalled, the admin app must call this method to keep the list up to date.
 &lt;p&gt; When {@code lockdownEnabled} is false {@code lockdownWhitelist} is ignored . When
 {@code lockdownEnabled} is {@code true} and {@code lockdownWhitelist} is {@code null} or
 empty, only system apps can bypass VPN.
 &lt;p&gt; Setting always-on VPN package to {@code null} or using
 {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} clears lockdown whitelist.
@param {Object {ComponentName}} vpnPackage package name for an installed VPN app on the device, or {@code null}
         to remove an existing always-on VPN configuration
@param {String} lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
         {@code false} otherwise. This has no effect when clearing.
@param {Boolean} lockdownWhitelist Packages that will be able to access the network directly when VPN
         is in lockdown mode but not connected. Has no effect when clearing.
@throws SecurityException if {@code admin} is not a device or a profile
         owner.
@throws NameNotFoundException if {@code vpnPackage} or one of
         {@code lockdownWhitelist} is not installed.
@throws UnsupportedOperationException if {@code vpnPackage} exists but does
         not support being set as always-on, or if always-on VPN is not
         available.
*/
setAlwaysOnVpnPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isAlwaysOnVpnLockdownEnabled'>/**Called by device or profile owner to query whether current always-on VPN is configured in
</span> lockdown mode. Returns {@code false} when no always-on configuration is set.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a device or a profile owner.
@see #setAlwaysOnVpnPackage(ComponentName, String, boolean)
*/
isAlwaysOnVpnLockdownEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getAlwaysOnVpnLockdownWhitelist'>/**Called by device or profile owner to query the set of packages that are allowed to access
</span> the network directly when always-on VPN is in lockdown mode but not connected. Returns
 {@code null} when always-on VPN is not active or not in lockdown mode.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a device or a profile owner.
@see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)
*/
getAlwaysOnVpnLockdownWhitelist : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getAlwaysOnVpnPackage'>/**Called by a device or profile owner to read the name of the package administering an
</span> always-on VPN connection for the current user. If there is no such package, or the always-on
 VPN is provided by the system instead of by an application, {@code null} will be returned.
@return {String} Package name of VPN controller responsible for always-on VPN, or {@code null} if none
         is set.
@throws SecurityException if {@code admin} is not a device or a profile owner.
*/
getAlwaysOnVpnPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setCameraDisabled'>/**Called by an application that is administering the device to disable all cameras on the
</span> device, for this user. After setting this, no applications running as this user will be able
 to access any cameras on the device.
 &lt;p&gt;
 If the caller is device owner, then the restriction will be applied to all users.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 not, a security exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled Whether or not the camera should be disabled.
@throws SecurityException if {@code admin} is not an active administrator or does not use
             {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
*/
setCameraDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCameraDisabled'>/**Determine whether or not the device's cameras have been disabled for this user,
</span> either by the calling admin, if specified, or all admins.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to check whether any admins
 have disabled the camera
*/
getCameraDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCameraDisabled'>/**
</span>@hide per-user version
*/
getCameraDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-requestBugreport'>/**Called by a device owner to request a bugreport.
</span> &lt;p&gt;
 If the device contains secondary users or profiles, they must be affiliated with the device.
 Otherwise a {@link SecurityException} will be thrown. See {@link #isAffiliatedUser}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Boolean} {@code true} if the bugreport collection started successfully, or {@code false} if it
         wasn't triggered because a previous bugreport operation is still active (either the
         bugreport is still running or waiting for the user to share or decline)
@throws SecurityException if {@code admin} is not a device owner, or there is at least one
         profile or secondary user that is not affiliated with the device.
@see #isAffiliatedUser
*/
requestBugreport : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getGuestUserDisabled'>/**Determine whether or not creating a guest user has been disabled for the device
</span>@hide 
*/
getGuestUserDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setScreenCaptureDisabled'>/**Called by a device/profile owner to set whether the screen capture is disabled. Disabling
</span> screen capture also prevents the content from being shown on display devices that do not have
 a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 secure surfaces and secure displays.
 &lt;p&gt;
 The calling device admin must be a device or profile owner. If it is not, a security
 exception will be thrown.
 &lt;p&gt;
 From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also blocks
 assist requests for all activities of the relevant user.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled Whether screen capture is disabled or not.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setScreenCaptureDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getScreenCaptureDisabled'>/**Determine whether or not screen capture has been disabled by the calling
</span> admin, if specified, or all admins.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to check whether any admins
 have disabled screen capture.
*/
getScreenCaptureDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getScreenCaptureDisabled'>/**
</span>@hide per-user version
*/
getScreenCaptureDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setAutoTimeRequired'>/**Called by a device owner, or alternatively a profile owner from Android 8.0 (API level 26) or
</span> higher, to set whether auto time is required. If auto time is required, no user will be able
 set the date and time and network date and time will be used.
 &lt;p&gt;
 Note: if auto time is required the user can still manually set the time zone.
 &lt;p&gt;
 The calling device admin must be a device owner, or alternatively a profile owner from
 Android 8.0 (API level 26) or higher. If it is not, a security exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} required Whether auto time is set required or not.
@throws SecurityException if {@code admin} is not a device owner.
*/
setAutoTimeRequired : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getAutoTimeRequired'>/**
</span>@return {Boolean} true if auto time is required.
*/
getAutoTimeRequired : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setForceEphemeralUsers'>/**Called by a device owner to set whether all users created on the device should be ephemeral.
</span> &lt;p&gt;
 The system user is exempt from this policy - it is never ephemeral.
 &lt;p&gt;
 The calling device admin must be the device owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} forceEphemeralUsers If true, all the existing users will be deleted and all
            subsequently created users will be ephemeral.
@throws SecurityException if {@code admin} is not a device owner.
@hide 
*/
setForceEphemeralUsers : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getForceEphemeralUsers'>/**
</span>@return {Boolean} true if all users are created ephemeral.
@throws SecurityException if {@code admin} is not a device owner.
@hide 
*/
getForceEphemeralUsers : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setKeyguardDisabledFeatures'>/**Called by an application that is administering the device to disable keyguard customizations,
</span> such as widgets. After setting this, keyguard features will be disabled according to the
 provided feature list.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;
 if it has not, a security exception will be thrown.
 &lt;p&gt;
 Calling this from a managed profile before version {@link android.os.Build.VERSION_CODES#M}
 will throw a security exception. From version {@link android.os.Build.VERSION_CODES#M} the
 profile owner of a managed profile can set:
 &lt;ul&gt;
 &lt;li&gt;{@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which affects the parent user, but only if there
 is no separate challenge set on the managed profile.
 &lt;li&gt;{@link #KEYGUARD_DISABLE_FINGERPRINT}, {@link #KEYGUARD_DISABLE_FACE} or
 {@link #KEYGUARD_DISABLE_IRIS} which affects the managed profile challenge if
 there is one, or the parent user otherwise.
 &lt;li&gt;{@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS} which affects notifications generated
 by applications in the managed profile.
 &lt;/ul&gt;
 {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, {@link #KEYGUARD_DISABLE_FINGERPRINT},
 {@link #KEYGUARD_DISABLE_FACE} and {@link #KEYGUARD_DISABLE_IRIS} can also be
 set on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set restrictions on the parent
 profile.
 &lt;p&gt;
 Requests to disable other features on a managed profile will be ignored.
 &lt;p&gt;
 The admin can check which features have been disabled by calling
 {@link #getKeyguardDisabledFeatures}(ComponentName)
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} which The disabled features flag which can be either
            {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),
            {@link #KEYGUARD_DISABLE_FEATURES_ALL}, or a combination of
            {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},
            {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS},
            {@link #KEYGUARD_DISABLE_TRUST_AGENTS},
            {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS},
            {@link #KEYGUARD_DISABLE_FINGERPRINT},
            {@link #KEYGUARD_DISABLE_FACE},
            {@link #KEYGUARD_DISABLE_IRIS}.
@throws SecurityException if {@code admin} is not an active administrator or does not user
             {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}
*/
setKeyguardDisabledFeatures : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getKeyguardDisabledFeatures'>/**Determine whether or not features have been disabled in keyguard either by the calling
</span> admin, if specified, or all admins that set restrictions on this user and its participating
 profiles. Restrictions on profiles that have a separate challenge are not taken into account.

 &lt;p&gt;This method can be called on the {@link android.app.admin.DevicePolicyManager} instance
 returned by {@link #getParentProfileInstance}(ComponentName) in order to retrieve
 restrictions on the parent profile.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} to check whether any
 admins have disabled features in keyguard.
@return {Number} bitfield of flags. See {@link #setKeyguardDisabledFeatures(ComponentName, int)}
 for a list.
*/
getKeyguardDisabledFeatures : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getKeyguardDisabledFeatures'>/**
</span>@hide per-user version
*/
getKeyguardDisabledFeatures : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setActiveAdmin'>/**
</span>@hide 
*/
setActiveAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setActiveAdmin'>/**
</span>@hide 
*/
setActiveAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getRemoveWarning'>/**
</span>@hide 
*/
getRemoveWarning : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setActivePasswordState'>/**
</span>@hide 
*/
setActivePasswordState : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportPasswordChanged'>/**
</span>@hide 
*/
reportPasswordChanged : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportFailedPasswordAttempt'>/**
</span>@hide 
*/
reportFailedPasswordAttempt : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportSuccessfulPasswordAttempt'>/**
</span>@hide 
*/
reportSuccessfulPasswordAttempt : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportFailedBiometricAttempt'>/**
</span>@hide 
*/
reportFailedBiometricAttempt : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportSuccessfulBiometricAttempt'>/**
</span>@hide 
*/
reportSuccessfulBiometricAttempt : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportKeyguardDismissed'>/**Should be called when keyguard has been dismissed.
</span>@hide 
*/
reportKeyguardDismissed : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reportKeyguardSecured'>/**Should be called when keyguard view has been shown to the user.
</span>@hide 
*/
reportKeyguardSecured : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDeviceOwner'>/**
</span>@param {Object {ComponentName}} who the component name to be registered as device owner.
@param who the component name to be registered as device owner.
@return {Boolean} whether the package was successfully registered as the device owner.
@throws IllegalArgumentException if the package name is null or invalid
@throws IllegalStateException If the preconditions mentioned are not met.
*/
setDeviceOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDeviceOwner'>/**
</span>@hide 
*/
setDeviceOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDeviceOwner'>/**
</span>@hide 
*/
setDeviceOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDeviceOwner'>/**
</span>@param {Object {ComponentName}} who the component name to be registered as device owner.
@param {String} ownerName the human readable name of the institution that owns this device.
@param {Number} userId ID of the user on which the device owner runs.
@param userId ID of the user on which the device owner runs.
@return {Boolean} whether the package was successfully registered as the device owner.
@throws IllegalArgumentException if the package name is null or invalid
@throws IllegalStateException If the preconditions mentioned are not met.
*/
setDeviceOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceOwnerApp'>/**Used to determine if a particular package has been registered as a Device Owner app.
</span> A device owner app is a special device admin that cannot be deactivated by the user, once
 activated as a device admin. It also cannot be uninstalled. To check whether a particular
 package is currently registered as the device owner app, pass in the package name from
 {@link Context#getPackageName()} to this method.&lt;p/&gt;This is useful for device
 admin apps that want to check whether they are also registered as the device owner app. The
 exact mechanism by which a device admin app is registered as a device owner app is defined by
 the setup process.
@param {String} packageName the package name of the app, to compare with the registered device owner
 app, if any.
@return {Boolean} whether or not the package is registered as the device owner app.
*/
isDeviceOwnerApp : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceOwnerAppOnCallingUser'>/**
</span>@return {Boolean} true if a package is registered as device owner, only when it's running on the
 calling user.

 &lt;p&gt;Same as {@link #isDeviceOwnerApp}, but bundled code should use it for clarity.
@hide 
*/
isDeviceOwnerAppOnCallingUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceOwnerAppOnAnyUser'>/**
</span>@return {Boolean} true if a package is registered as device owner, even if it's running on a different
 user.

 &lt;p&gt;Requires the MANAGE_USERS permission.
@hide 
*/
isDeviceOwnerAppOnAnyUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerComponentOnCallingUser'>/**
</span>@return {Object {android.content.ComponentName}} device owner component name, only when it's running on the calling user.
@hide 
*/
getDeviceOwnerComponentOnCallingUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerComponentOnAnyUser'>/**
</span>@return {Object {android.content.ComponentName}} device owner component name, even if it's running on a different user.
@hide 
*/
getDeviceOwnerComponentOnAnyUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerUser'>/**
</span>@return {Object {android.os.UserHandle}} Handle of the user who runs device owner, or {@code null} if there's no device owner.
@hide 
*/
getDeviceOwnerUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerUserId'>/**
</span>@hide 
*/
getDeviceOwnerUserId : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearDeviceOwnerApp'>/**Clears the current device owner. The caller must be the device owner. This function should be
</span> used cautiously as once it is called it cannot be undone. The device owner can only be set as
 a part of device setup, before it completes.
 &lt;p&gt;
 While some policies previously set by the device owner will be cleared by this method, it is
 a best-effort process and some other policies will still remain in place after the device
 owner is cleared.
@param {String} packageName The package name of the device owner.
@throws SecurityException if the caller is not in {@code packageName} or {@code packageName}
             does not own the current device owner component.
@deprecated This method is expected to be used for testing purposes only. The device owner
 will lose control of the device and its data after calling it. In order to protect any
 sensitive data that remains on the device, it is advised that the device owner factory resets
 the device instead of calling this method. See {@link #wipeData(int)}.
*/
clearDeviceOwnerApp : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwner'>/**Returns the device owner package name, only if it's running on the calling user.
</span>
 &lt;p&gt;Bundled components should use {@code getDeviceOwnerComponentOnCallingUser()} for clarity.
@hide 
*/
getDeviceOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceManaged'>/**Called by the system to find out whether the device is managed by a Device Owner.
</span>@return {Boolean} whether the device is managed by a Device Owner.
@throws SecurityException if the caller is not the device owner, does not hold the
         MANAGE_USERS permission and is not the system.
@hide 
*/
isDeviceManaged : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerNameOnAnyUser'>/**Returns the device owner name.  Note this method *will* return the device owner
</span> name when it's running on a different user.
@hide 
*/
getDeviceOwnerNameOnAnyUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceInitializerApp'>/**
</span>@hide 
@deprecated Do not use
@removed 
*/
getDeviceInitializerApp : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceInitializerComponent'>/**
</span>@hide 
@deprecated Do not use
@removed 
*/
getDeviceInitializerComponent : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setActiveProfileOwner'>/**
</span>@param {Object {ComponentName}} admin The component to register as an active admin and profile owner.
@param {String} ownerName The user-visible name of the entity that is managing this user.
@param admin The component to register as an active admin and profile owner.
@param ownerName The user-visible name of the entity that is managing this user.
@return {Boolean} whether the admin was successfully registered as the profile owner.
@throws IllegalArgumentException if packageName is null, the package isn't installed, or
         the user has already been set up.
*/
setActiveProfileOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearProfileOwner'>/**Clears the active profile owner. The caller must be the profile owner of this user, otherwise
</span> a SecurityException will be thrown. This method is not available to managed profile owners.
 &lt;p&gt;
 While some policies previously set by the profile owner will be cleared by this method, it is
 a best-effort process and some other policies will still remain in place after the profile
 owner is cleared.
@param {Object {ComponentName}} admin The component to remove as the profile owner.
@throws SecurityException if {@code admin} is not an active profile owner, or the method is
 being called from a managed profile.
@deprecated This method is expected to be used for testing purposes only. The profile owner
 will lose control of the user and its data after calling it. In order to protect any
 sensitive data that remains on this user, it is advised that the profile owner deletes it
 instead of calling this method. See {@link #wipeData(int)}.
*/
clearProfileOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-hasUserSetupCompleted'>/**
</span>@hide Checks whether the user was already setup.
*/
hasUserSetupCompleted : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setProfileOwner'>/**
</span>@param {Object {ComponentName}} admin the component name to be registered as profile owner.
@param {String} ownerName the human readable name of the organisation associated with this DPM.
@param {Number} userHandle the userId to set the profile owner for.
@param userHandle the userId to set the profile owner for.
@return {Boolean} whether the component was successfully registered as the profile owner.
@throws IllegalArgumentException if admin is null, the package isn't installed, or the
 preconditions mentioned are not met.
*/
setProfileOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDeviceOwnerLockScreenInfo'>/**Sets the device owner information to be shown on the lock screen.
</span> &lt;p&gt;
 If the device owner information is {@code null} or empty then the device owner info is
 cleared and the user owner info is shown on the lock screen if it is set.
 &lt;p&gt;
 If the device owner information contains only whitespaces then the message on the lock screen
 will be blank and the user will not be allowed to change it.
 &lt;p&gt;
 If the device owner information needs to be localized, it is the responsibility of the
 {@link android.app.admin.DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast
 and set a new version of this string accordingly.
@param {Object {ComponentName}} admin The name of the admin component to check.
@param {Object {CharSequence}} info Device owner information which will be displayed instead of the user owner info.
@throws SecurityException if {@code admin} is not a device owner.
*/
setDeviceOwnerLockScreenInfo : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerLockScreenInfo'>/**
</span>@return {Object {java.lang.CharSequence}} The device owner information. If it is not set returns {@code null}.
*/
getDeviceOwnerLockScreenInfo : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPackagesSuspended'>/**Called by device or profile owners to suspend packages for this user. This function can be
</span> called by a device owner, profile owner, or by a delegate given the
 {@link #DELEGATION_PACKAGE_ACCESS} scope via {@link #setDelegatedScopes}.
 &lt;p&gt;
 A suspended package will not be able to start activities. Its notifications will be hidden,
 it will not show up in recents, will not be able to show toasts or dialogs or ring the
 device.
 &lt;p&gt;
 The package must already be installed. If the package is uninstalled while suspended the
 package will no longer be suspended. The admin can block this by using
 {@link #setUninstallBlocked}.
@param {Object {ComponentName}} admin The name of the admin component to check, or {@code null} if the caller is a
            package access delegate.
@param {Object {java.lang.String[]}} packageNames The package names to suspend or unsuspend.
@param {Boolean} suspended If set to {@code true} than the packages will be suspended, if set to
            {@code false} the packages will be unsuspended.
@return {String} an array of package names for which the suspended status is not set as requested in
         this method.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_PACKAGE_ACCESS
*/
setPackagesSuspended : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isPackageSuspended'>/**Determine if a package is suspended. This function can be called by a device owner, profile
</span> owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is a package access delegate.
@param {String} packageName The name of the package to retrieve the suspended status of.
@return {Boolean} {@code true} if the package is suspended or {@code false} if the package is not
         suspended, could not be found or an error occurred.
@throws SecurityException if {@code admin} is not a device or profile owner.
@throws NameNotFoundException if the package could not be found.
@see #setDelegatedScopes
@see #DELEGATION_PACKAGE_ACCESS
*/
isPackageSuspended : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setProfileEnabled'>/**Sets the enabled state of the profile. A profile should be enabled only once it is ready to
</span> be used. Only the profile owner can call this.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a profile owner.
*/
setProfileEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setProfileName'>/**Sets the name of the profile. In the device owner case it sets the name of the user which it
</span> is called from. Only a profile owner or device owner can call this. If this is never called
 by the profile or device owner, the name will be set to default values.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associate with.
@param {String} profileName The name of the profile.
@param admin Which {@link DeviceAdminReceiver} this request is associate with.
@param profileName The name of the profile.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setProfileName : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isProfileOwnerApp'>/**Used to determine if a particular package is registered as the profile owner for the
</span> user. A profile owner is a special device admin that has additional privileges
 within the profile.
@param {String} packageName The package name of the app to compare with the registered profile owner.
@return {Boolean} Whether or not the package is registered as the profile owner.
*/
isProfileOwnerApp : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getProfileOwner'>/**
</span>@hide 
@return {Object {android.content.ComponentName}} the packageName of the owner of the given user profile or {@code null} if no profile
 owner has been set for that user.
@throws IllegalArgumentException if the userId is invalid.
*/
getProfileOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getProfileOwnerAsUser'>/**
</span>@see #getProfileOwner()
@hide 
*/
getProfileOwnerAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getProfileOwnerAsUser'>/**
</span>@hide 
*/
getProfileOwnerAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getProfileOwnerName'>/**
</span>@hide 
@return {String} the human readable name of the organisation associated with this DPM or {@code null}
         if one is not set.
@throws IllegalArgumentException if the userId is invalid.
*/
getProfileOwnerName : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getProfileOwnerNameAsUser'>/**
</span>@param {Number} userId The user for whom to fetch the profile owner name, if any.
@param userId The user for whom to fetch the profile owner name, if any.
@return {String} the human readable name of the organisation associated with this profile owner or
         null if one is not set.
@throws IllegalArgumentException if the userId is invalid.
*/
getProfileOwnerNameAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-checkDeviceIdentifierAccess'>/**Returns whether the specified package can read the device identifiers.
</span>@param {String} packageName The package name of the app to check for device identifier access.
@param {Number} pid The process id of the package to be checked.
@param {Number} uid The uid of the package to be checked.
@return {Boolean} whether the package can read the device identifiers.
@hide 
*/
checkDeviceIdentifierAccess : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-addPersistentPreferredActivity'>/**Called by a profile owner or device owner to set a default activity that the system selects
</span> to handle intents that match the given {@link IntentFilter}. This activity will remain the
 default intent handler even if the set of potential event handlers for the intent filter
 changes and if the intent preferences are reset.
 &lt;p&gt;
 Note that the caller should still declare the activity in the manifest, the API just sets
 the activity to be the default one to handle the given intent filter.
 &lt;p&gt;
 The default disambiguation mechanism takes over if the activity is not installed (anymore).
 When the activity is (re)installed, it is automatically reset as default intent handler for
 the filter.
 &lt;p&gt;
 The calling device admin must be a profile owner or device owner. If it is not, a security
 exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {IntentFilter}} filter The IntentFilter for which a default handler is added.
@param {Object {ComponentName}} activity The Activity that is added as default intent handler.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
addPersistentPreferredActivity : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearPackagePersistentPreferredActivities'>/**Called by a profile owner or device owner to remove all persistent intent handler preferences
</span> associated with the given package that were set by {@link #addPersistentPreferredActivity}.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The name of the package for which preferences are removed.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
clearPackagePersistentPreferredActivities : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDefaultSmsApplication'>/**Called by a device owner to set the default SMS application.
</span> &lt;p&gt;
 The calling device admin must be a device owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The name of the package to set as the default SMS application.
@throws SecurityException if {@code admin} is not a device owner.
*/
setDefaultSmsApplication : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setApplicationRestrictionsManagingPackage'>/**Called by a profile owner or device owner to grant permission to a package to manage
</span> application restrictions for the calling user via {@link #setApplicationRestrictions} and
 {@link #getApplicationRestrictions}.
 &lt;p&gt;
 This permission is persistent until it is later cleared by calling this method with a
 {@code null} value or uninstalling the managing package.
 &lt;p&gt;
 The supplied application restriction managing package must be installed when calling this
 API, otherwise an {@link NameNotFoundException} will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The package name which will be given access to application restrictions
            APIs. If {@code null} is given the current package will be cleared.
@throws SecurityException if {@code admin} is not a device or profile owner.
@throws NameNotFoundException if {@code packageName} is not found
@deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #setDelegatedScopes}
 with the {@link #DELEGATION_APP_RESTRICTIONS} scope instead.
*/
setApplicationRestrictionsManagingPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getApplicationRestrictionsManagingPackage'>/**Called by a profile owner or device owner to retrieve the application restrictions managing
</span> package for the current user, or {@code null} if none is set. If there are multiple
 delegates this function will return one of them.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {String} The package name allowed to manage application restrictions on the current user, or
         {@code null} if none is set.
@throws SecurityException if {@code admin} is not a device or profile owner.
@deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatePackages}
 with the {@link #DELEGATION_APP_RESTRICTIONS} scope instead.
*/
getApplicationRestrictionsManagingPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isCallerApplicationRestrictionsManagingPackage'>/**Called by any application to find out whether it has been granted permission via
</span> {@link #setApplicationRestrictionsManagingPackage} to manage application restrictions
 for the calling user.

 &lt;p&gt;This is done by comparing the calling Linux uid with the uid of the package specified by
 that method.
@deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatedScopes}
 instead.
*/
isCallerApplicationRestrictionsManagingPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setApplicationRestrictions'>/**Sets the application restrictions for a given target application running in the calling user.
</span> &lt;p&gt;
 The caller must be a profile or device owner on that user, or the package allowed to manage
 application restrictions via {@link #setDelegatedScopes} with the
 {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.
 &lt;p&gt;
 The provided {@link Bundle} consists of key-value pairs, where the types of values may be:
 &lt;ul&gt;
 &lt;li&gt;{@code boolean}
 &lt;li&gt;{@code int}
 &lt;li&gt;{@code String} or {@code String[]}
 &lt;li&gt;From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 &lt;/ul&gt;
 &lt;p&gt;
 If the restrictions are not available yet, but may be applied in the near future, the caller
 can notify the target application of that by adding
 {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.
 &lt;p&gt;
 The application restrictions are only made visible to the target application via
 {@link UserManager#getApplicationRestrictions(String)}, in addition to the profile or device
 owner, and the application restrictions managing package via
 {@link #getApplicationRestrictions}.

 &lt;p&gt;NOTE: The method performs disk I/O and shouldn't be called on the main thread
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if called by the application restrictions managing package.
@param {String} packageName The name of the package to update restricted settings for.
@param {Object {Bundle}} settings A {@link Bundle} to be parsed by the receiving application, conveying a new
            set of active restrictions.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_APP_RESTRICTIONS
@see UserManager#KEY_RESTRICTIONS_PENDING
*/
setApplicationRestrictions : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setTrustAgentConfiguration'>/**Sets a list of configuration features to enable for a trust agent component. This is meant to
</span> be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all trust
 agents but those enabled by this function call. If flag
 {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.
 &lt;p&gt;
 For any specific trust agent, whether it is disabled or not depends on the aggregated state
 of each admin's {@link #KEYGUARD_DISABLE_TRUST_AGENTS} setting and its trust agent
 configuration as set by this function call. In particular: if any admin sets
 {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and does not additionally set any
 trust agent configuration, the trust agent is disabled completely. Otherwise, the trust agent
 will receive the list of configurations from all admins who set
 {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and aggregate the configurations to determine its
 behavior. The exact meaning of aggregation is trust-agent-specific.
 &lt;p&gt;
 The calling device admin must have requested
 {@link android.app.admin.DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;
 if not, a security exception will be thrown.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to set the configuration for
 the parent profile.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, calling
 this method has no effect - no trust agent configuration will be set.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {ComponentName}} target Component name of the agent to be configured.
@param {Object {PersistableBundle}} configuration Trust-agent-specific feature configuration bundle. Please consult
        documentation of the specific trust agent to determine the interpretation of this
        bundle.
@throws SecurityException if {@code admin} is not an active administrator or does not use
             {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}
*/
setTrustAgentConfiguration : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getTrustAgentConfiguration'>/**Gets configuration for the given trust agent based on aggregating all calls to
</span> {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)} for
 all device admins.
 &lt;p&gt;
 This method can be called on the {@link android.app.admin.DevicePolicyManager} instance returned by
 {@link #getParentProfileInstance}(ComponentName) in order to retrieve the configuration set
 on the parent profile.
 &lt;p&gt;
 On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, null is
 always returned.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with. If null,
 this function returns a list of configurations for all admins that declare
 {@link #KEYGUARD_DISABLE_TRUST_AGENTS}. If any admin declares
 {@link #KEYGUARD_DISABLE_TRUST_AGENTS} but doesn't call
 {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)}
 for this {@param agent} or calls it with a null configuration, null is returned.
@param {Object {ComponentName}} agent Which component to get enabled features for.
@return {Object {java.util.List}} configuration for the given trust agent.
*/
getTrustAgentConfiguration : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getTrustAgentConfiguration'>/**
</span>@hide per-user version
*/
getTrustAgentConfiguration : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setCrossProfileCallerIdDisabled'>/**Called by a profile owner of a managed profile to set whether caller-Id information from the
</span> managed profile will be shown in the parent profile, for incoming calls.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled If true caller-Id information in the managed profile is not displayed.
@throws SecurityException if {@code admin} is not a profile owner.
*/
setCrossProfileCallerIdDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileCallerIdDisabled'>/**Called by a profile owner of a managed profile to determine whether or not caller-Id
</span> information has been disabled.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a profile owner.
*/
getCrossProfileCallerIdDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileCallerIdDisabled'>/**Determine whether or not caller-Id information has been disabled.
</span>@param {Object {UserHandle}} userHandle The user for whom to check the caller-id permission
@hide 
*/
getCrossProfileCallerIdDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setCrossProfileContactsSearchDisabled'>/**Called by a profile owner of a managed profile to set whether contacts search from the
</span> managed profile will be shown in the parent profile, for incoming calls.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled If true contacts search in the managed profile is not displayed.
@throws SecurityException if {@code admin} is not a profile owner.
*/
setCrossProfileContactsSearchDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileContactsSearchDisabled'>/**Called by a profile owner of a managed profile to determine whether or not contacts search
</span> has been disabled.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a profile owner.
*/
getCrossProfileContactsSearchDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileContactsSearchDisabled'>/**Determine whether or not contacts search has been disabled.
</span>@param {Object {UserHandle}} userHandle The user for whom to check the contacts search permission
@hide 
*/
getCrossProfileContactsSearchDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-startManagedQuickContact'>/**Start Quick Contact on the managed profile for the user, if the policy allows.
</span>@hide 
*/
startManagedQuickContact : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-startManagedQuickContact'>/**Start Quick Contact on the managed profile for the user, if the policy allows.
</span>@hide 
*/
startManagedQuickContact : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setBluetoothContactSharingDisabled'>/**Called by a profile owner of a managed profile to set whether bluetooth devices can access
</span> enterprise contacts.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
 &lt;p&gt;
 This API works on managed profile only.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled If true, bluetooth devices cannot access enterprise contacts.
@throws SecurityException if {@code admin} is not a profile owner.
*/
setBluetoothContactSharingDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getBluetoothContactSharingDisabled'>/**Called by a profile owner of a managed profile to determine whether or not Bluetooth devices
</span> cannot access enterprise contacts.
 &lt;p&gt;
 The calling device admin must be a profile owner. If it is not, a security exception will be
 thrown.
 &lt;p&gt;
 This API works on managed profile only.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a profile owner.
*/
getBluetoothContactSharingDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getBluetoothContactSharingDisabled'>/**Determine whether or not Bluetooth devices cannot access contacts.
</span> &lt;p&gt;
 This API works on managed profile UserHandle only.
@param {Object {UserHandle}} userHandle The user for whom to check the caller-id permission
@hide 
*/
getBluetoothContactSharingDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-addCrossProfileIntentFilter'>/**Called by the profile owner of a managed profile so that some intents sent in the managed
</span> profile can also be resolved in the parent, or vice versa. Only activity intents are
 supported.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {IntentFilter}} filter The {@link IntentFilter} the intent has to match to be also resolved in the
            other profile
@param {Number} flags {@link DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT} and
            {@link DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED} are supported.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
addCrossProfileIntentFilter : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearCrossProfileIntentFilters'>/**Called by a profile owner of a managed profile to remove the cross-profile intent filters
</span> that go from the managed profile to the parent, or from the parent to the managed profile.
 Only removes those that have been set by the profile owner.
 &lt;p&gt;
 &lt;em&gt;Note&lt;/em&gt;: A list of default cross profile intent filters are set up by the system when
 the profile is created, some of them ensure the proper functioning of the profile, while
 others enable sharing of data from the parent to the managed profile for user convenience.
 These default intent filters are not cleared when this API is called. If the default cross
 profile data sharing is not desired, they can be disabled with
 {@link UserManager#DISALLOW_SHARE_INTO_MANAGED_PROFILE}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a profile owner.
*/
clearCrossProfileIntentFilters : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPermittedAccessibilityServices'>/**Called by a profile or device owner to set the permitted
</span> {@link android.accessibilityservice.AccessibilityService}. When set by
 a device owner or profile owner the restriction applies to all profiles of the user the
 device owner or profile owner is an admin for. By default, the user can use any accessibility
 service. When zero or more packages have been added, accessibility services that are not in
 the list and not part of the system can not be enabled by the user.
 &lt;p&gt;
 Calling with a null value for the list disables the restriction so that all services can be
 used, calling with an empty list only allows the built-in system services. Any non-system
 accessibility service that's currently enabled must be included in the list.
 &lt;p&gt;
 System accessibility services are always available to the user the list can't modify this.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {java.util.List}} packageNames List of accessibility service package names.
@return {Boolean} {@code true} if the operation succeeded, or {@code false} if the list didn't
         contain every enabled non-system accessibility service.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setPermittedAccessibilityServices : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermittedAccessibilityServices'>/**Returns the list of permitted accessibility services set by this device or profile owner.
</span> &lt;p&gt;
 An empty list means no accessibility services except system services are allowed. Null means
 all accessibility services are allowed.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.util.List}} List of accessiblity service package names.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
getPermittedAccessibilityServices : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isAccessibilityServicePermittedByAdmin'>/**Called by the system to check if a specific accessibility service is disabled by admin.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName Accessibility service package name that needs to be checked.
@param {Number} userHandle user id the admin is running as.
@return {Boolean} true if the accessibility service is permitted, otherwise false.
@hide 
*/
isAccessibilityServicePermittedByAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermittedAccessibilityServices'>/**Returns the list of accessibility services permitted by the device or profiles
</span> owners of this user.

 &lt;p&gt;Null means all accessibility services are allowed, if a non-null list is returned
 it will contain the intersection of the permitted lists for any device or profile
 owners that apply to this user. It will also include any system accessibility services.
@param {Number} userId which user to check for.
@return {Object {java.util.List}} List of accessiblity service package names.
@hide 
*/
getPermittedAccessibilityServices : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPermittedInputMethods'>/**Called by a profile or device owner to set the permitted input methods services for this
</span> user. By default, the user can use any input method.
 &lt;p&gt;
 When zero or more packages have been added, input method that are not in the list and not
 part of the system can not be enabled by the user. This method will fail if it is called for
 a admin that is not for the foreground user or a profile of the foreground user. Any
 non-system input method service that's currently enabled must be included in the list.
 &lt;p&gt;
 Calling with a null value for the list disables the restriction so that all input methods can
 be used, calling with an empty list disables all but the system's own input methods.
 &lt;p&gt;
 System input methods are always available to the user - this method can't modify this.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {java.util.List}} packageNames List of input method package names.
@return {Boolean} {@code true} if the operation succeeded, or {@code false} if the list didn't
        contain every enabled non-system input method service.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setPermittedInputMethods : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermittedInputMethods'>/**Returns the list of permitted input methods set by this device or profile owner.
</span> &lt;p&gt;
 An empty list means no input methods except system input methods are allowed. Null means all
 input methods are allowed.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.util.List}} List of input method package names.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
getPermittedInputMethods : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isInputMethodPermittedByAdmin'>/**Called by the system to check if a specific input method is disabled by admin.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName Input method package name that needs to be checked.
@param {Number} userHandle user id the admin is running as.
@return {Boolean} true if the input method is permitted, otherwise false.
@hide 
*/
isInputMethodPermittedByAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermittedInputMethodsForCurrentUser'>/**Returns the list of input methods permitted by the device or profiles owners.
</span>
 &lt;p&gt;On {@link android.os.Build.VERSION_CODES#Q} and later devices, this method returns the
 result for the calling user.&lt;/p&gt;

 &lt;p&gt;On Android P and prior devices, this method returns the result for the current user.&lt;/p&gt;

 &lt;p&gt;Null means all input methods are allowed, if a non-null list is returned
 it will contain the intersection of the permitted lists for any device or profile
 owners that apply to this user. It will also include any system input methods.
@return {Object {java.util.List}} List of input method package names.
@hide 
*/
getPermittedInputMethodsForCurrentUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPermittedCrossProfileNotificationListeners'>/**Called by a profile owner of a managed profile to set the packages that are allowed to use
</span> a {@link android.service.notification.NotificationListenerService} in the primary user to
 see notifications from the managed profile. By default all packages are permitted by this
 policy. When zero or more packages have been added, notification listeners installed on the
 primary user that are not in the list and are not part of the system won't receive events
 for managed profile notifications.
 &lt;p&gt;
 Calling with a {@code null} value for the list disables the restriction so that all
 notification listener services be used. Calling with an empty list disables all but the
 system's own notification listeners. System notification listener services are always
 available to the user.
 &lt;p&gt;
 If a device or profile owner want to stop notification listeners in their user from seeing
 that user's notifications they should prevent that service from running instead (e.g. via
 {@link #setApplicationHidden(ComponentName, String, boolean)})
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {java.util.List}} packageList List of package names to whitelist
@return {Boolean} true if setting the restriction succeeded. It will fail if called outside a managed
 profile
@throws SecurityException if {@code admin} is not a profile owner.
@see android.service.notification.NotificationListenerService
*/
setPermittedCrossProfileNotificationListeners : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermittedCrossProfileNotificationListeners'>/**Returns the list of packages installed on the primary user that allowed to use a
</span> {@link android.service.notification.NotificationListenerService} to receive
 notifications from this managed profile, as set by the profile owner.
 &lt;p&gt;
 An empty list means no notification listener services except system ones are allowed.
 A {@code null} return value indicates that all notification listeners are allowed.
*/
getPermittedCrossProfileNotificationListeners : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isNotificationListenerServicePermitted'>/**Returns true if {@code NotificationListenerServices} from the given package are allowed to
</span> receive events for notifications from the given user id. Can only be called by the system uid
@see #setPermittedCrossProfileNotificationListeners(ComponentName, List)
@hide 
*/
isNotificationListenerServicePermitted : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getKeepUninstalledPackages'>/**Get the list of apps to keep around as APKs even if no user has currently installed it. This
</span> function can be called by a device owner or by a delegate given the
 {@link #DELEGATION_KEEP_UNINSTALLED_PACKAGES} scope via {@link #setDelegatedScopes}.
 &lt;p&gt;
 Please note that packages returned in this method are not automatically pre-cached.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is a keep uninstalled packages delegate.
@return {Object {java.util.List}} List of package names to keep cached.
@see #setDelegatedScopes
@see #DELEGATION_KEEP_UNINSTALLED_PACKAGES
*/
getKeepUninstalledPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setKeepUninstalledPackages'>/**Set a list of apps to keep around as APKs even if no user has currently installed it. This
</span> function can be called by a device owner or by a delegate given the
 {@link #DELEGATION_KEEP_UNINSTALLED_PACKAGES} scope via {@link #setDelegatedScopes}.

 &lt;p&gt;Please note that setting this policy does not imply that specified apps will be
 automatically pre-cached.&lt;/p&gt;
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is a keep uninstalled packages delegate.
@param {Object {java.util.List}} packageNames List of package names to keep cached.
@throws SecurityException if {@code admin} is not a device owner.
@see #setDelegatedScopes
@see #DELEGATION_KEEP_UNINSTALLED_PACKAGES
*/
setKeepUninstalledPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-createUser'>/**Called by a device owner to create a user with the specified name. The UserHandle returned
</span> by this method should not be persisted as user handles are recycled as users are removed and
 created. If you need to persist an identifier for this user, use
 {@link UserManager#getSerialNumberForUser}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} name the user's name
@see UserHandle
@return {Object {android.os.UserHandle}} the {@link android.os.UserHandle} object for the created user, or {@code null} if the
         user could not be created.
@deprecated From {@link android.os.Build.VERSION_CODES#M}
@removed From {@link android.os.Build.VERSION_CODES#N}
*/
createUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-createAndInitializeUser'>/**Called by a device owner to create a user with the specified name. The UserHandle returned
</span> by this method should not be persisted as user handles are recycled as users are removed and
 created. If you need to persist an identifier for this user, use
 {@link UserManager#getSerialNumberForUser}.  The new user will be started in the background
 immediately.

 &lt;p&gt; profileOwnerComponent is the {@link android.app.admin.DeviceAdminReceiver} to be the profile owner as well
 as registered as an active admin on the new user.  The profile owner package will be
 installed on the new user if it already is installed on the device.

 &lt;p&gt;If the optionalInitializeData is not null, then the extras will be passed to the
 profileOwnerComponent when onEnable is called.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} name the user's name
@param {String} ownerName the human readable name of the organisation associated with this DPM.
@param {Object {ComponentName}} profileOwnerComponent The {@link DeviceAdminReceiver} that will be an active admin on
      the user.
@param {Object {Bundle}} adminExtras Extras that will be passed to onEnable of the admin receiver
      on the new user.
@see UserHandle
@return {Object {android.os.UserHandle}} the {@link android.os.UserHandle} object for the created user, or {@code null} if the
         user could not be created.
@deprecated From {@link android.os.Build.VERSION_CODES#M}
@removed From {@link android.os.Build.VERSION_CODES#N}
*/
createAndInitializeUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-createAndManageUser'>/**Called by a device owner to create a user with the specified name and a given component of
</span> the calling package as profile owner. The UserHandle returned by this method should not be
 persisted as user handles are recycled as users are removed and created. If you need to
 persist an identifier for this user, use {@link UserManager#getSerialNumberForUser}. The new
 user will not be started in the background.
 &lt;p&gt;
 admin is the {@link android.app.admin.DeviceAdminReceiver} which is the device owner. profileOwner is also a
 DeviceAdminReceiver in the same package as admin, and will become the profile owner and will
 be registered as an active admin on the new user. The profile owner package will be installed
 on the new user.
 &lt;p&gt;
 If the adminExtras are not null, they will be stored on the device until the user is started
 for the first time. Then the extras will be passed to the admin when onEnable is called.
 &lt;p&gt;From {@link android.os.Build.VERSION_CODES#P} onwards, if targeting
 {@link android.os.Build.VERSION_CODES#P}, throws {@link UserOperationException} instead of
 returning {@code null} on failure.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} name The user's name.
@param {Object {ComponentName}} profileOwner Which {@link DeviceAdminReceiver} will be profile owner. Has to be in the
            same package as admin, otherwise no user is created and an
            IllegalArgumentException is thrown.
@param {Object {PersistableBundle}} adminExtras Extras that will be passed to onEnable of the admin receiver on the new
            user.
@param {Number} flags {@link #SKIP_SETUP_WIZARD}, {@link #MAKE_USER_EPHEMERAL} and
        {@link #LEAVE_ALL_SYSTEM_APPS_ENABLED} are supported.
@see UserHandle
@return {Object {android.os.UserHandle}} the {@link android.os.UserHandle} object for the created user, or {@code null} if the
         user could not be created.
@throws SecurityException if {@code admin} is not a device owner.
@throws UserOperationException if the user could not be created and the calling app is
 targeting {@link android.os.Build.VERSION_CODES#P} and running on
 {@link android.os.Build.VERSION_CODES#P}.
*/
createAndManageUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-removeUser'>/**Called by a device owner to remove a user/profile and all associated data. The primary user
</span> can not be removed.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {UserHandle}} userHandle the user to remove.
@return {Boolean} {@code true} if the user was removed, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
*/
removeUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-switchUser'>/**Called by a device owner to switch the specified secondary user to the foreground.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {UserHandle}} userHandle the user to switch to; null will switch to primary.
@return {Boolean} {@code true} if the switch was successful, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
@see Intent#ACTION_USER_FOREGROUND
@see #getSecondaryUsers(ComponentName)
*/
switchUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-startUserInBackground'>/**Called by a device owner to start the specified secondary user in background.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {UserHandle}} userHandle the user to be started in background.
@return {Number} one of the following result codes:
 {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 {@link UserManager#USER_OPERATION_SUCCESS},
 {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 {@link UserManager#USER_OPERATION_ERROR_MAX_RUNNING_USERS},
@throws SecurityException if {@code admin} is not a device owner.
@see #getSecondaryUsers(ComponentName)
*/
startUserInBackground : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-stopUser'>/**Called by a device owner to stop the specified secondary user.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {UserHandle}} userHandle the user to be stopped.
@return {Number} one of the following result codes:
 {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 {@link UserManager#USER_OPERATION_SUCCESS},
 {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
@throws SecurityException if {@code admin} is not a device owner.
@see #getSecondaryUsers(ComponentName)
*/
stopUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-logoutUser'>/**Called by a profile owner of secondary user that is affiliated with the device to stop the
</span> calling user and switch back to primary.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Number} one of the following result codes:
 {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 {@link UserManager#USER_OPERATION_SUCCESS},
 {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
@throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
@see #getSecondaryUsers(ComponentName)
*/
logoutUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getSecondaryUsers'>/**Called by a device owner to list all secondary users on the device. Managed profiles are not
</span> considered as secondary users.
 &lt;p&gt; Used for various user management APIs, including {@link #switchUser}, {@link #removeUser}
 and {@link #stopUser}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.util.List}} list of other {@link UserHandle}s on the device.
@throws SecurityException if {@code admin} is not a device owner.
@see #removeUser(ComponentName, UserHandle)
@see #switchUser(ComponentName, UserHandle)
@see #startUserInBackground(ComponentName, UserHandle)
@see #stopUser(ComponentName, UserHandle)
*/
getSecondaryUsers : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isEphemeralUser'>/**Checks if the profile owner is running in an ephemeral user.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Boolean} whether the profile owner is running in an ephemeral user.
*/
isEphemeralUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getApplicationRestrictions'>/**Retrieves the application restrictions for a given target application running in the calling
</span> user.
 &lt;p&gt;
 The caller must be a profile or device owner on that user, or the package allowed to manage
 application restrictions via {@link #setDelegatedScopes} with the
 {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.

 &lt;p&gt;NOTE: The method performs disk I/O and shouldn't be called on the main thread
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if called by the application restrictions managing package.
@param {String} packageName The name of the package to fetch restricted settings of.
@return {Object {android.os.Bundle}} {@link Bundle} of settings corresponding to what was set last time
         {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty
         {@link Bundle} if no restrictions have been set.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_APP_RESTRICTIONS
*/
getApplicationRestrictions : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-addUserRestriction'>/**Called by a profile or device owner to set a user restriction specified by the key.
</span> &lt;p&gt;
 The calling device admin must be a profile or device owner; if it is not, a security
 exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} key The key of the restriction. See the constants in {@link android.os.UserManager}
            for the list of keys.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
addUserRestriction : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearUserRestriction'>/**Called by a profile or device owner to clear a user restriction specified by the key.
</span> &lt;p&gt;
 The calling device admin must be a profile or device owner; if it is not, a security
 exception will be thrown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} key The key of the restriction. See the constants in {@link android.os.UserManager}
            for the list of keys.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
clearUserRestriction : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getUserRestrictions'>/**Called by a profile or device owner to get user restrictions set with
</span> {@link #addUserRestriction(ComponentName, String)}.
 &lt;p&gt;
 The target user may have more restrictions set by the system or other device owner / profile
 owner. To get all the user restrictions currently set, use
 {@link UserManager#getUserRestrictions()}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
getUserRestrictions : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-createAdminSupportIntent'>/**Called by any app to display a support dialog when a feature was disabled by an admin.
</span> This returns an intent that can be used with {@link Context#startActivity(Intent)} to
 display the dialog. It will tell the user that the feature indicated by {@code restriction}
 was disabled by an admin, and include a link for more information. The default content of
 the dialog can be changed by the restricting admin via
 {@link #setShortSupportMessage(ComponentName, CharSequence)}. If the restriction is not
 set (i.e. the feature is available), then the return value will be {@code null}.
@param {String} restriction Indicates for which feature the dialog should be displayed. Can be a
            user restriction from {@link UserManager}, e.g.
            {@link UserManager#DISALLOW_ADJUST_VOLUME}, or one of the constants
            {@link #POLICY_DISABLE_CAMERA} or {@link #POLICY_DISABLE_SCREEN_CAPTURE}.
@return {Object {android.content.Intent}} Intent An intent to be used to start the dialog-activity if the restriction is
            set by an admin, or null if the restriction does not exist or no admin set it.
*/
createAdminSupportIntent : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setApplicationHidden'>/**Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and
</span> actual package file remain. This function can be called by a device owner, profile owner, or
 by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is a package access delegate.
@param {String} packageName The name of the package to hide or unhide.
@param {Boolean} hidden {@code true} if the package should be hidden, {@code false} if it should be
            unhidden.
@return {Boolean} boolean Whether the hidden setting of the package was successfully updated.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_PACKAGE_ACCESS
*/
setApplicationHidden : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isApplicationHidden'>/**Determine if a package is hidden. This function can be called by a device owner, profile
</span> owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is a package access delegate.
@param {String} packageName The name of the package to retrieve the hidden status of.
@return {Boolean} boolean {@code true} if the package is hidden, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_PACKAGE_ACCESS
*/
isApplicationHidden : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-enableSystemApp'>/**Re-enable a system app that was disabled by default when the user was initialized. This
</span> function can be called by a device owner, profile owner, or by a delegate given the
 {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is an enable system app delegate.
@param {String} packageName The package to be re-enabled in the calling profile.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_PACKAGE_ACCESS
*/
enableSystemApp : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-enableSystemApp'>/**Re-enable system apps by intent that were disabled by default when the user was initialized.
</span> This function can be called by a device owner, profile owner, or by a delegate given the
 {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
            {@code null} if the caller is an enable system app delegate.
@param {Object {Intent}} intent An intent matching the app(s) to be installed. All apps that resolve for this
            intent will be re-enabled in the calling profile.
@return {Number} int The number of activities that matched the intent and were installed.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_PACKAGE_ACCESS
*/
enableSystemApp : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-installExistingPackage'>/**Install an existing package that has been installed in another user, or has been kept after
</span> removal via {@link #setKeepUninstalledPackages}.
 This function can be called by a device owner, profile owner or a delegate given
 the {@link #DELEGATION_INSTALL_EXISTING_PACKAGE} scope via {@link #setDelegatedScopes}.
 When called in a secondary user or managed profile, the user/profile must be affiliated with
 the device. See {@link #isAffiliatedUser}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The package to be installed in the calling profile.
@return {Boolean} {@code true} if the app is installed; {@code false} otherwise.
@throws SecurityException if {@code admin} is not the device owner, or the profile owner of
 an affiliated user or profile.
@see #setKeepUninstalledPackages
@see #setDelegatedScopes
@see #isAffiliatedUser
@see #DELEGATION_PACKAGE_ACCESS
*/
installExistingPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setAccountManagementDisabled'>/**Called by a device owner or profile owner to disable account management for a specific type
</span> of account.
 &lt;p&gt;
 The calling device admin must be a device owner or profile owner. If it is not, a security
 exception will be thrown.
 &lt;p&gt;
 When account management is disabled for an account type, adding or removing an account of
 that type will not be possible.
 &lt;p&gt;
 From {@link android.os.Build.VERSION_CODES#N} the profile or device owner can still use
 {@link android.accounts.AccountManager} APIs to add or remove accounts when account
 management for a specific type is disabled.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} accountType For which account management is disabled or enabled.
@param {Boolean} disabled The boolean indicating that account management will be disabled (true) or
            enabled (false).
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setAccountManagementDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getAccountTypesWithManagementDisabled'>/**Gets the array of accounts for which account management is disabled by the profile owner.
</span>
 &lt;p&gt; Account management can be disabled/enabled by calling
 {@link #setAccountManagementDisabled}.
@return {String} a list of account types for which account management has been disabled.
@see #setAccountManagementDisabled
*/
getAccountTypesWithManagementDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getAccountTypesWithManagementDisabledAsUser'>/**
</span>@see #getAccountTypesWithManagementDisabled()
@hide 
*/
getAccountTypesWithManagementDisabledAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setLockTaskPackages'>/**Sets which packages may enter lock task mode.
</span> &lt;p&gt;
 Any packages that share uid with an allowed package will also be allowed to activate lock
 task. From {@link android.os.Build.VERSION_CODES#M} removing packages from the lock task
 package list results in locked tasks belonging to those packages to be finished.
 &lt;p&gt;
 This function can only be called by the device owner, a profile owner of an affiliated user
 or profile, or the profile owner when no device owner is set. See {@link #isAffiliatedUser}.
 Any package set via this method will be cleared if the user becomes unaffiliated.
@param {Object {ComponentName}} packages The list of packages allowed to enter lock task mode
@param {Object {java.lang.String[]}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
 affiliated user or profile, or the profile owner when no device owner is set.
@see #isAffiliatedUser
@see Activity#startLockTask()
@see DeviceAdminReceiver#onLockTaskModeEntering(Context, Intent, String)
@see DeviceAdminReceiver#onLockTaskModeExiting(Context, Intent)
@see UserManager#DISALLOW_CREATE_WINDOWS
*/
setLockTaskPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLockTaskPackages'>/**Returns the list of packages allowed to start the lock task mode.
</span>@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
 affiliated user or profile, or the profile owner when no device owner is set.
@see #isAffiliatedUser
@see #setLockTaskPackages
*/
getLockTaskPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isLockTaskPermitted'>/**This function lets the caller know whether the given component is allowed to start the
</span> lock task mode.
@param {String} pkg The package to check
*/
isLockTaskPermitted : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setLockTaskFeatures'>/**Sets which system features are enabled when the device runs in lock task mode. This method
</span> doesn't affect the features when lock task mode is inactive. Any system features not included
 in {@code flags} are implicitly disabled when calling this method. By default, only
 {@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS} is enabled—all the other features are disabled. To
 disable the global actions dialog, call this method omitting
 {@link #LOCK_TASK_FEATURE_GLOBAL_ACTIONS}.

 &lt;p&gt;This method can only be called by the device owner, a profile owner of an affiliated
 user or profile, or the profile owner when no device owner is set. See
 {@link #isAffiliatedUser}.
 Any features set using this method are cleared if the user becomes unaffiliated.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} flags The system features enabled during lock task mode.
@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
 affiliated user or profile, or the profile owner when no device owner is set.
@see #isAffiliatedUser
*/
setLockTaskFeatures : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLockTaskFeatures'>/**Gets which system features are enabled for LockTask mode.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Number} bitfield of flags. See {@link #setLockTaskFeatures(ComponentName, int)} for a list.
@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
 affiliated user or profile, or the profile owner when no device owner is set.
@see #isAffiliatedUser
@see #setLockTaskFeatures
*/
getLockTaskFeatures : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setGlobalSetting'>/**Called by device owner to update {@link android.provider.Settings.Global} settings.
</span> Validation that the value of the setting is in the correct form for the setting type should
 be performed by the caller.
 &lt;p&gt;
 The settings that can be updated with this method are:
 &lt;ul&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#ADB_ENABLED}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#AUTO_TIME}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#AUTO_TIME_ZONE}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#DATA_ROAMING}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#WIFI_SLEEP_POLICY}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN} This setting is only
 available from {@link android.os.Build.VERSION_CODES#M} onwards and can only be set if
 {@link #setMaximumTimeToLock} is not used to set a timeout.&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN}&lt;/li&gt; This
 setting is only available from {@link android.os.Build.VERSION_CODES#M} onwards.&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 Changing the following settings has no effect as of {@link android.os.Build.VERSION_CODES#M}:
 &lt;ul&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#BLUETOOTH_ON}. Use
 {@link android.bluetooth.BluetoothAdapter#enable()} and
 {@link android.bluetooth.BluetoothAdapter#disable()} instead.&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#MODE_RINGER}. Use
 {@link android.media.AudioManager#setRingerMode(int)} instead.&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#NETWORK_PREFERENCE}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Global#WIFI_ON}. Use
 {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)} instead.&lt;/li&gt;
 &lt;/ul&gt;
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} setting The name of the setting to update.
@param {String} value The value to update the setting to.
@throws SecurityException if {@code admin} is not a device owner.
*/
setGlobalSetting : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setSystemSetting'>/**Called by a device or profile owner to update {@link android.provider.Settings.System}
</span> settings. Validation that the value of the setting is in the correct form for the setting
 type should be performed by the caller.
 &lt;p&gt;
 The settings that can be updated by a device owner or profile owner of secondary user with
 this method are:
 &lt;ul&gt;
 &lt;li&gt;{@link android.provider.Settings.System#SCREEN_BRIGHTNESS}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.System#SCREEN_BRIGHTNESS_MODE}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.System#SCREEN_OFF_TIMEOUT}&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} setting The name of the setting to update.
@param {String} value The value to update the setting to.
@param value The value to update the setting to.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setSystemSetting : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setTime'>/**Called by device owner to set the system wall clock time. This only takes effect if called
</span> when {@link android.provider.Settings.Global#AUTO_TIME} is 0, otherwise {@code false} will be
 returned.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with
@param {Number} millis time in milliseconds since the Epoch
@return {Boolean} {@code true} if set time succeeded, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
*/
setTime : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setTimeZone'>/**Called by device owner to set the system's persistent default time zone. This only takes
</span> effect if called when {@link android.provider.Settings.Global#AUTO_TIME_ZONE} is 0, otherwise
 {@code false} will be returned.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with
@param {String} timeZone one of the Olson ids from the list returned by
     {@link java.util.TimeZone#getAvailableIDs}
@param timeZone one of the Olson ids from the list returned by
     {@link java.util.TimeZone#getAvailableIDs}
@return {Boolean} {@code true} if set timezone succeeded, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
*/
setTimeZone : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setSecureSetting'>/**Called by profile or device owners to update {@link android.provider.Settings.Secure}
</span> settings. Validation that the value of the setting is in the correct form for the setting
 type should be performed by the caller.
 &lt;p&gt;
 The settings that can be updated by a profile or device owner with this method are:
 &lt;ul&gt;
 &lt;li&gt;{@link android.provider.Settings.Secure#DEFAULT_INPUT_METHOD}&lt;/li&gt;
 &lt;li&gt;{@link android.provider.Settings.Secure#SKIP_FIRST_USE_HINTS}&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 A device owner can additionally update the following settings:
 &lt;ul&gt;
 &lt;li&gt;{@link android.provider.Settings.Secure#LOCATION_MODE}&lt;/li&gt;
 &lt;/ul&gt;

 &lt;strong&gt;Note: Starting from Android O, apps should no longer call this method with the
 setting {@link android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS}, which is
 deprecated. Instead, device owners or profile owners should use the restriction
 {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES}.
 If any app targeting {@link android.os.Build.VERSION_CODES#O} or higher calls this method
 with {@link android.provider.Settings.Secure#INSTALL_NON_MARKET_APPS},
 an {@link UnsupportedOperationException} is thrown.

 Starting from Android Q, the device and profile owner can also call
 {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY} to restrict unknown sources for
 all users.
 &lt;/strong&gt;
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} setting The name of the setting to update.
@param {String} value The value to update the setting to.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setSecureSetting : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setRestrictionsProvider'>/**Designates a specific service component as the provider for making permission requests of a
</span> local or remote administrator of the user.
 &lt;p/&gt;
 Only a profile owner can designate the restrictions provider.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {ComponentName}} provider The component name of the service that implements
            {@link RestrictionsReceiver}. If this param is null, it removes the restrictions
            provider previously assigned.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setRestrictionsProvider : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setMasterVolumeMuted'>/**Called by profile or device owners to set the master volume mute on or off.
</span> This has no effect when set on a managed profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} on {@code true} to mute master volume, {@code false} to turn mute off.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setMasterVolumeMuted : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isMasterVolumeMuted'>/**Called by profile or device owners to check whether the master volume mute is on or off.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Boolean} {@code true} if master volume is muted, {@code false} if it's not.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
isMasterVolumeMuted : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setUninstallBlocked'>/**Change whether a user can uninstall a package. This function can be called by a device owner,
</span> profile owner, or by a delegate given the {@link #DELEGATION_BLOCK_UNINSTALL} scope via
 {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
             {@code null} if the caller is a block uninstall delegate.
@param {String} packageName package to change.
@param {Boolean} uninstallBlocked true if the user shouldn't be able to uninstall the package.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setDelegatedScopes
@see #DELEGATION_BLOCK_UNINSTALL
*/
setUninstallBlocked : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isUninstallBlocked'>/**Check whether the user has been blocked by device policy from uninstalling a package.
</span> Requires the caller to be the profile owner if checking a specific admin's policy.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; Starting from {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}, the
 behavior of this API is changed such that passing {@code null} as the {@code admin} parameter
 will return if any admin has blocked the uninstallation. Before L MR1, passing {@code null}
 will cause a NullPointerException to be raised.
@param {Object {ComponentName}} admin The name of the admin component whose blocking policy will be checked, or
            {@code null} to check whether any admin has blocked the uninstallation.
@param {String} packageName package to check.
@return {Boolean} true if uninstallation is blocked.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
isUninstallBlocked : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-addCrossProfileWidgetProvider'>/**Called by the profile owner of a managed profile to enable widget providers from a given
</span> package to be available in the parent profile. As a result the user will be able to add
 widgets from the white-listed package running under the profile to a widget host which runs
 under the parent profile, for example the home screen. Note that a package may have zero or
 more provider components, where each component provides a different widget type.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; By default no widget provider package is white-listed.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The package from which widget providers are white-listed.
@return {Boolean} Whether the package was added.
@throws SecurityException if {@code admin} is not a profile owner.
@see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
@see #getCrossProfileWidgetProviders(android.content.ComponentName)
*/
addCrossProfileWidgetProvider : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-removeCrossProfileWidgetProvider'>/**Called by the profile owner of a managed profile to disable widget providers from a given
</span> package to be available in the parent profile. For this method to take effect the package
 should have been added via
 {@link #addCrossProfileWidgetProvider( android.content.ComponentName, String)}.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; By default no widget provider package is white-listed.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The package from which widget providers are no longer white-listed.
@return {Boolean} Whether the package was removed.
@throws SecurityException if {@code admin} is not a profile owner.
@see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
@see #getCrossProfileWidgetProviders(android.content.ComponentName)
*/
removeCrossProfileWidgetProvider : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileWidgetProviders'>/**Called by the profile owner of a managed profile to query providers from which packages are
</span> available in the parent profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.util.List}} The white-listed package list.
@see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
@see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
@throws SecurityException if {@code admin} is not a profile owner.
*/
getCrossProfileWidgetProviders : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setUserIcon'>/**Called by profile or device owners to set the user's photo.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {Bitmap}} icon the bitmap to set as the photo.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setUserIcon : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setSystemUpdatePolicy'>/**Called by device owners to set a local system update policy. When a new policy is set,
</span> {@link #ACTION_SYSTEM_UPDATE_POLICY_CHANGED} is broadcasted.
 &lt;p&gt;
 If the supplied system update policy has freeze periods set but the freeze periods do not
 meet 90-day maximum length or 60-day minimum separation requirement set out in
 {@link android.app.admin.SystemUpdatePolicy#setFreezePeriods},
 {@link android.app.admin.SystemUpdatePolicy.ValidationFailedException} will the thrown. Note that the system
 keeps a record of freeze periods the device experienced previously, and combines them with
 the new freeze periods to be set when checking the maximum freeze length and minimum freeze
 separation constraints. As a result, freeze periods that passed validation during
 {@link android.app.admin.SystemUpdatePolicy#setFreezePeriods} might fail the additional checks here due to
 the freeze period history. If this is causing issues during development,
 {@code adb shell dpm clear-freeze-period-record} can be used to clear the record.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with. All
            components in the device owner package can set system update policies and the most
            recent policy takes effect.
@param {Object {SystemUpdatePolicy}} policy the new policy, or {@code null} to clear the current policy.
@throws SecurityException if {@code admin} is not a device owner.
@throws IllegalArgumentException if the policy type or maintenance window is not valid.
@throws SystemUpdatePolicy.ValidationFailedException if the policy's freeze period does not
             meet the requirement.
@see SystemUpdatePolicy
@see SystemUpdatePolicy#setFreezePeriods(List)
*/
setSystemUpdatePolicy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getSystemUpdatePolicy'>/**Retrieve a local system update policy set previously by {@link #setSystemUpdatePolicy}.
</span>@return {Object {android.app.admin.SystemUpdatePolicy}} The current policy object, or {@code null} if no policy is set.
*/
getSystemUpdatePolicy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearSystemUpdatePolicyFreezePeriodRecord'>/**Reset record of previous system update freeze period the device went through.
</span> Only callable by ADB.
@hide 
*/
clearSystemUpdatePolicyFreezePeriodRecord : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setKeyguardDisabled'>/**Called by a device owner or profile owner of secondary users that is affiliated with the
</span> device to disable the keyguard altogether.
 &lt;p&gt;
 Setting the keyguard to disabled has the same effect as choosing &quot;None&quot; as the screen lock
 type. However, this call has no effect if a password, pin or pattern is currently set. If a
 password, pin or pattern is set after the keyguard was disabled, the keyguard stops being
 disabled.

 &lt;p&gt;
 As of {@link android.os.Build.VERSION_CODES#P}, this call also dismisses the
 keyguard if it is currently shown.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled {@code true} disables the keyguard, {@code false} reenables it.
@return {Boolean} {@code false} if attempting to disable the keyguard while a lock password was in
         place. {@code true} otherwise.
@throws SecurityException if {@code admin} is not the device owner, or a profile owner of
 secondary user that is affiliated with the device.
@see #isAffiliatedUser
@see #getSecondaryUsers
*/
setKeyguardDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setStatusBarDisabled'>/**Called by device owner or profile owner of secondary users  that is affiliated with the
</span> device to disable the status bar. Disabling the status bar blocks notifications, quick
 settings and other screen overlays that allow escaping from a single use device.
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; This method has no effect for LockTask mode. The behavior of the
 status bar in LockTask mode can be configured with
 {@link #setLockTaskFeatures(ComponentName, int)}. Calls to this method when the device is in
 LockTask mode will be registered, but will only take effect when the device leaves LockTask
 mode.

 &lt;p&gt;This policy does not have any effect while on the lock screen, where the status bar will
 not be disabled. Using LockTask instead of this method is recommended.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} disabled {@code true} disables the status bar, {@code false} reenables it.
@return {Boolean} {@code false} if attempting to disable the status bar failed. {@code true} otherwise.
@throws SecurityException if {@code admin} is not the device owner, or a profile owner of
 secondary user that is affiliated with the device.
@see #isAffiliatedUser
@see #getSecondaryUsers
*/
setStatusBarDisabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-notifyPendingSystemUpdate'>/**Called by the system update service to notify device and profile owners of pending system
</span> updates.

 This method should only be used when it is unknown whether the pending system
 update is a security patch. Otherwise, use
 {@link #notifyPendingSystemUpdate(long, boolean)}.
@param {Number} updateReceivedTime The time as given by {@link System#currentTimeMillis()}
         indicating when the current pending update was first available. {@code -1} if no
         update is available.
@see #notifyPendingSystemUpdate(long, boolean)
@hide 
*/
notifyPendingSystemUpdate : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-notifyPendingSystemUpdate'>/**Called by the system update service to notify device and profile owners of pending system
</span> updates.

 This method should be used instead of {@link #notifyPendingSystemUpdate}(long)
 when it is known whether the pending system update is a security patch.
@param {Number} updateReceivedTime The time as given by {@link System#currentTimeMillis()}
         indicating when the current pending update was first available. {@code -1} if no
         update is available.
@param {Boolean} isSecurityPatch {@code true} if this system update is purely a security patch;
         {@code false} if not.
@see #notifyPendingSystemUpdate(long)
@hide 
*/
notifyPendingSystemUpdate : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPendingSystemUpdate'>/**Called by device or profile owners to get information about a pending system update.
</span>@param {Object {ComponentName}} admin Which profile or device owner this request is associated with.
@return {Object {android.app.admin.SystemUpdateInfo}} Information about a pending system update or {@code null} if no update pending.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see DeviceAdminReceiver#onSystemUpdatePending(Context, Intent, long)
*/
getPendingSystemUpdate : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPermissionPolicy'>/**Set the default response for future runtime permission requests by applications. This
</span> function can be called by a device owner, profile owner, or by a delegate given the
 {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 The policy can allow for normal operation which prompts the user to grant a permission, or
 can allow automatic granting or denying of runtime permission requests by an application.
 This also applies to new permissions declared by app updates. When a permission is denied or
 granted this way, the effect is equivalent to setting the permission * grant state via
 {@link #setPermissionGrantState}.
 &lt;p/&gt;
 As this policy only acts on runtime permission requests, it only applies to applications
 built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
@param {Object {ComponentName}} admin Which profile or device owner this request is associated with.
@param {Number} policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},
            {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setPermissionGrantState
@see #setDelegatedScopes
@see #DELEGATION_PERMISSION_GRANT
*/
setPermissionPolicy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermissionPolicy'>/**Returns the current runtime permission policy set by the device or profile owner. The
</span> default is {@link #PERMISSION_POLICY_PROMPT}.
@param {Object {ComponentName}} admin Which profile or device owner this request is associated with.
@return {Number} the current policy for future permission requests.
*/
getPermissionPolicy : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setPermissionGrantState'>/**Sets the grant state of a runtime permission for a specific application. The state can be
</span> {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,
 {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user
 cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which
 the permission is granted and the user cannot manage it through the UI. This method can only
 be called by a profile owner, device owner, or a delegate given the
 {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 &lt;p/&gt;
 Note that user cannot manage other permissions in the affected group through the UI
 either and their granted state will be kept as the current value. Thus, it's recommended that
 you set the grant state of all the permissions in the affected group.
 &lt;p/&gt;
 Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke
 the permission. It retains the previous grant, if any.
 &lt;p/&gt;
 Device admins with a {@code targetSdkVersion} &amp;lt; {@link android.os.Build.VERSION_CODES#Q}
 cannot grant and revoke permissions for applications built with a {@code targetSdkVersion}
 &amp;lt; {@link android.os.Build.VERSION_CODES#M}.
 &lt;p/&gt;
 Admins with a {@code targetSdkVersion} &amp;ge; {@link android.os.Build.VERSION_CODES#Q} can
 grant and revoke permissions of all apps. Similar to the user revoking a permission from a
 application built with a {@code targetSdkVersion} &amp;lt;
 {@link android.os.Build.VERSION_CODES#M} the app-op matching the permission is set to
 {@link android.app.AppOpsManager#MODE_IGNORED}, but the permission stays granted.
@param {Object {ComponentName}} admin Which profile or device owner this request is associated with.
@param {String} packageName The application to grant or revoke a permission to.
@param {String} permission The permission to grant or revoke.
@param {Number} grantState The permission grant state which is one of
            {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
            {@link #PERMISSION_GRANT_STATE_GRANTED},
@return {Boolean} whether the permission was successfully granted or revoked.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #PERMISSION_GRANT_STATE_DENIED
@see #PERMISSION_GRANT_STATE_DEFAULT
@see #PERMISSION_GRANT_STATE_GRANTED
@see #setDelegatedScopes
@see #DELEGATION_PERMISSION_GRANT
*/
setPermissionGrantState : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getPermissionGrantState'>/**Returns the current grant state of a runtime permission for a specific application. This
</span> function can be called by a device owner, profile owner, or by a delegate given the
 {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
@param {Object {ComponentName}} admin Which profile or device owner this request is associated with, or {@code null}
            if the caller is a permission grant delegate.
@param {String} packageName The application to check the grant state for.
@param {String} permission The permission to check for.
@return {Number} the current grant state specified by device policy. If the profile or device owner
         has not set a grant state, the return value is
         {@link #PERMISSION_GRANT_STATE_DEFAULT}. This does not indicate whether or not the
         permission is currently granted for the package.
         &lt;p/&gt;
         If a grant state was set by the profile or device owner, then the return value will
         be one of {@link #PERMISSION_GRANT_STATE_DENIED} or
         {@link #PERMISSION_GRANT_STATE_GRANTED}, which indicates if the permission is
         currently denied or granted.
@throws SecurityException if {@code admin} is not a device or profile owner.
@see #setPermissionGrantState(ComponentName, String, String, int)
@see PackageManager#checkPermission(String, String)
@see #setDelegatedScopes
@see #DELEGATION_PERMISSION_GRANT
*/
getPermissionGrantState : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isProvisioningAllowed'>/**Returns whether it is possible for the caller to initiate provisioning of a managed profile
</span> or device, setting itself as the device or profile owner.
@param {String} action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},
 {@link #ACTION_PROVISION_MANAGED_PROFILE}.
@return {Boolean} whether provisioning a managed profile or device is possible.
@throws IllegalArgumentException if the supplied action is not valid.
*/
isProvisioningAllowed : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-checkProvisioningPreCondition'>/**Checks whether it is possible to initiate provisioning a managed device,
</span> profile or user, setting the given package as owner.
@param {String} action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},
        {@link #ACTION_PROVISION_MANAGED_PROFILE},
        {@link #ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE},
        {@link #ACTION_PROVISION_MANAGED_USER}
@param {String} packageName The package of the component that would be set as device, user, or profile
        owner.
@return {Number} A {@link ProvisioningPreCondition} value indicating whether provisioning is allowed.
@hide 
*/
checkProvisioningPreCondition : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isManagedProfile'>/**Return if this user is a managed profile of another user. An admin can become the profile
</span> owner of a managed profile with {@link #ACTION_PROVISION_MANAGED_PROFILE} and of a managed
 user with {@link #createAndManageUser}
@param {Object {ComponentName}} admin Which profile owner this request is associated with.
@return {Boolean} if this user is a managed profile of another user.
*/
isManagedProfile : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isSystemOnlyUser'>/**
</span>@param {Object {ComponentName}} admin Which device owner this request is associated with.
@param admin Which device owner this request is associated with.
@return {Boolean} if this user is a system-only user.
*/
isSystemOnlyUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getWifiMacAddress'>/**Called by device owner to get the MAC address of the Wi-Fi device.
</span>@param {Object {ComponentName}} admin Which device owner this request is associated with.
@return {String} the MAC address of the Wi-Fi device, or null when the information is not available.
         (For example, Wi-Fi hasn't been enabled, or the device doesn't support Wi-Fi.)
         &lt;p&gt;
         The address will be in the {@code XX:XX:XX:XX:XX:XX} format.
@throws SecurityException if {@code admin} is not a device owner.
*/
getWifiMacAddress : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-reboot'>/**Called by device owner to reboot the device. If there is an ongoing call on the device,
</span> throws an {@link IllegalStateException}.
@param {Object {ComponentName}} admin Which device owner the request is associated with.
@throws IllegalStateException if device has an ongoing call.
@throws SecurityException if {@code admin} is not a device owner.
@see TelephonyManager#CALL_STATE_IDLE
*/
reboot : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setShortSupportMessage'>/**Called by a device admin to set the short support message. This will be displayed to the user
</span> in settings screens where funtionality has been disabled by the admin. The message should be
 limited to a short statement such as &quot;This setting is disabled by your administrator. Contact
 someone@example.com for support.&quot; If the message is longer than 200 characters it may be
 truncated.
 &lt;p&gt;
 If the short support message needs to be localized, it is the responsibility of the
 {@link android.app.admin.DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast
 and set a new version of this string accordingly.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {CharSequence}} message Short message to be displayed to the user in settings or null to clear the
            existing message.
@param message Short message to be displayed to the user in settings or null to clear the
            existing message.
@throws SecurityException if {@code admin} is not an active administrator.
*/
setShortSupportMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getShortSupportMessage'>/**Called by a device admin to get the short support message.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.lang.CharSequence}} The message set by {@link #setShortSupportMessage(ComponentName, CharSequence)} or
         null if no message has been set.
@throws SecurityException if {@code admin} is not an active administrator.
*/
getShortSupportMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setLongSupportMessage'>/**Called by a device admin to set the long support message. This will be displayed to the user
</span> in the device administators settings screen.
 &lt;p&gt;
 If the long support message needs to be localized, it is the responsibility of the
 {@link android.app.admin.DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast
 and set a new version of this string accordingly.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {CharSequence}} message Long message to be displayed to the user in settings or null to clear the
            existing message.
@param message Long message to be displayed to the user in settings or null to clear the
            existing message.
@throws SecurityException if {@code admin} is not an active administrator.
*/
setLongSupportMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLongSupportMessage'>/**Called by a device admin to get the long support message.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.lang.CharSequence}} The message set by {@link #setLongSupportMessage(ComponentName, CharSequence)} or
         null if no message has been set.
@throws SecurityException if {@code admin} is not an active administrator.
*/
getLongSupportMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getShortSupportMessageForUser'>/**Called by the system to get the short support message.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} userHandle user id the admin is running as.
@return {Object {java.lang.CharSequence}} The message set by {@link #setShortSupportMessage(ComponentName, CharSequence)}
@hide 
*/
getShortSupportMessageForUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLongSupportMessageForUser'>/**Called by the system to get the long support message.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} userHandle user id the admin is running as.
@return {Object {java.lang.CharSequence}} The message set by {@link #setLongSupportMessage(ComponentName, CharSequence)}
@hide 
*/
getLongSupportMessageForUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getParentProfileInstance'>/**Called by the profile owner of a managed profile to obtain a {@link android.app.admin.DevicePolicyManager}
</span> whose calls act on the parent profile.

 &lt;p&gt;The following methods are supported for the parent instance, all other methods will
 throw a SecurityException when called on the parent instance:
 &lt;ul&gt;
 &lt;li&gt;{@link #getPasswordQuality}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordQuality}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumLength}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumLength}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumUpperCase}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumUpperCase}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumLowerCase}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumLowerCase}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumLetters}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumLetters}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumNumeric}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumNumeric}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumSymbols}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumSymbols}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMinimumNonLetter}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordMinimumNonLetter}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordHistoryLength}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordHistoryLength}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordExpirationTimeout}&lt;/li&gt;
 &lt;li&gt;{@link #setPasswordExpirationTimeout}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordExpiration}&lt;/li&gt;
 &lt;li&gt;{@link #getPasswordMaximumLength}&lt;/li&gt;
 &lt;li&gt;{@link #isActivePasswordSufficient}&lt;/li&gt;
 &lt;li&gt;{@link #getCurrentFailedPasswordAttempts}&lt;/li&gt;
 &lt;li&gt;{@link #getMaximumFailedPasswordsForWipe}&lt;/li&gt;
 &lt;li&gt;{@link #setMaximumFailedPasswordsForWipe}&lt;/li&gt;
 &lt;li&gt;{@link #getMaximumTimeToLock}&lt;/li&gt;
 &lt;li&gt;{@link #setMaximumTimeToLock}&lt;/li&gt;
 &lt;li&gt;{@link #lockNow}&lt;/li&gt;
 &lt;li&gt;{@link #getKeyguardDisabledFeatures}&lt;/li&gt;
 &lt;li&gt;{@link #setKeyguardDisabledFeatures}&lt;/li&gt;
 &lt;li&gt;{@link #getTrustAgentConfiguration}&lt;/li&gt;
 &lt;li&gt;{@link #setTrustAgentConfiguration}&lt;/li&gt;
 &lt;li&gt;{@link #getRequiredStrongAuthTimeout}&lt;/li&gt;
 &lt;li&gt;{@link #setRequiredStrongAuthTimeout}&lt;/li&gt;
 &lt;/ul&gt;
@return {Object {android.app.admin.DevicePolicyManager}} a new instance of {@link DevicePolicyManager} that acts on the parent profile.
@throws SecurityException if {@code admin} is not a profile owner.
*/
getParentProfileInstance : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setSecurityLoggingEnabled'>/**Called by device owner to control the security logging feature.
</span>
 &lt;p&gt; Security logs contain various information intended for security auditing purposes.
 See {@link android.app.admin.SecurityLog.SecurityEvent} for details.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The device owner won't be able to retrieve security logs if there
 are unaffiliated secondary users or profiles on the device, regardless of whether the
 feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
 all users to become affiliated. Therefore it's recommended that affiliation ids are set for
 new users as soon as possible after provisioning via {@link #setAffiliationIds}.
@param {Object {ComponentName}} admin Which device owner this request is associated with.
@param {Boolean} enabled whether security logging should be enabled or not.
@throws SecurityException if {@code admin} is not a device owner.
@see #setAffiliationIds
@see #retrieveSecurityLogs
*/
setSecurityLoggingEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isSecurityLoggingEnabled'>/**Return whether security logging is enabled or not by the device owner.
</span>
 &lt;p&gt;Can only be called by the device owner, otherwise a {@link SecurityException} will be
 thrown.
@param {Object {ComponentName}} admin Which device owner this request is associated with.
@return {Boolean} {@code true} if security logging is enabled by device owner, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
*/
isSecurityLoggingEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-retrieveSecurityLogs'>/**Called by device owner to retrieve all new security logging entries since the last call to
</span> this API after device boots.

 &lt;p&gt; Access to the logs is rate limited and it will only return new logs after the device
 owner has been notified via {@link android.app.admin.DeviceAdminReceiver#onSecurityLogsAvailable}.

 &lt;p&gt;If there is any other user or profile on the device, it must be affiliated with the
 device. Otherwise a {@link SecurityException} will be thrown. See {@link #isAffiliatedUser}.
@param {Object {ComponentName}} admin Which device owner this request is associated with.
@return {Object {java.util.List}} the new batch of security logs which is a list of {@link SecurityEvent},
 or {@code null} if rate limitation is exceeded or if logging is currently disabled.
@throws SecurityException if {@code admin} is not a device owner, or there is at least one
 profile or secondary user that is not affiliated with the device.
@see #isAffiliatedUser
@see DeviceAdminReceiver#onSecurityLogsAvailable
*/
retrieveSecurityLogs : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-forceNetworkLogs'>/**Makes all accumulated network logs available to DPC in a new batch.
</span> Only callable by ADB. If throttled, returns time to wait in milliseconds, otherwise 0.
@hide 
*/
forceNetworkLogs : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-forceSecurityLogs'>/**Forces a batch of security logs to be fetched from logd and makes it available for DPC.
</span> Only callable by ADB. If throttled, returns time to wait in milliseconds, otherwise 0.
@hide 
*/
forceSecurityLogs : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getParentProfileInstance'>/**Called by the system to obtain a {@link android.app.admin.DevicePolicyManager} whose calls act on the parent
</span> profile.
@hide 
*/
getParentProfileInstance : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setMeteredDataDisabledPackages'>/**Called by a device or profile owner to restrict packages from using metered data.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {java.util.List}} packageNames the list of package names to be restricted.
@return {Object {java.util.List}} a list of package names which could not be restricted.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setMeteredDataDisabledPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getMeteredDataDisabledPackages'>/**Called by a device or profile owner to retrieve the list of packages which are restricted
</span> by the admin from using metered data.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.util.List}} the list of restricted package names.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
getMeteredDataDisabledPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isMeteredDataDisabledPackageForUser'>/**Called by the system to check if a package is restricted from using metered data
</span> by {@param admin}.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName the package whose restricted status is needed.
@param {Number} userId the user to which {@param packageName} belongs.
@return {Boolean} {@code true} if the package is restricted by admin, otherwise {@code false}
@throws SecurityException if the caller doesn't run with {@link Process#SYSTEM_UID}
@hide 
*/
isMeteredDataDisabledPackageForUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-retrievePreRebootSecurityLogs'>/**Called by device owners to retrieve device logs from before the device's last reboot.
</span> &lt;p&gt;
 &lt;strong&gt; This API is not supported on all devices. Calling this API on unsupported devices
 will result in {@code null} being returned. The device logs are retrieved from a RAM region
 which is not guaranteed to be corruption-free during power cycles, as a result be cautious
 about data corruption when parsing. &lt;/strong&gt;

 &lt;p&gt;If there is any other user or profile on the device, it must be affiliated with the
 device. Otherwise a {@link SecurityException} will be thrown. See {@link #isAffiliatedUser}.
@param {Object {ComponentName}} admin Which device owner this request is associated with.
@return {Object {java.util.List}} Device logs from before the latest reboot of the system, or {@code null} if this API
         is not supported on the device.
@throws SecurityException if {@code admin} is not a device owner, or there is at least one
 profile or secondary user that is not affiliated with the device.
@see #isAffiliatedUser
@see #retrieveSecurityLogs
*/
retrievePreRebootSecurityLogs : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setOrganizationColor'>/**Called by a profile owner of a managed profile to set the color used for customization. This
</span> color is used as background color of the confirm credentials screen for that user. The
 default color is teal (#00796B).
 &lt;p&gt;
 The confirm credentials screen can be created using
 {@link android.app.KeyguardManager#createConfirmDeviceCredentialIntent}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} color The 24bit (0xRRGGBB) representation of the color to be used.
@throws SecurityException if {@code admin} is not a profile owner.
*/
setOrganizationColor : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setOrganizationColorForUser'>/**
</span>@param {Number} color The 24bit (0xRRGGBB) representation of the color to be used.
@param {Number} userId which user to set the color to.
@param userId which user to set the color to.
@RequiresPermission(allOf = {
       Manifest.permission.MANAGE_USERS,
       Manifest.permission.INTERACT_ACROSS_USERS_FULL})
*/
setOrganizationColorForUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getOrganizationColor'>/**Called by a profile owner of a managed profile to retrieve the color used for customization.
</span> This color is used as background color of the confirm credentials screen for that user.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Number} The 24bit (0xRRGGBB) representation of the color to be used.
@throws SecurityException if {@code admin} is not a profile owner.
*/
getOrganizationColor : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getOrganizationColorForUser'>/**
</span>@param {Number} userHandle The user id of the user we're interested in.
@param userHandle The user id of the user we're interested in.
@return {Number} The 24bit (0xRRGGBB) representation of the color to be used.
*/
getOrganizationColorForUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setOrganizationName'>/**Called by the device owner (since API 26) or profile owner (since API 24) to set the name of
</span> the organization under management.

 &lt;p&gt;If the organization name needs to be localized, it is the responsibility of the {@link android.app.admin.DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast and set
 a new version of this string accordingly.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {CharSequence}} title The organization name or {@code null} to clear a previously set name.
@throws SecurityException if {@code admin} is not a device or profile owner.
*/
setOrganizationName : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getOrganizationName'>/**Called by a profile owner of a managed profile to retrieve the name of the organization under
</span> management.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@return {Object {java.lang.CharSequence}} The organization name or {@code null} if none is set.
@throws SecurityException if {@code admin} is not a profile owner.
*/
getOrganizationName : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDeviceOwnerOrganizationName'>/**Called by the system to retrieve the name of the organization managing the device.
</span>@return {Object {java.lang.CharSequence}} The organization name or {@code null} if none is set.
@throws SecurityException if the caller is not the device owner, does not hold the
         MANAGE_USERS permission and is not the system.
@hide 
*/
getDeviceOwnerOrganizationName : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getOrganizationNameForUser'>/**Retrieve the default title message used in the confirm credentials screen for a given user.
</span>@param {Number} userHandle The user id of the user we're interested in.
@return {Object {java.lang.CharSequence}} The organization name or {@code null} if none is set.
@hide 
*/
getOrganizationNameForUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getUserProvisioningState'>/**
</span>@return {Number} the {@link UserProvisioningState} for the current user - for unmanaged users will
         return {@link #STATE_USER_UNMANAGED}
@hide 
*/
getUserProvisioningState : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setUserProvisioningState'>/**Set the {@link android.app.admin.DevicePolicyManager.UserProvisioningState} for the supplied user, if they are managed.
</span>@param {Number} state to store
@param {Number} userHandle for user
@hide 
*/
setUserProvisioningState : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setAffiliationIds'>/**Indicates the entity that controls the device or profile owner. Two users/profiles are
</span> affiliated if the set of ids set by their device or profile owners intersect.

 &lt;p&gt;A user/profile that is affiliated with the device owner user is considered to be
 affiliated with the device.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Features that depend on user affiliation (such as security logging
 or {@link #bindDeviceAdminServiceAsUser}) won't be available when a secondary user or profile
 is created, until it becomes affiliated. Therefore it is recommended that the appropriate
 affiliation ids are set by its profile owner as soon as possible after the user/profile is
 created.
@param {Object {ComponentName}} admin Which profile or device owner this request is associated with.
@param {Object {java.util.Set}} ids A set of opaque non-empty affiliation ids.
@throws IllegalArgumentException if {@code ids} is null or contains an empty string.
@see #isAffiliatedUser
*/
setAffiliationIds : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getAffiliationIds'>/**Returns the set of affiliation ids previously set via {@link #setAffiliationIds}, or an
</span> empty set if none have been set.
*/
getAffiliationIds : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isAffiliatedUser'>/**Returns whether this user/profile is affiliated with the device.
</span> &lt;p&gt;
 By definition, the user that the device owner runs on is always affiliated with the device.
 Any other user/profile is considered affiliated with the device if the set specified by its
 profile owner via {@link #setAffiliationIds} intersects with the device owner's.
@see #setAffiliationIds
*/
isAffiliatedUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isUninstallInQueue'>/**
</span>@param {String} packageName the package to check for
@param packageName the package to check for
@return {Boolean} whether the uninstall intent for {@code packageName} is pending
*/
isUninstallInQueue : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-uninstallPackageWithActiveAdmins'>/**
</span>@param {String} packageName the package containing active DAs to be uninstalled
@param packageName the package containing active DAs to be uninstalled
*/
uninstallPackageWithActiveAdmins : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-forceRemoveActiveAdmin'>/**
</span>@param {Object {ComponentName}} userHandle user id to remove the admin for.
@param {Number} admin The administration compononent to remove.
@param admin The administration compononent to remove.
@throws SecurityException if the caller is not shell / root or the admin package
         isn't a test application see {@link ApplicationInfo#FLAG_TEST_APP}.
*/
forceRemoveActiveAdmin : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceProvisioned'>/**Returns whether the device has been provisioned.
</span>
 &lt;p&gt;Not for use by third-party applications.
@hide 
*/
isDeviceProvisioned : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setDeviceProvisioningConfigApplied'>/**Writes that the provisioning configuration has been applied.
</span>
 &lt;p&gt;The caller must hold the {@link android.Manifest.permission#MANAGE_USERS}
 permission.

 &lt;p&gt;Not for use by third-party applications.
@hide 
*/
setDeviceProvisioningConfigApplied : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isDeviceProvisioningConfigApplied'>/**Returns whether the provisioning configuration has been applied.
</span>
 &lt;p&gt;The caller must hold the {@link android.Manifest.permission#MANAGE_USERS} permission.

 &lt;p&gt;Not for use by third-party applications.
@return {Boolean} whether the provisioning configuration has been applied.
@hide 
*/
isDeviceProvisioningConfigApplied : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-forceUpdateUserSetupComplete'>/**
</span>@hide Force update user setup completed status. This API has no effect on user build.
@throws {@link SecurityException} if the caller has no
         {@code android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS} or the caller is
         not {@link UserHandle#SYSTEM_USER}
*/
forceUpdateUserSetupComplete : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setBackupServiceEnabled'>/**Allows the device owner or profile owner to enable or disable the backup service.
</span>
 &lt;p&gt; Each user has its own backup service which manages the backup and restore mechanisms in
 that user. Disabling the backup service will prevent data from being backed up or restored.

 &lt;p&gt; Device owner calls this API to control backup services across all users on the device.
 Profile owner can use this API to enable or disable the profile's backup service. However,
 for a managed profile its backup functionality is only enabled if both the device owner
 and the profile owner have enabled the backup service.

 &lt;p&gt; By default, backup service is disabled on a device with device owner, and within a
 managed profile.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} enabled {@code true} to enable the backup service, {@code false} to disable it.
@throws SecurityException if {@code admin} is not a device owner or a profile owner.
*/
setBackupServiceEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isBackupServiceEnabled'>/**Return whether the backup service is enabled by the device owner or profile owner for the
</span> current user, as previously set by {@link #setBackupServiceEnabled(ComponentName, boolean)}.

 &lt;p&gt; Whether the backup functionality is actually enabled or not depends on settings from both
 the current user and the device owner, please see
 {@link #setBackupServiceEnabled(ComponentName, boolean)} for details.

 &lt;p&gt; Backup service manages all backup and restore mechanisms on the device.
@return {Boolean} {@code true} if backup service is enabled, {@code false} otherwise.
@see #setBackupServiceEnabled
*/
isBackupServiceEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setNetworkLoggingEnabled'>/**Called by a device owner or delegated app with {@link #DELEGATION_NETWORK_LOGGING} to
</span> control the network logging feature.

 &lt;p&gt; Network logs contain DNS lookup and connect() library call events. The following library
     functions are recorded while network logging is active:
     &lt;ul&gt;
       &lt;li&gt;{@code getaddrinfo()}&lt;/li&gt;
       &lt;li&gt;{@code gethostbyname()}&lt;/li&gt;
       &lt;li&gt;{@code connect()}&lt;/li&gt;
     &lt;/ul&gt;

 &lt;p&gt; Network logging is a low-overhead tool for forensics but it is not guaranteed to use
     full system call logging; event reporting is enabled by default for all processes but not
     strongly enforced.
     Events from applications using alternative implementations of libc, making direct kernel
     calls, or deliberately obfuscating traffic may not be recorded.

 &lt;p&gt; Some common network events may not be reported. For example:
     &lt;ul&gt;
       &lt;li&gt;Applications may hardcode IP addresses to reduce the number of DNS lookups, or use
           an alternative system for name resolution, and so avoid calling
           {@code getaddrinfo()} or {@code gethostbyname}.&lt;/li&gt;
       &lt;li&gt;Applications may use datagram sockets for performance reasons, for example
           for a game client. Calling {@code connect()} is unnecessary for this kind of
           socket, so it will not trigger a network event.&lt;/li&gt;
     &lt;/ul&gt;

 &lt;p&gt; It is possible to directly intercept layer 3 traffic leaving the device using an
     always-on VPN service.
     See {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)}
     and {@link android.net.VpnService} for details.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The device owner won't be able to retrieve network logs if there
 are unaffiliated secondary users or profiles on the device, regardless of whether the
 feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
 all users to become affiliated. Therefore it's recommended that affiliation ids are set for
 new users as soon as possible after provisioning via {@link #setAffiliationIds}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
        {@code null} if called by a delegated app.
@param {Boolean} enabled whether network logging should be enabled or not.
@throws SecurityException if {@code admin} is not a device owner.
@see #setAffiliationIds
@see #retrieveNetworkLogs
*/
setNetworkLoggingEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isNetworkLoggingEnabled'>/**Return whether network logging is enabled by a device owner.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with. Can only
 be {@code null} if the caller is a delegated app with {@link #DELEGATION_NETWORK_LOGGING}
 or has MANAGE_USERS permission.
@return {Boolean} {@code true} if network logging is enabled by device owner, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner and caller has
 no MANAGE_USERS permission
*/
isNetworkLoggingEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-retrieveNetworkLogs'>/**Called by device owner or delegated app with {@link #DELEGATION_NETWORK_LOGGING} to retrieve
</span> the most recent batch of network logging events.
 A device owner has to provide a batchToken provided as part of
 {@link android.app.admin.DeviceAdminReceiver#onNetworkLogsAvailable} callback. If the token doesn't match the
 token of the most recent available batch of logs, {@code null} will be returned.

 &lt;p&gt; {@link android.app.admin.NetworkEvent} can be one of {@link android.app.admin.DnsEvent} or {@link android.app.admin.ConnectEvent}.

 &lt;p&gt; The list of network events is sorted chronologically, and contains at most 1200 events.

 &lt;p&gt; Access to the logs is rate limited and this method will only return a new batch of logs
 after the device device owner has been notified via
 {@link android.app.admin.DeviceAdminReceiver#onNetworkLogsAvailable}.

 &lt;p&gt;If a secondary user or profile is created, calling this method will throw a
 {@link SecurityException} until all users become affiliated again. It will also no longer be
 possible to retrieve the network logs batch with the most recent batchToken provided
 by {@link android.app.admin.DeviceAdminReceiver#onNetworkLogsAvailable}. See
 {@link android.app.admin.DevicePolicyManager#setAffiliationIds}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with, or
        {@code null} if called by a delegated app.
@param {Number} batchToken A token of the batch to retrieve
@return {Object {java.util.List}} A new batch of network logs which is a list of {@link NetworkEvent}. Returns
        {@code null} if the batch represented by batchToken is no longer available or if
        logging is disabled.
@throws SecurityException if {@code admin} is not a device owner, or there is at least one
 profile or secondary user that is not affiliated with the device.
@see #setAffiliationIds
@see DeviceAdminReceiver#onNetworkLogsAvailable
*/
retrieveNetworkLogs : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-bindDeviceAdminServiceAsUser'>/**Called by a device owner to bind to a service from a profile owner or vice versa.
</span> See {@link #getBindDeviceAdminTargetUsers} for a definition of which
 device/profile owners are allowed to bind to services of another profile/device owner.
 &lt;p&gt;
 The service must be protected by {@link android.Manifest.permission#BIND_DEVICE_ADMIN}.
 Note that the {@link Context} used to obtain this
 {@link android.app.admin.DevicePolicyManager} instance via {@link Context#getSystemService(Class)} will be used
 to bind to the {@link android.app.Service}.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {Intent}} serviceIntent Identifies the service to connect to.  The Intent must specify either an
        explicit component name or a package name to match an
        {@link IntentFilter} published by a service.
@param {Object {ServiceConnection}} conn Receives information as the service is started and stopped in main thread. This
        must be a valid {@link ServiceConnection} object; it must not be {@code null}.
@param {Number} flags Operation options for the binding operation. See
        {@link Context#bindService(Intent, ServiceConnection, int)}.
@param {Object {UserHandle}} targetUser Which user to bind to. Must be one of the users returned by
        {@link #getBindDeviceAdminTargetUsers}, otherwise a {@link SecurityException} will
        be thrown.
@return {Boolean} If you have successfully bound to the service, {@code true} is returned;
         {@code false} is returned if the connection is not made and you will not
         receive the service object.
@see Context#bindService(Intent, ServiceConnection, int)
@see #getBindDeviceAdminTargetUsers(ComponentName)
*/
bindDeviceAdminServiceAsUser : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getBindDeviceAdminTargetUsers'>/**Returns the list of target users that the calling device or profile owner can use when
</span> calling {@link #bindDeviceAdminServiceAsUser}.
 &lt;p&gt;
 A device owner can bind to a service from a profile owner and vice versa, provided that:
 &lt;ul&gt;
 &lt;li&gt;Both belong to the same package name.
 &lt;li&gt;Both users are affiliated. See {@link #setAffiliationIds}.
 &lt;/ul&gt;
*/
getBindDeviceAdminTargetUsers : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLastSecurityLogRetrievalTime'>/**Called by the system to get the time at which the device owner last retrieved security
</span> logging entries.
@return {Number} the time at which the device owner most recently retrieved security logging entries,
         in milliseconds since epoch; -1 if security logging entries were never retrieved.
@throws SecurityException if the caller is not the device owner, does not hold the
         MANAGE_USERS permission and is not the system.
@hide 
*/
getLastSecurityLogRetrievalTime : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLastBugReportRequestTime'>/**Called by the system to get the time at which the device owner last requested a bug report.
</span>@return {Number} the time at which the device owner most recently requested a bug report, in
         milliseconds since epoch; -1 if a bug report was never requested.
@throws SecurityException if the caller is not the device owner, does not hold the
         MANAGE_USERS permission and is not the system.
@hide 
*/
getLastBugReportRequestTime : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getLastNetworkLogRetrievalTime'>/**Called by the system to get the time at which the device owner last retrieved network logging
</span> events.
@return {Number} the time at which the device owner most recently retrieved network logging events, in
         milliseconds since epoch; -1 if network logging events were never retrieved.
@throws SecurityException if the caller is not the device owner, does not hold the
         MANAGE_USERS permission and is not the system.
@hide 
*/
getLastNetworkLogRetrievalTime : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isCurrentInputMethodSetByOwner'>/**Called by the system to find out whether the current user's IME was set by the device/profile
</span> owner or the user.
@return {Boolean} {@code true} if the user's IME was set by the device or profile owner, {@code false}
         otherwise.
@throws SecurityException if the caller is not the device owner/profile owner.
@hide 
*/
isCurrentInputMethodSetByOwner : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getOwnerInstalledCaCerts'>/**Called by the system to get a list of CA certificates that were installed by the device or
</span> profile owner.

 &lt;p&gt; The caller must be the target user's device owner/profile Owner or hold the
 {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL} permission.
@param {Object {UserHandle}} user The user for whom to retrieve information.
@return {Object {java.util.List}} list of aliases identifying CA certificates installed by the device or profile owner
@throws SecurityException if the caller does not have permission to retrieve information
         about the given user's CA certificates.
@hide 
*/
getOwnerInstalledCaCerts : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-clearApplicationUserData'>/**Called by the device owner or profile owner to clear application user data of a given
</span> package. The behaviour of this is equivalent to the target application calling
 {@link android.app.ActivityManager#clearApplicationUserData()}.

 &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; an application can store data outside of its application data, e.g.
 external storage or user dictionary. This data will not be wiped by calling this API.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {String} packageName The name of the package which will have its user data wiped.
@param {Object {Executor}} executor The executor through which the listener should be invoked.
@param {Object {DevicePolicyManager.OnClearApplicationUserDataListener}} listener A callback object that will inform the caller when the clearing is done.
@throws SecurityException if the caller is not the device owner/profile owner.
*/
clearApplicationUserData : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setLogoutEnabled'>/**Called by a device owner to specify whether logout is enabled for all secondary users. The
</span> system may show a logout button that stops the user and switches back to the primary user.
@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Boolean} enabled whether logout should be enabled or not.
@throws SecurityException if {@code admin} is not a device owner.
*/
setLogoutEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isLogoutEnabled'>/**Returns whether logout is enabled by a device owner.
</span>@return {Boolean} {@code true} if logout is enabled by device owner, {@code false} otherwise.
*/
isLogoutEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getDisallowedSystemApps'>/**Returns set of system apps that should be removed during provisioning.
</span>@param {Object {ComponentName}} admin Which {@link DeviceAdminReceiver} this request is associated with.
@param {Number} userId ID of the user to be provisioned.
@param {String} provisioningAction action indicating type of provisioning, should be one of
 {@link #ACTION_PROVISION_MANAGED_DEVICE}, {@link #ACTION_PROVISION_MANAGED_PROFILE} or
 {@link #ACTION_PROVISION_MANAGED_USER}.
@hide 
*/
getDisallowedSystemApps : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-transferOwnership'>/**Changes the current administrator to another one. All policies from the current
</span> administrator are migrated to the new administrator. The whole operation is atomic -
 the transfer is either complete or not done at all.

 &lt;p&gt;Depending on the current administrator (device owner, profile owner), you have the
 following expected behaviour:
 &lt;ul&gt;
     &lt;li&gt;A device owner can only be transferred to a new device owner&lt;/li&gt;
     &lt;li&gt;A profile owner can only be transferred to a new profile owner&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;Use the {@code bundle} parameter to pass data to the new administrator. The data
 will be received in the
 {@link android.app.admin.DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}
 callback of the new administrator.

 &lt;p&gt;The transfer has failed if the original administrator is still the corresponding owner
 after calling this method.

 &lt;p&gt;The incoming target administrator must have the
 &lt;code&gt;&amp;lt;support-transfer-ownership /&amp;gt;&lt;/code&gt; tag inside the
 &lt;code&gt;&amp;lt;device-admin&amp;gt;&amp;lt;/device-admin&amp;gt;&lt;/code&gt; tags in the xml file referenced by
 {@link android.app.admin.DeviceAdminReceiver#DEVICE_ADMIN_META_DATA}. Otherwise an
 {@link IllegalArgumentException} will be thrown.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@param {Object {ComponentName}} target which {@link DeviceAdminReceiver} we want the new administrator to be
@param {Object {PersistableBundle}} bundle data to be sent to the new administrator
@throws SecurityException if {@code admin} is not a device owner nor a profile owner
@throws IllegalArgumentException if {@code admin} or {@code target} is {@code null}, they
 are components in the same package or {@code target} is not an active admin
*/
transferOwnership : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setStartUserSessionMessage'>/**Called by a device owner to specify the user session start message. This may be displayed
</span> during a user switch.
 &lt;p&gt;
 The message should be limited to a short statement or it may be truncated.
 &lt;p&gt;
 If the message needs to be localized, it is the responsibility of the
 {@link android.app.admin.DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast
 and set a new version of this message accordingly.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {CharSequence}} startUserSessionMessage message for starting user session, or {@code null} to use
 system default message.
@throws SecurityException if {@code admin} is not a device owner.
*/
setStartUserSessionMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setEndUserSessionMessage'>/**Called by a device owner to specify the user session end message. This may be displayed
</span> during a user switch.
 &lt;p&gt;
 The message should be limited to a short statement or it may be truncated.
 &lt;p&gt;
 If the message needs to be localized, it is the responsibility of the
 {@link android.app.admin.DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast
 and set a new version of this message accordingly.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@param {Object {CharSequence}} endUserSessionMessage message for ending user session, or {@code null} to use system
 default message.
@throws SecurityException if {@code admin} is not a device owner.
*/
setEndUserSessionMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getStartUserSessionMessage'>/**Returns the user session start message.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a device owner.
*/
getStartUserSessionMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getEndUserSessionMessage'>/**Returns the user session end message.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@throws SecurityException if {@code admin} is not a device owner.
*/
getEndUserSessionMessage : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-addOverrideApn'>/**Called by device owner to add an override APN.
</span>
 &lt;p&gt;This method may returns {@code -1} if {@code apnSetting} conflicts with an existing
 override APN. Update the existing conflicted APN with
 {@link #updateOverrideApn(ComponentName, int, ApnSetting)} instead of adding a new entry.
 &lt;p&gt;Two override APNs are considered to conflict when all the following APIs return
 the same values on both override APNs:
 &lt;ul&gt;
   &lt;li&gt;{@link ApnSetting#getOperatorNumeric()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getApnName()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getProxyAddressAsString()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getProxyPort()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getMmsProxyAddressAsString()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getMmsProxyPort()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getMmsc()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#isEnabled()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getMvnoType()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getProtocol()}&lt;/li&gt;
   &lt;li&gt;{@link ApnSetting#getRoamingProtocol()}&lt;/li&gt;
 &lt;/ul&gt;
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@param {Object {ApnSetting}} apnSetting the override APN to insert
@return {Number} The {@code id} of inserted override APN. Or {@code -1} when failed to insert into
         the database.
@throws SecurityException if {@code admin} is not a device owner.
@see #setOverrideApnsEnabled(ComponentName, boolean)
*/
addOverrideApn : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-updateOverrideApn'>/**Called by device owner to update an override APN.
</span>
 &lt;p&gt;This method may returns {@code false} if there is no override APN with the given
 {@code apnId}.
 &lt;p&gt;This method may also returns {@code false} if {@code apnSetting} conflicts with an
 existing override APN. Update the existing conflicted APN instead.
 &lt;p&gt;See {@link #addOverrideApn} for the definition of conflict.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@param {Number} apnId the {@code id} of the override APN to update
@param {Object {ApnSetting}} apnSetting the override APN to update
@return {Boolean} {@code true} if the required override APN is successfully updated,
         {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
@see #setOverrideApnsEnabled(ComponentName, boolean)
*/
updateOverrideApn : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-removeOverrideApn'>/**Called by device owner to remove an override APN.
</span>
 &lt;p&gt;This method may returns {@code false} if there is no override APN with the given
 {@code apnId}.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@param {Number} apnId the {@code id} of the override APN to remove
@return {Boolean} {@code true} if the required override APN is successfully removed, {@code false}
         otherwise.
@throws SecurityException if {@code admin} is not a device owner.
@see #setOverrideApnsEnabled(ComponentName, boolean)
*/
removeOverrideApn : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getOverrideApns'>/**Called by device owner to get all override APNs inserted by device owner.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@return {Object {java.util.List}} A list of override APNs inserted by device owner.
@throws SecurityException if {@code admin} is not a device owner.
@see #setOverrideApnsEnabled(ComponentName, boolean)
*/
getOverrideApns : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setOverrideApnsEnabled'>/**Called by device owner to set if override APNs should be enabled.
</span> &lt;p&gt; Override APNs are separated from other APNs on the device, and can only be inserted or
 modified by the device owner. When enabled, only override APNs are in use, any other APNs
 are ignored.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@param {Boolean} enabled {@code true} if override APNs should be enabled, {@code false} otherwise
@throws SecurityException if {@code admin} is not a device owner.
*/
setOverrideApnsEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isOverrideApnEnabled'>/**Called by device owner to check if override APNs are currently enabled.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@return {Boolean} {@code true} if override APNs are currently enabled, {@code false} otherwise.
@throws SecurityException if {@code admin} is not a device owner.
@see #setOverrideApnsEnabled(ComponentName, boolean)
*/
isOverrideApnEnabled : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getTransferOwnershipBundle'>/**Returns the data passed from the current administrator to the new administrator during an
</span> ownership transfer. This is the same {@code bundle} passed in
 {@link #transferOwnership(ComponentName, ComponentName, PersistableBundle)}. The bundle is
 persisted until the profile owner or device owner is removed.

 &lt;p&gt;This is the same &lt;code&gt;bundle&lt;/code&gt; received in the
 {@link android.app.admin.DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)}.
 Use this method to retrieve it after the transfer as long as the new administrator is the
 active device or profile owner.

 &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if no ownership transfer was started for the calling user.
@see #transferOwnership
@see DeviceAdminReceiver#onTransferOwnershipComplete(Context, PersistableBundle)
@throws SecurityException if the caller is not a device or profile owner.
*/
getTransferOwnershipBundle : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setGlobalPrivateDnsModeOpportunistic'>/**Sets the global Private DNS mode to opportunistic.
</span> May only be called by the device owner.

 &lt;p&gt;In this mode, the DNS subsystem will attempt a TLS handshake to the network-supplied
 resolver prior to attempting name resolution in cleartext.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@return {Number} {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully, or
         {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set.
@throws SecurityException if the caller is not the device owner.
*/
setGlobalPrivateDnsModeOpportunistic : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setGlobalPrivateDnsModeSpecifiedHost'>/**Sets the global Private DNS host to be used.
</span> May only be called by the device owner.

 &lt;p&gt;Note that the method is blocking as it will perform a connectivity check to the resolver,
 to ensure it is valid. Because of that, the method should not be called on any thread that
 relates to user interaction, such as the UI thread.

 &lt;p&gt;In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver
 must be reachable both from within and outside the VPN. Otherwise, the device may lose
 the ability to resolve hostnames as system traffic to the resolver may not go through the
 VPN.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@param {String} privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).
@return {Number} {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,
         {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or
         {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not
         implement RFC7858.
@throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.
@throws SecurityException if the caller is not the device owner.
*/
setGlobalPrivateDnsModeSpecifiedHost : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-installSystemUpdate'>/**Called by device owner to install a system update from the given file. The device will be
</span> rebooted in order to finish installing the update. Note that if the device is rebooted, this
 doesn't necessarily mean that the update has been applied successfully. The caller should
 additionally check the system version with {@link android.os.Build#FINGERPRINT} or {@link android.os.Build.VERSION}. If an error occurs during processing the OTA before the reboot,
 the caller will be notified by {@link android.app.admin.DevicePolicyManager.InstallSystemUpdateCallback}. If device does not have
 sufficient battery level, the installation will fail with error {@link android.app.admin.DevicePolicyManager.InstallSystemUpdateCallback#UPDATE_ERROR_BATTERY_LOW}.
@param {Object {ComponentName}} admin The {@link DeviceAdminReceiver} that this request is associated with.
@param {Object {Uri}} updateFilePath An Uri of the file that contains the update. The file should be
 readable by the calling app.
@param {Object {Executor}} executor The executor through which the callback should be invoked.
@param {Object {DevicePolicyManager.InstallSystemUpdateCallback}} callback A callback object that will inform the caller when installing an update
 fails.
*/
installSystemUpdate : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getGlobalPrivateDnsMode'>/**Returns the system-wide Private DNS mode.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@return {Number} one of {@code PRIVATE_DNS_MODE_OFF}, {@code PRIVATE_DNS_MODE_OPPORTUNISTIC},
 {@code PRIVATE_DNS_MODE_PROVIDER_HOSTNAME} or {@code PRIVATE_DNS_MODE_UNKNOWN}.
@throws SecurityException if the caller is not the device owner.
*/
getGlobalPrivateDnsMode : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getGlobalPrivateDnsHost'>/**Returns the system-wide Private DNS host.
</span>@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with.
@return {String} The hostname used for Private DNS queries, null if none is set.
@throws SecurityException if the caller is not the device owner.
*/
getGlobalPrivateDnsHost : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setProfileOwnerCanAccessDeviceIds'>/**Grants the profile owner of the given user access to device identifiers (such as
</span> serial number, IMEI and MEID).

 &lt;p&gt;This lets the profile owner request inclusion of device identifiers when calling
 {@link generateKeyPair}.

 &lt;p&gt;This grant is necessary to guarantee that profile owners can access device identifiers.

 &lt;p&gt;Privileged system API - meant to be called by the system, particularly the managed
 provisioning app, when a work profile is set up.
@hide 
*/
setProfileOwnerCanAccessDeviceIds : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-setCrossProfileCalendarPackages'>/**Allows a set of packages to access cross-profile calendar APIs.
</span>
 &lt;p&gt;Called by a profile owner of a managed profile.

 &lt;p&gt;Calling with a {@code null} value for the set disables the restriction so that all
 packages are allowed to access cross-profile calendar APIs. Calling with an empty set
 disallows all packages from accessing cross-profile calendar APIs. If this method isn't
 called, no package is allowed to access cross-profile calendar APIs by default.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@param {Object {java.util.Set}} packageNames set of packages to be whitelisted
@throws SecurityException if {@code admin} is not a profile owner
@see #getCrossProfileCalendarPackages(ComponentName)
*/
setCrossProfileCalendarPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileCalendarPackages'>/**Gets a set of package names that are allowed to access cross-profile calendar APIs.
</span>
 &lt;p&gt;Called by a profile owner of a managed profile.
@param {Object {ComponentName}} admin which {@link DeviceAdminReceiver} this request is associated with
@return {Object {java.util.Set}} the set of names of packages that were previously allowed via
 {@link #setCrossProfileCalendarPackages(ComponentName, Set)}, or an
 empty set if none have been allowed
@throws SecurityException if {@code admin} is not a profile owner
@see #setCrossProfileCalendarPackages(ComponentName, Set)
*/
getCrossProfileCalendarPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isPackageAllowedToAccessCalendar'>/**Returns if a package is allowed to access cross-profile calendar APIs.
</span>
 &lt;p&gt;A package is allowed to access cross-profile calendar APIs if it's allowed by
 admins via {@link #setCrossProfileCalendarPackages(ComponentName, Set)} and
 {@link android.provider.Settings.Secure#CROSS_PROFILE_CALENDAR_ENABLED}
 is turned on in the managed profile.

 &lt;p&gt;To query for a specific user, use
 {@link Context#createPackageContextAsUser(String, int, UserHandle)} to create a context for
 that user, and get a {@link android.app.admin.DevicePolicyManager} from this context.
@param {String} packageName the name of the package
@return {Boolean} {@code true} if the package is allowed to access cross-profile calendar APIs,
 {@code false} otherwise
@see #setCrossProfileCalendarPackages(ComponentName, Set)
@see #getCrossProfileCalendarPackages(ComponentName)
@hide 
*/
isPackageAllowedToAccessCalendar : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-getCrossProfileCalendarPackages'>/**Gets a set of package names that are allowed to access cross-profile calendar APIs.
</span>
 &lt;p&gt;To query for a specific user, use
 {@link Context#createPackageContextAsUser(String, int, UserHandle)} to create a context for
 that user, and get a {@link android.app.admin.DevicePolicyManager} from this context.
@return {Object {java.util.Set}} the set of names of packages that were previously allowed via
 {@link #setCrossProfileCalendarPackages(ComponentName, Set)}, or an
 empty set if none have been allowed
@see #setCrossProfileCalendarPackages(ComponentName, Set)
@see #getCrossProfileCalendarPackages(ComponentName)
@hide 
*/
getCrossProfileCalendarPackages : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isManagedKiosk'>/**Returns whether the device is being used as a managed kiosk. These requirements are as
</span> follows:
 &lt;ul&gt;
     &lt;li&gt;The device is in Lock Task (therefore there is also a Device Owner app on the
     device)&lt;/li&gt;
     &lt;li&gt;The Lock Task feature {@link android.app.admin.DevicePolicyManager#LOCK_TASK_FEATURE_SYSTEM_INFO} is
     not enabled, so the system info in the status bar is not visible&lt;/li&gt;
     &lt;li&gt;The device does not have a secure lock screen (e.g. it has no lock screen or has
     swipe-to-unlock)&lt;/li&gt;
     &lt;li&gt;The device is not in the middle of an ephemeral user session&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;Publicly-accessible dedicated devices don't have the same privacy model as
 personally-used devices. In particular, user consent popups don't make sense as a barrier to
 accessing persistent data on these devices since the user giving consent and the user whose
 data is on the device are unlikely to be the same. These consent popups prevent the true
 remote management of these devices.

 &lt;p&gt;This condition is not sufficient to cover APIs that would access data that only lives for
 the duration of the user's session, since the user has an expectation of privacy in these
 conditions that more closely resembles use of a personal device. In those cases, see {@link #isUnattendedManagedKiosk}().
@hide 
*/
isManagedKiosk : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-isUnattendedManagedKiosk'>/**Returns whether the device is being used as an unattended managed kiosk. These requirements
</span> are as follows:
 &lt;ul&gt;
     &lt;li&gt;The device is being used as a managed kiosk, as defined at {@link #isManagedKiosk}()&lt;/li&gt;
     &lt;li&gt;The device has not received user input for at least 30 minutes&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;See {@link #isManagedKiosk}() for context. This is a stronger requirement that also
 ensures that the device hasn't been interacted with recently, making it an appropriate check
 for privacy-sensitive APIs that wouldn't be appropriate during an active user session.
@hide 
*/
isUnattendedManagedKiosk : function(  ) {},

<span id='android-app-admin-DevicePolicyManager-method-startViewCalendarEventInManagedProfile'>/**Starts an activity to view calendar events in the managed profile.
</span>@param {Number} eventId the id of the event to be viewed
@param {Number} start the start time of the event
@param {Number} end the end time of the event
@param {Boolean} allDay if the event is an all-day event
@param {Number} flags flags to be set for the intent
@return {Boolean} {@code true} if the activity is started successfully, {@code false} otherwise
@see CalendarContract#startViewCalendarEventInManagedProfile(Context, String, long, long,
 long, boolean, int)
@hide 
*/
startViewCalendarEventInManagedProfile : function(  ) {},


};</pre>
</body>
</html>
