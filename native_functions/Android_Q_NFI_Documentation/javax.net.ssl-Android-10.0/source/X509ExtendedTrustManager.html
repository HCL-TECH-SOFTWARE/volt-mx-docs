<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='javax-net-ssl-X509ExtendedTrustManager'>/**@class javax.net.ssl.X509ExtendedTrustManager
</span> implements javax.net.ssl.X509TrustManager

@extends java.lang.Object

 Extensions to the &lt;code&gt;X509TrustManager&lt;/code&gt; interface to support
 SSL/TLS connection sensitive trust management.
 &lt;p&gt;
 To prevent man-in-the-middle attacks, hostname checks can be done
 to verify that the hostname in an end-entity certificate matches the
 targeted hostname.  TLS does not require such checks, but some protocols
 over TLS (such as HTTPS) do.  In earlier versions of the JDK, the
 certificate chain checks were done at the SSL/TLS layer, and the hostname
 verification checks were done at the layer over TLS.  This class allows
 for the checking to be done during a single call to this class.
 &lt;p&gt;
 RFC 2830 defines the server identification specification for the &quot;LDAPS&quot;
 algorithm. RFC 2818 defines both the server identification and the
 client identification specification for the &quot;HTTPS&quot; algorithm.

 @see X509TrustManager
 @see HostnameVerifier

 @since 1.7
*/
var X509ExtendedTrustManager = {

<span id='javax-net-ssl-X509ExtendedTrustManager-method-checkClientTrusted'>/**Given the partial or complete certificate chain provided by the
</span> peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 &lt;p&gt;
 The authentication type is determined by the actual certificate
 used. For instance, if RSAPublicKey is used, the authType
 should be &quot;RSA&quot;. Checking is case-sensitive.
 &lt;p&gt;
 If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of
 {@link javax.net.ssl.SSLSocket}, and the endpoint identification
 algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent
 man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt;
 connected to should be checked against the peer's identity presented
 in the end-entity X509 certificate, as specified in the endpoint
 identification algorithm.
 &lt;p&gt;
 If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of
 {@link javax.net.ssl.SSLSocket}, and the algorithm constraints of the
 &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the
 certification path, fields such as subject public key, the signature
 algorithm, key usage, extended key usage, etc. need to conform to the
 algorithm constraints in place on this socket.
@param {Object {java.security.cert.X509Certificate[]}} chain the peer certificate chain
@param {String} authType the key exchange algorithm used
@param {Object {Socket}} socket the socket used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
@throws IllegalArgumentException if null or zero-length array is passed
        in for the &lt;code&gt;chain&lt;/code&gt; parameter or if null or zero-length
        string is passed in for the &lt;code&gt;authType&lt;/code&gt; parameter
@throws CertificateException if the certificate chain is not trusted
        by this TrustManager
@see SSLParameters#getEndpointIdentificationAlgorithm
@see SSLParameters#setEndpointIdentificationAlgorithm(String)
@see SSLParameters#getAlgorithmConstraints
@see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
*/
checkClientTrusted : function(  ) {},

<span id='javax-net-ssl-X509ExtendedTrustManager-method-checkServerTrusted'>/**Given the partial or complete certificate chain provided by the
</span> peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 &lt;p&gt;
 The authentication type is the key exchange algorithm portion
 of the cipher suites represented as a String, such as &quot;RSA&quot;,
 &quot;DHE_DSS&quot;. Note: for some exportable cipher suites, the key
 exchange algorithm is determined at run time during the
 handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,
 the authType should be RSA_EXPORT when an ephemeral RSA key is
 used for the key exchange, and RSA when the key from the server
 certificate is used. Checking is case-sensitive.
 &lt;p&gt;
 If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of
 {@link javax.net.ssl.SSLSocket}, and the endpoint identification
 algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent
 man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt;
 connected to should be checked against the peer's identity presented
 in the end-entity X509 certificate, as specified in the endpoint
 identification algorithm.
 &lt;p&gt;
 If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of
 {@link javax.net.ssl.SSLSocket}, and the algorithm constraints of the
  &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the
 certification path, fields such as subject public key, the signature
 algorithm, key usage, extended key usage, etc. need to conform to the
 algorithm constraints in place on this socket.
@param {Object {java.security.cert.X509Certificate[]}} chain the peer certificate chain
@param {String} authType the key exchange algorithm used
@param {Object {Socket}} socket the socket used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
@throws IllegalArgumentException if null or zero-length array is passed
        in for the &lt;code&gt;chain&lt;/code&gt; parameter or if null or zero-length
        string is passed in for the &lt;code&gt;authType&lt;/code&gt; parameter
@throws CertificateException if the certificate chain is not trusted
        by this TrustManager
@see SSLParameters#getEndpointIdentificationAlgorithm
@see SSLParameters#setEndpointIdentificationAlgorithm(String)
@see SSLParameters#getAlgorithmConstraints
@see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
*/
checkServerTrusted : function(  ) {},

<span id='javax-net-ssl-X509ExtendedTrustManager-method-checkClientTrusted'>/**Given the partial or complete certificate chain provided by the
</span> peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 &lt;p&gt;
 The authentication type is determined by the actual certificate
 used. For instance, if RSAPublicKey is used, the authType
 should be &quot;RSA&quot;. Checking is case-sensitive.
 &lt;p&gt;
 If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint
 identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is
 non-empty, to prevent man-in-the-middle attacks, the address that
 the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against
 the peer's identity presented in the end-entity X509 certificate,
 as specified in the endpoint identification algorithm.
 &lt;p&gt;
 If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm
 constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every
 certificate in the certification path, fields such as subject public
 key, the signature algorithm, key usage, extended key usage, etc.
 need to conform to the algorithm constraints in place on this engine.
@param {Object {java.security.cert.X509Certificate[]}} chain the peer certificate chain
@param {String} authType the key exchange algorithm used
@param {Object {SSLEngine}} engine the engine used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
@throws IllegalArgumentException if null or zero-length array is passed
        in for the &lt;code&gt;chain&lt;/code&gt; parameter or if null or zero-length
        string is passed in for the &lt;code&gt;authType&lt;/code&gt; parameter
@throws CertificateException if the certificate chain is not trusted
        by this TrustManager
@see SSLParameters#getEndpointIdentificationAlgorithm
@see SSLParameters#setEndpointIdentificationAlgorithm(String)
@see SSLParameters#getAlgorithmConstraints
@see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
*/
checkClientTrusted : function(  ) {},

<span id='javax-net-ssl-X509ExtendedTrustManager-method-checkServerTrusted'>/**Given the partial or complete certificate chain provided by the
</span> peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 &lt;p&gt;
 The authentication type is the key exchange algorithm portion
 of the cipher suites represented as a String, such as &quot;RSA&quot;,
 &quot;DHE_DSS&quot;. Note: for some exportable cipher suites, the key
 exchange algorithm is determined at run time during the
 handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,
 the authType should be RSA_EXPORT when an ephemeral RSA key is
 used for the key exchange, and RSA when the key from the server
 certificate is used. Checking is case-sensitive.
 &lt;p&gt;
 If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint
 identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is
 non-empty, to prevent man-in-the-middle attacks, the address that
 the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against
 the peer's identity presented in the end-entity X509 certificate,
 as specified in the endpoint identification algorithm.
 &lt;p&gt;
 If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm
 constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every
 certificate in the certification path, fields such as subject public
 key, the signature algorithm, key usage, extended key usage, etc.
 need to conform to the algorithm constraints in place on this engine.
@param {Object {java.security.cert.X509Certificate[]}} chain the peer certificate chain
@param {String} authType the key exchange algorithm used
@param {Object {SSLEngine}} engine the engine used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
@throws IllegalArgumentException if null or zero-length array is passed
        in for the &lt;code&gt;chain&lt;/code&gt; parameter or if null or zero-length
        string is passed in for the &lt;code&gt;authType&lt;/code&gt; parameter
@throws CertificateException if the certificate chain is not trusted
        by this TrustManager
@see SSLParameters#getEndpointIdentificationAlgorithm
@see SSLParameters#setEndpointIdentificationAlgorithm(String)
@see SSLParameters#getAlgorithmConstraints
@see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
*/
checkServerTrusted : function(  ) {},


};</pre>
</body>
</html>
