Ext.data.JsonP.javax_net_ssl_SSLEngine({"tagname":"class","name":"javax.net.ssl.SSLEngine","autodetected":{},"files":[{"filename":"SSLEngine.js","href":"SSLEngine.html#javax-net-ssl-SSLEngine"}],"extends":"java.lang.Object","since":"1.5","author":[{"tagname":"author","name":"Brad R. Wetmore","email":null}],"members":[{"name":"beginHandshake","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-beginHandshake","meta":{}},{"name":"closeInbound","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-closeInbound","meta":{}},{"name":"closeOutbound","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-closeOutbound","meta":{}},{"name":"getApplicationProtocol","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getApplicationProtocol","meta":{}},{"name":"getDelegatedTask","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getDelegatedTask","meta":{}},{"name":"getEnableSessionCreation","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getEnableSessionCreation","meta":{}},{"name":"getEnabledCipherSuites","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getEnabledCipherSuites","meta":{}},{"name":"getEnabledProtocols","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getEnabledProtocols","meta":{}},{"name":"getHandshakeApplicationProtocol","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getHandshakeApplicationProtocol","meta":{}},{"name":"getHandshakeApplicationProtocolSelector","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getHandshakeApplicationProtocolSelector","meta":{}},{"name":"getHandshakeSession","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getHandshakeSession","meta":{}},{"name":"getHandshakeStatus","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getHandshakeStatus","meta":{}},{"name":"getNeedClientAuth","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getNeedClientAuth","meta":{}},{"name":"getPeerHost","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getPeerHost","meta":{}},{"name":"getPeerPort","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getPeerPort","meta":{}},{"name":"getSSLParameters","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getSSLParameters","meta":{}},{"name":"getSession","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getSession","meta":{}},{"name":"getSupportedCipherSuites","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getSupportedCipherSuites","meta":{}},{"name":"getSupportedProtocols","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getSupportedProtocols","meta":{}},{"name":"getUseClientMode","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getUseClientMode","meta":{}},{"name":"getWantClientAuth","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-getWantClientAuth","meta":{}},{"name":"isInboundDone","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-isInboundDone","meta":{}},{"name":"isOutboundDone","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-isOutboundDone","meta":{}},{"name":"setEnableSessionCreation","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setEnableSessionCreation","meta":{}},{"name":"setEnabledCipherSuites","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setEnabledCipherSuites","meta":{}},{"name":"setEnabledProtocols","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setEnabledProtocols","meta":{}},{"name":"setHandshakeApplicationProtocolSelector","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setHandshakeApplicationProtocolSelector","meta":{}},{"name":"setNeedClientAuth","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setNeedClientAuth","meta":{}},{"name":"setSSLParameters","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setSSLParameters","meta":{}},{"name":"setUseClientMode","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setUseClientMode","meta":{}},{"name":"setWantClientAuth","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-setWantClientAuth","meta":{}},{"name":"unwrap","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-unwrap","meta":{}},{"name":"wrap","tagname":"method","owner":"javax.net.ssl.SSLEngine","id":"method-wrap","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-javax.net.ssl.SSLEngine","short_doc":"A class which enables secure communications using protocols such as\n the Secure Sockets Layer (SSL) or\n  IETF RFC 224...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>javax.net.ssl.SSLEngine</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine' target='_blank'>SSLEngine.js</a></div></pre><div class='doc-contents'><p>A class which enables secure communications using protocols such as\n the Secure Sockets Layer (SSL) or\n <A HREF=\"http://www.ietf.org/rfc/rfc2246.txt\"> IETF RFC 2246 \"Transport\n Layer Security\" (TLS) </A> protocols, but is transport independent.\n <P>\n The secure communications modes include: <UL></UL></P></p>\n\n<pre><code>  &lt;LI&gt; &lt;em&gt;Integrity Protection&lt;/em&gt;.  SSL/TLS protects against\n  modification of messages by an active wiretapper.\n\n  &lt;LI&gt; &lt;em&gt;Authentication&lt;/em&gt;.  In most modes, SSL/TLS provides\n  peer authentication.  Servers are usually authenticated, and\n  clients may be authenticated as requested by servers.\n\n  &lt;LI&gt; &lt;em&gt;Confidentiality (Privacy Protection)&lt;/em&gt;.  In most\n  modes, SSL/TLS encrypts data being sent between client and\n  server.  This protects the confidentiality of data, so that\n  passive wiretappers won't see sensitive data such as financial\n  information or personal information of many kinds.\n\n  &lt;/UL&gt;\n</code></pre>\n\n<p> These kinds of protection are specified by a \"cipher suite\", which\n is a combination of cryptographic algorithms used by a given SSL\n connection.  During the negotiation process, the two endpoints must\n agree on a cipher suite that is available in both environments.  If\n there is no such suite in common, no SSL connection can be\n established, and no data can be exchanged.\n <P>\n The cipher suite used is established by a negotiation process called\n \"handshaking\".  The goal of this process is to create or rejoin a\n \"session\", which may protect many connections over time.  After\n handshaking has completed, you can access session attributes by\n using the <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getSession\" rel=\"javax.net.ssl.SSLEngine-method-getSession\" class=\"docClass\">getSession</a>() method.\n <P>\n The <code>SSLSocket</code> class provides much of the same security\n functionality, but all of the inbound and outbound data is\n automatically transported using the underlying Socket, which by design uses a blocking model.\n While this is appropriate for many applications, this model does not\n provide the scalability required by large servers.\n <P>\n The primary distinction of an <code>SSLEngine</code> is that it\n operates on inbound and outbound byte streams, independent of the\n transport mechanism.  It is the responsibility of the\n <code>SSLEngine</code> user to arrange for reliable I/O transport to\n the peer.  By separating the SSL/TLS abstraction from the I/O\n transport mechanism, the <code>SSLEngine</code> can be used for a\n wide variety of I/O types, such as non-blocking I/O (polling), selectable non-blocking I/O, Socket and the\n traditional Input/OutputStreams, local ByteBuffers or byte arrays, <A\n HREF=\"http://www.jcp.org/en/jsr/detail?id=203\"> future asynchronous\n I/O models </A>, and so on.\n <P>\n At a high level, the <code>SSLEngine</code> appears thus:</P></P></P></P></p>\n\n<pre>                   app data\n\n                |           ^\n                |     |     |\n                v     |     |\n           +----+-----|-----+----+\n           |          |          |\n           |       SSL|Engine    |\n   wrap()  |          |          |  unwrap()\n           | OUTBOUND | INBOUND  |\n           |          |          |\n           +----+-----|-----+----+\n                |     |     ^\n                |     |     |\n                v           |\n\n                   net data\n </pre>\n\n\n<p> Application data (also known as plaintext or cleartext) is data which\n is produced or consumed by an application.  Its counterpart is\n network data, which consists of either handshaking and/or ciphertext\n (encrypted) data, and destined to be transported via an I/O\n mechanism.  Inbound data is data which has been received from the\n peer, and outbound data is destined for the peer.\n <P>\n (In the context of an <code>SSLEngine</code>, the term \"handshake\n data\" is taken to mean any data exchanged to establish and control a\n secure connection.  Handshake data includes the SSL/TLS messages\n \"alert\", \"change_cipher_spec,\" and \"handshake.\")\n <P>\n There are five distinct phases to an <code>SSLEngine</code>.</P></P></p>\n\n<p> <OL>\n     <li> Creation - The <code>SSLEngine</code> has been created and\n     initialized, but has not yet been used.  During this phase, an\n     application may set any <code>SSLEngine</code>-specific settings\n     (enabled cipher suites, whether the <code>SSLEngine</code> should\n     handshake in client or server mode, and so on).  Once\n     handshaking has begun, though, any new settings (except\n     client/server mode, see below) will be used for\n     the next handshake.</li></OL></p>\n\n<pre><code> &lt;li&gt; Initial Handshake - The initial handshake is a procedure by\n which the two peers exchange communication parameters until an\n SSLSession is established.  Application data can not be sent during\n this phase.\n\n &lt;li&gt; Application Data - Once the communication parameters have\n been established and the handshake is complete, application data\n may flow through the &lt;code&gt;SSLEngine&lt;/code&gt;.  Outbound\n application messages are encrypted and integrity protected,\n and inbound messages reverse the process.\n\n &lt;li&gt;  Rehandshaking - Either side may request a renegotiation of\n the session at any time during the Application Data phase.  New\n handshaking data can be intermixed among the application data.\n Before starting the rehandshake phase, the application may\n reset the SSL/TLS communication parameters such as the list of\n enabled ciphersuites and whether to use client authentication,\n but can not change between client/server modes.  As before, once\n handshaking has begun, any new &lt;code&gt;SSLEngine&lt;/code&gt;\n configuration settings will not be used until the next\n handshake.\n\n &lt;li&gt;  Closure - When the connection is no longer needed, the\n application should close the &lt;code&gt;SSLEngine&lt;/code&gt; and should\n send/receive any remaining messages to the peer before\n closing the underlying transport mechanism.  Once an engine is\n closed, it is not reusable:  a new &lt;code&gt;SSLEngine&lt;/code&gt; must\n be created.\n</code></pre>\n\n<p> \n An <code>SSLEngine</code> is created by calling javax.net.ssl.SSLContext.createSSLEngine() from an initialized\n <code>SSLContext</code>.  Any configuration\n parameters should be set before making the first call to\n <code>wrap()</code>, <code>unwrap()</code>, or\n <code>beginHandshake()</code>.  These methods all trigger the\n initial handshake.\n <P>\n Data moves through the engine by calling ByteBuffer) wrap() or ByteBuffer)\n unwrap() on outbound or inbound data, respectively.  Depending on\n the state of the <code>SSLEngine</code>, a <code>wrap()</code> call\n may consume application data from the source buffer and may produce\n network data in the destination buffer.  The outbound data\n may contain application and/or handshake data.  A call to\n <code>unwrap()</code> will examine the source buffer and may\n advance the handshake if the data is handshaking information, or\n may place application data in the destination buffer if the data\n is application.  The state of the underlying SSL/TLS algorithm\n will determine when data is consumed and produced.\n <P>\n Calls to <code>wrap()</code> and <code>unwrap()</code> return an\n <code>SSLEngineResult</code> which indicates the status of the\n operation, and (optionally) how to interact with the engine to make\n progress.\n <P>\n The <code>SSLEngine</code> produces/consumes complete SSL/TLS\n packets only, and does not store application data internally between\n calls to <code>wrap()/unwrap()</code>.  Thus input and output\n <code>ByteBuffer</code>s must be sized appropriately to hold the\n maximum record that can be produced.  Calls to javax.net.ssl.SSLSession.getPacketBufferSize() and javax.net.ssl.SSLSession.getApplicationBufferSize() should be used to determine\n the appropriate buffer sizes.  The size of the outbound application\n data buffer generally does not matter.  If buffer conditions do not\n allow for the proper consumption/production of data, the application\n must determine (via <a href=\"#!/api/javax.net.ssl.SSLEngineResult\" rel=\"javax.net.ssl.SSLEngineResult\" class=\"docClass\">javax.net.ssl.SSLEngineResult</a>) and correct the\n problem, and then try the call again.\n <P>\n For example, <code>unwrap()</code> will return a <a href=\"#!/api/javax.net.ssl.SSLEngineResult.Status-property-BUFFER_OVERFLOW\" rel=\"javax.net.ssl.SSLEngineResult.Status-property-BUFFER_OVERFLOW\" class=\"docClass\">javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW</a> result if the engine\n determines that there is not enough destination buffer space available.\n Applications should call javax.net.ssl.SSLSession.getApplicationBufferSize()\n and compare that value with the space available in the destination buffer,\n enlarging the buffer if necessary.  Similarly, if <code>unwrap()</code>\n were to return a <a href=\"#!/api/javax.net.ssl.SSLEngineResult.Status-property-BUFFER_UNDERFLOW\" rel=\"javax.net.ssl.SSLEngineResult.Status-property-BUFFER_UNDERFLOW\" class=\"docClass\">javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW</a>, the\n application should call javax.net.ssl.SSLSession.getPacketBufferSize() to ensure\n that the source buffer has enough room to hold a record (enlarging if\n necessary), and then obtain more inbound data.</P></P></P></P></p>\n\n<p> <pre>{@code\n   SSLEngineResult r = engine.unwrap(src, dst);\n   switch (r.getStatus()) {\n   BUFFER_OVERFLOW:\n       // Could attempt to drain the dst buffer of any already obtained\n       // data, but we'll just increase it to the size needed.\n       int appSize = engine.getSession().getApplicationBufferSize();\n       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());\n       dst.flip();\n       b.put(dst);\n       dst = b;\n       // retry the operation.\n       break;\n   BUFFER_UNDERFLOW:\n       int netSize = engine.getSession().getPacketBufferSize();\n       // Resize buffer if needed.\n       if (netSize > dst.capacity()) {\n           ByteBuffer b = ByteBuffer.allocate(netSize);\n           src.flip();\n           b.put(src);\n           src = b;\n       }\n       // Obtain more inbound network data for src,\n       // then retry the operation.\n       break;\n   // other cases: CLOSED, OK.\n   }\n }</pre></p>\n\n<p> <P>\n Unlike <code>SSLSocket</code>, all methods of SSLEngine are\n non-blocking.  <code>SSLEngine</code> implementations may\n require the results of tasks that may take an extended period of\n time to complete, or may even block.  For example, a TrustManager\n may need to connect to a remote certificate validation service,\n or a KeyManager might need to prompt a user to determine which\n certificate to use as part of client authentication.  Additionally,\n creating cryptographic signatures and verifying them can be slow,\n seemingly blocking.\n <P>\n For any operation which may potentially block, the\n <code>SSLEngine</code> will create a java.lang.Runnable\n delegated task.  When <code>SSLEngineResult</code> indicates that a\n delegated task result is needed, the application must call <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getDelegatedTask\" rel=\"javax.net.ssl.SSLEngine-method-getDelegatedTask\" class=\"docClass\">getDelegatedTask</a>() to obtain an outstanding delegated task and\n call its run() method (possibly using\n a different thread depending on the compute strategy).  The\n application should continue obtaining delegated tasks until no more\n exist, and try the original operation again.\n <P>\n At the end of a communication session, applications should properly\n close the SSL/TLS link.  The SSL/TLS protocols have closure handshake\n messages, and these messages should be communicated to the peer\n before releasing the <code>SSLEngine</code> and closing the\n underlying transport mechanism.  A close can be initiated by one of:\n an SSLException, an inbound closure handshake message, or one of the\n close methods.  In all cases, closure handshake messages are\n generated by the engine, and <code>wrap()</code> should be repeatedly\n called until the resulting <code>SSLEngineResult</code>'s status\n returns \"CLOSED\", or <a href=\"#!/api/javax.net.ssl.SSLEngine-method-isOutboundDone\" rel=\"javax.net.ssl.SSLEngine-method-isOutboundDone\" class=\"docClass\">isOutboundDone</a>() returns true.  All\n data obtained from the <code>wrap()</code> method should be sent to the\n peer.\n <P>\n <a href=\"#!/api/javax.net.ssl.SSLEngine-method-closeOutbound\" rel=\"javax.net.ssl.SSLEngine-method-closeOutbound\" class=\"docClass\">closeOutbound</a>() is used to signal the engine that the\n application will not be sending any more data.\n <P>\n A peer will signal its intent to close by sending its own closure\n handshake message.  After this message has been received and\n processed by the local <code>SSLEngine</code>'s <code>unwrap()</code>\n call, the application can detect the close by calling\n <code>unwrap()</code> and looking for a <code>SSLEngineResult</code>\n with status \"CLOSED\", or if <a href=\"#!/api/javax.net.ssl.SSLEngine-method-isInboundDone\" rel=\"javax.net.ssl.SSLEngine-method-isInboundDone\" class=\"docClass\">isInboundDone</a>() returns true.\n If for some reason the peer closes the communication link without\n sending the proper SSL/TLS closure message, the application can\n detect the end-of-stream and can signal the engine via <a href=\"#!/api/javax.net.ssl.SSLEngine-method-closeInbound\" rel=\"javax.net.ssl.SSLEngine-method-closeInbound\" class=\"docClass\">closeInbound</a>() that there will no more inbound messages to\n process.  Some applications might choose to require orderly shutdown\n messages from a peer, in which case they can check that the closure\n was generated by a handshake message and not by an end-of-stream\n condition.\n <P>\n There are two groups of cipher suites which you will need to know\n about when managing cipher suites:</P></P></P></P></P></P></p>\n\n<p> <UL>\n      <LI> <em>Supported</em> cipher suites:  all the suites which are\n      supported by the SSL implementation.  This list is reported\n      using <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getSupportedCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getSupportedCipherSuites\" class=\"docClass\">getSupportedCipherSuites</a>().</LI></UL></p>\n\n<pre><code>  &lt;LI&gt; &lt;em&gt;Enabled&lt;/em&gt; cipher suites, which may be fewer than\n  the full set of supported suites.  This group is set using the\n  []) method, and\n  queried using the <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" class=\"docClass\">getEnabledCipherSuites</a>() method.\n  Initially, a default set of cipher suites will be enabled on a\n  new engine that represents the minimum suggested\n  configuration.\n</code></pre>\n\n<p> </p>\n\n<p> Implementation defaults require that only cipher suites which\n authenticate servers and provide confidentiality be enabled by\n default.  Only if both sides explicitly agree to unauthenticated\n and/or non-private (unencrypted) communications will such a\n cipher suite be selected.\n <P>\n Each SSL/TLS connection must have one client and one server, thus\n each endpoint must decide which role to assume.  This choice determines\n who begins the handshaking process as well as which type of messages\n should be sent by each party.  The method <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-setUseClientMode\" class=\"docClass\">setUseClientMode</a>(boolean) configures the mode.  Once the initial\n handshaking has started, an <code>SSLEngine</code> can not switch\n between client and server modes, even when performing renegotiations.\n <P>\n Applications might choose to process delegated tasks in different\n threads.  When an <code>SSLEngine</code>\n is created, the current java.security.AccessControlContext\n is saved.  All future delegated tasks will be processed using this\n context:  that is, all access control decisions will be made using the\n context captured at engine creation.</P></P></p>\n\n<p> <HR></HR></p>\n\n<p> <B>Concurrency Notes</B>:\n There are two concurrency issues to be aware of:</p>\n\n<p> <OL>\n      <li>The <code>wrap()</code> and <code>unwrap()</code> methods\n      may execute concurrently of each other.</li></OL></p>\n\n<pre><code>  &lt;li&gt; The SSL/TLS protocols employ ordered packets.\n  Applications must take care to ensure that generated packets\n  are delivered in sequence.  If packets arrive\n  out-of-order, unexpected or fatal results may occur.\n</code></pre>\n\n<p> <P>\n      For example:</P></p>\n\n<pre>              synchronized (outboundLock) {\n                  sslEngine.wrap(src, dst);\n                  outboundQueue.put(dst);\n              }\n      </pre>\n\n\n<pre><code>  As a corollary, two threads must not attempt to call the same method\n  (either &lt;code&gt;wrap()&lt;/code&gt; or &lt;code&gt;unwrap()&lt;/code&gt;) concurrently,\n  because there is no way to guarantee the eventual packet ordering.\n</code></pre>\n\n<p> </p>\n\n<p> <h3>Default configuration for different Android versions</h3>\n <p>{@code SSLEngine} instances obtained from the default <a href=\"#!/api/javax.net.ssl.SSLContext\" rel=\"javax.net.ssl.SSLContext\" class=\"docClass\">javax.net.ssl.SSLContext</a> are configured as\n follows:</p>\n\n<p> <style type=\"text/css\">\n   tr.deprecated {\n     background-color: #ccc;\n     color: #999;\n     font-style: italic;\n   }\n </style></p>\n\n<p> <h4>Protocols</h4>\n <table>\n     <thead>\n         <tr>\n             <th>Protocol</th>\n             <th>Supported (API Levels)</th>\n             <th>Enabled by default (API Levels)</th>\n         </tr>\n     </thead>\n     <tbody>\n         <tr class=\"deprecated\">\n             <td>SSLv3</td>\n             <td>1&ndash;25</td>\n             <td>1&ndash;22</td>\n         </tr>\n         <tr>\n             <td>TLSv1</td>\n             <td>1+</td>\n             <td>1+</td>\n         </tr>\n         <tr>\n             <td>TLSv1.1</td>\n             <td>20+</td>\n             <td>20+</td>\n         </tr>\n         <tr>\n             <td>TLSv1.2</td>\n             <td>20+</td>\n             <td>20+</td>\n         </tr>\n         <tr>\n             <td>TLSv1.3</td>\n             <td>29+</td>\n             <td>29+</td>\n         </tr>\n     </tbody>\n </table></p>\n\n<p> <h4>Cipher suites</h4>\n <table>\n   <thead>\n     <tr>\n       <th>Cipher suite</th>\n       <th>Supported (API Levels)</th>\n       <th>Enabled by default (API Levels)</th>\n     </tr>\n   </thead>\n   <tbody>\n     <tr class=\"deprecated\">\n       <td>SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DHE_DSS_WITH_DES_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DHE_RSA_WITH_DES_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DH_anon_EXPORT_WITH_RC4_40_MD5</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DH_anon_WITH_3DES_EDE_CBC_SHA</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DH_anon_WITH_DES_CBC_SHA</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_DH_anon_WITH_RC4_128_MD5</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_EXPORT_WITH_RC4_40_MD5</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr>\n       <td>SSL_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>9+</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_WITH_DES_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_WITH_NULL_MD5</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_WITH_NULL_SHA</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_WITH_RC4_128_MD5</td>\n       <td>9-25</td>\n       <td>9-19</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>SSL_RSA_WITH_RC4_128_SHA</td>\n       <td>9-25</td>\n       <td>9-23</td>\n     </tr>\n     <tr>\n       <td>TLS_AES_128_GCM_SHA256</td>\n       <td>29+</td>\n       <td>29+</td>\n     </tr>\n     <tr>\n       <td>TLS_AES_256_GCM_SHA384</td>\n       <td>29+</td>\n       <td>29+</td>\n     </tr>\n     <tr>\n       <td>TLS_CHACHA20_POLY1305_SHA256</td>\n       <td>29+</td>\n       <td>29+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</td>\n       <td>9-22</td>\n       <td>9-22</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_AES_128_GCM_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</td>\n       <td>9-22</td>\n       <td>20-22</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_AES_256_GCM_SHA384</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_DSS_WITH_DES_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</td>\n       <td>9-25</td>\n       <td>9-25</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</td>\n       <td>20-25</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td>\n       <td>20-25</td>\n       <td>20-25</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</td>\n       <td>9-25</td>\n       <td>20-25</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</td>\n       <td>20-25</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</td>\n       <td>20-25</td>\n       <td>20-25</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DHE_RSA_WITH_DES_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_DSS_WITH_DES_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_RSA_WITH_DES_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_AES_128_CBC_SHA</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_AES_128_CBC_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_AES_128_GCM_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_AES_256_CBC_SHA</td>\n       <td>9-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_AES_256_CBC_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_AES_256_GCM_SHA384</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_DH_anon_WITH_DES_CBC_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</td>\n       <td>20-28</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</td>\n       <td>20-28</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</td>\n       <td>24+</td>\n       <td>24+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_ECDSA_WITH_NULL_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</td>\n       <td>20-25</td>\n       <td>20-23</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA</td>\n       <td>21+</td>\n       <td>21+</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA</td>\n       <td>21+</td>\n       <td>21+</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256</td>\n       <td>24+</td>\n       <td>24+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</td>\n       <td>20-28</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</td>\n       <td>20-28</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr>\n       <td>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td>\n       <td>24+</td>\n       <td>24+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_RSA_WITH_NULL_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDHE_RSA_WITH_RC4_128_SHA</td>\n       <td>20-25</td>\n       <td>20-23</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_NULL_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_NULL_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_RSA_WITH_RC4_128_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_anon_WITH_AES_256_CBC_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_anon_WITH_NULL_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_ECDH_anon_WITH_RC4_128_SHA</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_EMPTY_RENEGOTIATION_INFO_SCSV</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr>\n       <td>TLS_FALLBACK_SCSV</td>\n       <td>21+</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_NULL_WITH_NULL_NULL</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_PSK_WITH_3DES_EDE_CBC_SHA</td>\n       <td>21-22</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_PSK_WITH_AES_128_CBC_SHA</td>\n       <td>21+</td>\n       <td>21+</td>\n     </tr>\n     <tr>\n       <td>TLS_PSK_WITH_AES_256_CBC_SHA</td>\n       <td>21+</td>\n       <td>21+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_PSK_WITH_RC4_128_SHA</td>\n       <td>21-25</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr>\n       <td>TLS_RSA_WITH_AES_128_CBC_SHA</td>\n       <td>9+</td>\n       <td>9+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_AES_128_CBC_SHA256</td>\n       <td>20-28</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_RSA_WITH_AES_128_GCM_SHA256</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr>\n       <td>TLS_RSA_WITH_AES_256_CBC_SHA</td>\n       <td>9+</td>\n       <td>20+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_AES_256_CBC_SHA256</td>\n       <td>20-28</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>TLS_RSA_WITH_AES_256_GCM_SHA384</td>\n       <td>20+</td>\n       <td>20+</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_DES_CBC_SHA</td>\n       <td>1-8</td>\n       <td>1-8</td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_NULL_MD5</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_NULL_SHA</td>\n       <td>1-8</td>\n       <td></td>\n     </tr>\n     <tr class=\"deprecated\">\n       <td>TLS_RSA_WITH_NULL_SHA256</td>\n       <td>20-22</td>\n       <td></td>\n     </tr>\n   </tbody>\n </table></p>\n\n<p> <p><em>NOTE</em>: PSK cipher suites are enabled by default only if the {@code SSLContext} through\n which the engine was created has been initialized with a {@code PSKKeyManager}.</p>\n\n<p> @see SSLContext\n @see SSLSocket\n @see SSLServerSocket\n @see SSLSession\n @see java.net.Socket</p>\n        <p>Available since: <b>1.5</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-beginHandshake' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-beginHandshake' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-beginHandshake' class='name expandable'>beginHandshake</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Initiates handshaking (initial or renegotiation) on this SSLEngine. ...</div><div class='long'><p>Initiates handshaking (initial or renegotiation) on this SSLEngine.\n <P>\n This method is not needed for the initial handshake, as the\n <code>wrap()</code> and <code>unwrap()</code> methods will\n implicitly call this method if handshaking has not already begun.\n <P>\n Note that the peer may also request a session renegotiation with\n this <code>SSLEngine</code> by sending the appropriate\n session renegotiate handshake message.\n <P>\n Unlike the javax.net.ssl.SSLSocket#startHandshake() method, this method does not block\n until handshaking is completed.\n <P>\n To force a complete SSL/TLS session renegotiation, the current\n session should be invalidated prior to calling this method.\n <P>\n Some protocols may not support multiple handshakes on an existing\n engine and may throw an <code>SSLException</code>.</P></P></P></P></P></p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>SSLException\n          if a problem was encountered while signaling the\n          <code>SSLEngine</code> to begin a new handshake.\n          See the class description for more information on\n          engine closure.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if the client/server mode\n          has not yet been set.\n@see SSLSession#invalidate()</p>\n</div></li></ul></div></div></div><div id='method-closeInbound' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-closeInbound' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-closeInbound' class='name expandable'>closeInbound</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Signals that no more inbound network data will be sent\n to this SSLEngine. ...</div><div class='long'><p>Signals that no more inbound network data will be sent\n to this <code>SSLEngine</code>.\n <P>\n If the application initiated the closing process by calling\n <a href=\"#!/api/javax.net.ssl.SSLEngine-method-closeOutbound\" rel=\"javax.net.ssl.SSLEngine-method-closeOutbound\" class=\"docClass\">closeOutbound</a>(), under some circumstances it is not\n required that the initiator wait for the peer's corresponding\n close message.  (See section 7.2.1 of the TLS specification (<A\n HREF=\"http://www.ietf.org/rfc/rfc2246.txt\">RFC 2246</A>) for more\n information on waiting for closure alerts.)  In such cases, this\n method need not be called.\n <P>\n But if the application did not initiate the closure process, or\n if the circumstances above do not apply, this method should be\n called whenever the end of the SSL/TLS data stream is reached.\n This ensures closure of the inbound side, and checks that the\n peer followed the SSL/TLS close procedure properly, thus\n detecting possible truncation attacks.\n <P>\n This method is idempotent:  if the inbound side has already\n been closed, this method does not do anything.\n <P>\n ByteBuffer) wrap() should be\n called to flush any remaining handshake data.</P></P></P></P></p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>SSLException\n          if this engine has not received the proper SSL/TLS close\n          notification message from the peer.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-isInboundDone\" rel=\"javax.net.ssl.SSLEngine-method-isInboundDone\" class=\"docClass\">isInboundDone</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-isOutboundDone\" rel=\"javax.net.ssl.SSLEngine-method-isOutboundDone\" class=\"docClass\">isOutboundDone</a>()</p>\n</div></li></ul></div></div></div><div id='method-closeOutbound' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-closeOutbound' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-closeOutbound' class='name expandable'>closeOutbound</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Signals that no more outbound application data will be sent\n on this SSLEngine. ...</div><div class='long'><p>Signals that no more outbound application data will be sent\n on this <code>SSLEngine</code>.\n <P>\n This method is idempotent:  if the outbound side has already\n been closed, this method does not do anything.\n <P>\n ByteBuffer) should be\n called to flush any remaining handshake data.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-isOutboundDone\" rel=\"javax.net.ssl.SSLEngine-method-isOutboundDone\" class=\"docClass\">isOutboundDone</a>()</P></P></p>\n</div></div></div><div id='method-getApplicationProtocol' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getApplicationProtocol' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getApplicationProtocol' class='name expandable'>getApplicationProtocol</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the most recent application protocol value negotiated for this\n connection. ...</div><div class='long'><p>Returns the most recent application protocol value negotiated for this\n connection.\n <p>\n If supported by the underlying SSL/TLS implementation,\n application name negotiation mechanisms such as <a\n href=\"http://www.ietf.org/rfc/rfc7301.txt\"> RFC 7301 </a>, the\n Application-Layer Protocol Negotiation (ALPN), can negotiate\n application-level values between peers.\n <p>\n@implSpec The implementation in this class throws\n {@code UnsupportedOperationException} and performs no other action.</p>\n        <p>Available since: <b>9</b></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>null if it has not yet been determined if application\n         protocols might be used for this connection, an empty\n         {@code String} if application protocols values will not\n         be used, or a non-empty application protocol {@code String}\n         if a value was successfully negotiated.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedOperationException if the underlying provider\n         does not implement the operation.</p>\n</div></li></ul></div></div></div><div id='method-getDelegatedTask' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getDelegatedTask' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getDelegatedTask' class='name expandable'>getDelegatedTask</a>( <span class='pre'></span> ) : Object {java.lang.Runnable}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a delegated Runnable task for\n this SSLEngine. ...</div><div class='long'><p>Returns a delegated <code>Runnable</code> task for\n this <code>SSLEngine</code>.\n <P>\n <code>SSLEngine</code> operations may require the results of\n operations that block, or may take an extended period of time to\n complete.  This method is used to obtain an outstanding java.lang.Runnable operation (task).  Each task must be assigned\n a thread (possibly the current) to perform the run operation.  Once the\n <code>run</code> method returns, the <code>Runnable</code> object\n is no longer needed and may be discarded.\n <P>\n Delegated tasks run in the <code>AccessControlContext</code>\n in place when this object was created.\n <P>\n A call to this method will return each outstanding task\n exactly once.\n <P>\n Multiple delegated tasks can be run in parallel.</P></P></P></P></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.lang.Runnable}</span><div class='sub-desc'><p>a delegated <code>Runnable</code> task, or null\n          if none are available.</p>\n</div></li></ul></div></div></div><div id='method-getEnableSessionCreation' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getEnableSessionCreation' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getEnableSessionCreation' class='name expandable'>getEnableSessionCreation</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns true if new SSL sessions may be established by this engine. ...</div><div class='long'><p>Returns true if new SSL sessions may be established by this engine.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true indicates that sessions may be created; this\n          is the default.  false indicates that an existing session\n          must be resumed\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setEnableSessionCreation\" rel=\"javax.net.ssl.SSLEngine-method-setEnableSessionCreation\" class=\"docClass\">setEnableSessionCreation</a>(boolean)</p>\n</div></li></ul></div></div></div><div id='method-getEnabledCipherSuites' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getEnabledCipherSuites' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getEnabledCipherSuites' class='name expandable'>getEnabledCipherSuites</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the names of the SSL cipher suites which are currently\n enabled for use on this engine. ...</div><div class='long'><p>Returns the names of the SSL cipher suites which are currently\n enabled for use on this engine.  When an SSLEngine is first\n created, all enabled cipher suites support a minimum quality of\n service.  Thus, in some environments this value might be empty.\n <P>\n Even if a suite has been enabled, it might never be used.  (For\n example, the peer does not support it, the requisite\n certificates/private keys for the suite are not available, or an\n anonymous suite is enabled but authentication is required.)</P></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>an array of cipher suite names\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getSupportedCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getSupportedCipherSuites\" class=\"docClass\">getSupportedCipherSuites</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setEnabledCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-setEnabledCipherSuites\" class=\"docClass\">setEnabledCipherSuites</a>(String [])</p>\n</div></li></ul></div></div></div><div id='method-getEnabledProtocols' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getEnabledProtocols' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getEnabledProtocols' class='name expandable'>getEnabledProtocols</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the names of the protocol versions which are currently\n enabled for use with this SSLEngine. ...</div><div class='long'><p>Returns the names of the protocol versions which are currently\n enabled for use with this <code>SSLEngine</code>.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>an array of protocols\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setEnabledProtocols\" rel=\"javax.net.ssl.SSLEngine-method-setEnabledProtocols\" class=\"docClass\">setEnabledProtocols</a>(String [])</p>\n</div></li></ul></div></div></div><div id='method-getHandshakeApplicationProtocol' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getHandshakeApplicationProtocol' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getHandshakeApplicationProtocol' class='name expandable'>getHandshakeApplicationProtocol</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the application protocol value negotiated on a SSL/TLS\n handshake currently in progress. ...</div><div class='long'><p>Returns the application protocol value negotiated on a SSL/TLS\n handshake currently in progress.\n <p>\n Like <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getHandshakeSession\" rel=\"javax.net.ssl.SSLEngine-method-getHandshakeSession\" class=\"docClass\">getHandshakeSession</a>(),\n a connection may be in the middle of a handshake. The\n application protocol may or may not yet be available.\n <p>\n@implSpec The implementation in this class throws\n {@code UnsupportedOperationException} and performs no other action.</p>\n        <p>Available since: <b>9</b></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>null if it has not yet been determined if application\n         protocols might be used for this handshake, an empty\n         {@code String} if application protocols values will not\n         be used, or a non-empty application protocol {@code String}\n         if a value was successfully negotiated.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedOperationException if the underlying provider\n         does not implement the operation.</p>\n</div></li></ul></div></div></div><div id='method-getHandshakeApplicationProtocolSelector' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getHandshakeApplicationProtocolSelector' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getHandshakeApplicationProtocolSelector' class='name expandable'>getHandshakeApplicationProtocolSelector</a>( <span class='pre'></span> ) : Object {java.util.function.BiFunction}<span class=\"signature\"></span></div><div class='description'><div class='short'>Retrieves the callback function that selects an application protocol\n value during a SSL/TLS handshake. ...</div><div class='long'><p>Retrieves the callback function that selects an application protocol\n value during a SSL/TLS handshake.\n See <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setHandshakeApplicationProtocolSelector\" rel=\"javax.net.ssl.SSLEngine-method-setHandshakeApplicationProtocolSelector\" class=\"docClass\">setHandshakeApplicationProtocolSelector</a>\n for the function's type parameters.\n@implSpec The implementation in this class throws\n {@code UnsupportedOperationException} and performs no other action.</p>\n        <p>Available since: <b>9</b></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.util.function.BiFunction}</span><div class='sub-desc'><p>the callback function, or null if none has been set.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedOperationException if the underlying provider\n         does not implement the operation.</p>\n</div></li></ul></div></div></div><div id='method-getHandshakeSession' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getHandshakeSession' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getHandshakeSession' class='name expandable'>getHandshakeSession</a>( <span class='pre'></span> ) : Object {javax.net.ssl.SSLSession}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the {@code SSLSession} being constructed during a SSL/TLS\n handshake. ...</div><div class='long'><p>Returns the {@code SSLSession} being constructed during a SSL/TLS\n handshake.\n <p>\n TLS protocols may negotiate parameters that are needed when using\n an instance of this class, but before the {@code SSLSession} has\n been completely initialized and made available via {@code getSession}.\n For example, the list of valid signature algorithms may restrict\n the type of certificates that can used during TrustManager\n decisions, or the maximum TLS fragment packet sizes can be\n resized to better support the network environment.\n <p>\n This method provides early access to the {@code SSLSession} being\n constructed.  Depending on how far the handshake has progressed,\n some data may not yet be available for use.  For example, if a\n remote server will be sending a Certificate chain, but that chain\n has yet not been processed, the {@code getPeerCertificates}\n method of {@code SSLSession} will throw a\n SSLPeerUnverifiedException.  Once that chain has been processed,\n {@code getPeerCertificates} will return the proper value.\n@see SSLSocket\n@see SSLSession\n@see ExtendedSSLSession\n@see X509ExtendedKeyManager\n@see X509ExtendedTrustManager</p>\n        <p>Available since: <b>1.7</b></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {javax.net.ssl.SSLSession}</span><div class='sub-desc'><p>null if this instance is not currently handshaking, or\n         if the current handshake has not progressed far enough to\n         create a basic SSLSession.  Otherwise, this method returns the\n         {@code SSLSession} currently being negotiated.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedOperationException if the underlying provider\n         does not implement the operation.</p>\n</div></li></ul></div></div></div><div id='method-getHandshakeStatus' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getHandshakeStatus' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getHandshakeStatus' class='name expandable'>getHandshakeStatus</a>( <span class='pre'></span> ) : Object {javax.net.ssl.SSLEngineResult.HandshakeStatus}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the current handshake status for this SSLEngine. ...</div><div class='long'><p>Returns the current handshake status for this <code>SSLEngine</code>.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {javax.net.ssl.SSLEngineResult.HandshakeStatus}</span><div class='sub-desc'><p>the current <code>SSLEngineResult.HandshakeStatus</code>.</p>\n</div></li></ul></div></div></div><div id='method-getNeedClientAuth' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getNeedClientAuth' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getNeedClientAuth' class='name expandable'>getNeedClientAuth</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns true if the engine will require client authentication. ...</div><div class='long'><p>Returns true if the engine will <i>require</i> client authentication.\n This option is only useful to engines in the server mode.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if client authentication is required,\n          or false if no client authentication is desired.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setNeedClientAuth\" class=\"docClass\">setNeedClientAuth</a>(boolean)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setWantClientAuth\" class=\"docClass\">setWantClientAuth</a>(boolean)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-getWantClientAuth\" class=\"docClass\">getWantClientAuth</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-setUseClientMode\" class=\"docClass\">setUseClientMode</a>(boolean)</p>\n</div></li></ul></div></div></div><div id='method-getPeerHost' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getPeerHost' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getPeerHost' class='name expandable'>getPeerHost</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the host name of the peer. ...</div><div class='long'><p>Returns the host name of the peer.\n <P>\n Note that the value is not authenticated, and should not be\n relied upon.</P></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>the host name of the peer, or null if nothing is\n          available.</p>\n</div></li></ul></div></div></div><div id='method-getPeerPort' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getPeerPort' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getPeerPort' class='name expandable'>getPeerPort</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the port number of the peer. ...</div><div class='long'><p>Returns the port number of the peer.\n <P>\n Note that the value is not authenticated, and should not be\n relied upon.</P></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the port number of the peer, or -1 if nothing is\n          available.</p>\n</div></li></ul></div></div></div><div id='method-getSSLParameters' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getSSLParameters' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getSSLParameters' class='name expandable'>getSSLParameters</a>( <span class='pre'></span> ) : Object {javax.net.ssl.SSLParameters}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the SSLParameters in effect for this SSLEngine. ...</div><div class='long'><p>Returns the SSLParameters in effect for this SSLEngine.\n The ciphersuites and protocols of the returned SSLParameters\n are always non-null.</p>\n        <p>Available since: <b>1.6</b></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {javax.net.ssl.SSLParameters}</span><div class='sub-desc'><p>the SSLParameters in effect for this SSLEngine.</p>\n</div></li></ul></div></div></div><div id='method-getSession' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getSession' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getSession' class='name expandable'>getSession</a>( <span class='pre'></span> ) : Object {javax.net.ssl.SSLSession}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the SSLSession in use in this\n SSLEngine. ...</div><div class='long'><p>Returns the <code>SSLSession</code> in use in this\n <code>SSLEngine</code>.\n <P>\n These can be long lived, and frequently correspond to an entire\n login session for some user.  The session specifies a particular\n cipher suite which is being actively used by all connections in\n that session, as well as the identities of the session's client\n and server.\n <P>\n Unlike javax.net.ssl.SSLSocket.getSession()\n this method does not block until handshaking is complete.\n <P>\n Until the initial handshake has completed, this method returns\n a session object which reports an invalid cipher suite of\n \"SSL_NULL_WITH_NULL_NULL\".</P></P></P></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {javax.net.ssl.SSLSession}</span><div class='sub-desc'><p>the <code>SSLSession</code> for this <code>SSLEngine</code>\n@see SSLSession</p>\n</div></li></ul></div></div></div><div id='method-getSupportedCipherSuites' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getSupportedCipherSuites' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getSupportedCipherSuites' class='name expandable'>getSupportedCipherSuites</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the names of the cipher suites which could be enabled for use\n on this engine. ...</div><div class='long'><p>Returns the names of the cipher suites which could be enabled for use\n on this engine.  Normally, only a subset of these will actually\n be enabled by default, since this list may include cipher suites which\n do not meet quality of service requirements for those defaults.  Such\n cipher suites might be useful in specialized applications.</p>\n\n<p> <p class=\"caution\">Applications should not blindly enable all supported\n cipher suites.  The supported cipher suites can include signaling cipher suite\n values that can cause connection problems if enabled inappropriately.</p>\n\n<p> <p>The proper way to use this method is to either check if a specific cipher\n suite is supported via {@code Arrays.asList(getSupportedCipherSuites()).contains(...)}\n or to filter a desired list of cipher suites to only the supported ones via\n {@code desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites()))}.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>an array of cipher suite names\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" class=\"docClass\">getEnabledCipherSuites</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setEnabledCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-setEnabledCipherSuites\" class=\"docClass\">setEnabledCipherSuites</a>(String [])</p>\n</div></li></ul></div></div></div><div id='method-getSupportedProtocols' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getSupportedProtocols' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getSupportedProtocols' class='name expandable'>getSupportedProtocols</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the names of the protocols which could be enabled for use\n with this SSLEngine. ...</div><div class='long'><p>Returns the names of the protocols which could be enabled for use\n with this <code>SSLEngine</code>.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>an array of protocols supported</p>\n</div></li></ul></div></div></div><div id='method-getUseClientMode' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getUseClientMode' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getUseClientMode' class='name expandable'>getUseClientMode</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns true if the engine is set to use client mode when\n handshaking. ...</div><div class='long'><p>Returns true if the engine is set to use client mode when\n handshaking.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if the engine should do handshaking\n          in \"client\" mode\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-setUseClientMode\" class=\"docClass\">setUseClientMode</a>(boolean)</p>\n</div></li></ul></div></div></div><div id='method-getWantClientAuth' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-getWantClientAuth' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-getWantClientAuth' class='name expandable'>getWantClientAuth</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns true if the engine will request client authentication. ...</div><div class='long'><p>Returns true if the engine will <i>request</i> client authentication.\n This option is only useful for engines in the server mode.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if client authentication is requested,\n          or false if no client authentication is desired.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setNeedClientAuth\" class=\"docClass\">setNeedClientAuth</a>(boolean)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-getNeedClientAuth\" class=\"docClass\">getNeedClientAuth</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setWantClientAuth\" class=\"docClass\">setWantClientAuth</a>(boolean)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-setUseClientMode\" class=\"docClass\">setUseClientMode</a>(boolean)</p>\n</div></li></ul></div></div></div><div id='method-isInboundDone' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-isInboundDone' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-isInboundDone' class='name expandable'>isInboundDone</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns whether ByteBuffer) will\n accept any more inbound data messages. ...</div><div class='long'><p>Returns whether ByteBuffer) will\n accept any more inbound data messages.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if the <code>SSLEngine</code> will not\n          consume anymore network data (and by implication,\n          will not produce any more application data.)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-closeInbound\" rel=\"javax.net.ssl.SSLEngine-method-closeInbound\" class=\"docClass\">closeInbound</a>()</p>\n</div></li></ul></div></div></div><div id='method-isOutboundDone' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-isOutboundDone' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-isOutboundDone' class='name expandable'>isOutboundDone</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns whether ByteBuffer) will\n produce any more outbound data messages. ...</div><div class='long'><p>Returns whether ByteBuffer) will\n produce any more outbound data messages.\n <P>\n Note that during the closure phase, a <code>SSLEngine</code> may\n generate handshake closure data that must be sent to the peer.\n <code>wrap()</code> must be called to generate this data.  When\n this method returns true, no more outbound data will be created.</P></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if the <code>SSLEngine</code> will not produce\n          any more network data\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-closeOutbound\" rel=\"javax.net.ssl.SSLEngine-method-closeOutbound\" class=\"docClass\">closeOutbound</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-closeInbound\" rel=\"javax.net.ssl.SSLEngine-method-closeInbound\" class=\"docClass\">closeInbound</a>()</p>\n</div></li></ul></div></div></div><div id='method-setEnableSessionCreation' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setEnableSessionCreation' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setEnableSessionCreation' class='name expandable'>setEnableSessionCreation</a>( <span class='pre'>flag</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Controls whether new SSL sessions may be established by this engine. ...</div><div class='long'><p>Controls whether new SSL sessions may be established by this engine.\n If session creations are not allowed, and there are no\n existing sessions to resume, there will be no successful\n handshaking.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>flag</span> : Boolean<div class='sub-desc'><p>true indicates that sessions may be created; this\n          is the default.  false indicates that an existing session\n          must be resumed\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getEnableSessionCreation\" rel=\"javax.net.ssl.SSLEngine-method-getEnableSessionCreation\" class=\"docClass\">getEnableSessionCreation</a>()</p>\n</div></li></ul></div></div></div><div id='method-setEnabledCipherSuites' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setEnabledCipherSuites' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setEnabledCipherSuites' class='name expandable'>setEnabledCipherSuites</a>( <span class='pre'>suites</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Sets the cipher suites enabled for use on this engine. ...</div><div class='long'><p>Sets the cipher suites enabled for use on this engine.\n <P>\n Each cipher suite in the <code>suites</code> parameter must have\n been listed by getSupportedCipherSuites(), or the method will\n fail.  Following a successful call to this method, only suites\n listed in the <code>suites</code> parameter are enabled for use.\n <P>\n See <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" class=\"docClass\">getEnabledCipherSuites</a>() for more information\n on why a specific cipher suite may never be used on a engine.</P></P></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>suites</span> : Object {java.lang.String[]}<div class='sub-desc'><p>Names of all the cipher suites to enable</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException when one or more of the ciphers\n          named by the parameter is not supported, or when the\n          parameter is null.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getSupportedCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getSupportedCipherSuites\" class=\"docClass\">getSupportedCipherSuites</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" rel=\"javax.net.ssl.SSLEngine-method-getEnabledCipherSuites\" class=\"docClass\">getEnabledCipherSuites</a>()</p>\n</div></li></ul></div></div></div><div id='method-setEnabledProtocols' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setEnabledProtocols' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setEnabledProtocols' class='name expandable'>setEnabledProtocols</a>( <span class='pre'>protocols</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Set the protocol versions enabled for use on this engine. ...</div><div class='long'><p>Set the protocol versions enabled for use on this engine.\n <P>\n The protocols must have been listed by getSupportedProtocols()\n as being supported.  Following a successful call to this method,\n only protocols listed in the <code>protocols</code> parameter\n are enabled for use.\n <p>\n Because of the way the protocol version is negotiated, connections\n will only be able to use a member of the lowest set of contiguous\n enabled protocol versions.  For example, enabling TLSv1.2 and TLSv1\n will result in connections only being able to use TLSv1.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>protocols</span> : Object {java.lang.String[]}<div class='sub-desc'><p>Names of all the protocols to enable.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException when one or more of\n          the protocols named by the parameter is not supported or\n          when the protocols parameter is null.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getEnabledProtocols\" rel=\"javax.net.ssl.SSLEngine-method-getEnabledProtocols\" class=\"docClass\">getEnabledProtocols</a>()</p>\n</div></li></ul></div></div></div><div id='method-setHandshakeApplicationProtocolSelector' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setHandshakeApplicationProtocolSelector' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setHandshakeApplicationProtocolSelector' class='name expandable'>setHandshakeApplicationProtocolSelector</a>( <span class='pre'>selector, selector</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Registers a callback function that selects an application protocol\n value for a SSL/TLS handshake. ...</div><div class='long'><p>Registers a callback function that selects an application protocol\n value for a SSL/TLS handshake.\n The function overrides any values supplied using\n <a href=\"#!/api/javax.net.ssl.SSLParameters-method-setApplicationProtocols\" rel=\"javax.net.ssl.SSLParameters-method-setApplicationProtocols\" class=\"docClass\">javax.net.ssl.SSLParameters.setApplicationProtocols</a> and it supports the following\n type parameters:\n <blockquote>\n <dl>\n <dt> {@code SSLEngine}\n <dd> The function's first argument allows the current {@code SSLEngine}\n      to be inspected, including the handshake session and configuration\n      settings.\n <dt> {@code List<String>}\n <dd> The function's second argument lists the application protocol names\n      advertised by the TLS peer.\n <dt> {@code String}\n <dd> The function's result is an application protocol name, or null to\n      indicate that none of the advertised names are acceptable.\n      If the return value is an empty {@code String} then application\n      protocol indications will not be used.\n      If the return value is null (no value chosen) or is a value that\n      was not advertised by the peer, the underlying protocol will\n      determine what action to take. (For example, ALPN will send a\n      \"no_application_protocol\" alert and terminate the connection.)\n </dd></dt></dd></String></dt></dd></dt></dl>\n </blockquote></p>\n\n<p> For example, the following call registers a callback function that\n examines the TLS handshake parameters and selects an application protocol\n name:\n <pre>{@code\n     serverEngine.setHandshakeApplicationProtocolSelector(\n         (serverEngine, clientProtocols) -> {\n             SSLSession session = serverEngine.getHandshakeSession();\n             return chooseApplicationProtocol(\n                 serverEngine,\n                 clientProtocols,\n                 session.getProtocol(),\n                 session.getCipherSuite());\n         });\n }</pre></p>\n        <p>Available since: <b>9</b></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>selector</span> : Object {java.util.function.BiFunction}<div class='sub-desc'><p>the callback function, or null to disable the callback\n         functionality.\n@implSpec The implementation in this class throws\n {@code UnsupportedOperationException} and performs no other action.</p>\n</div></li><li><span class='pre'>selector</span> : Object<div class='sub-desc'><p>the callback function, or null to disable the callback\n         functionality.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedOperationException if the underlying provider\n         does not implement the operation.</p>\n</div></li></ul></div></div></div><div id='method-setNeedClientAuth' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setNeedClientAuth' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setNeedClientAuth' class='name expandable'>setNeedClientAuth</a>( <span class='pre'>need</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Configures the engine to require client authentication. ...</div><div class='long'><p>Configures the engine to <i>require</i> client authentication.  This\n option is only useful for engines in the server mode.\n <P>\n An engine's client authentication setting is one of the following:\n <ul>\n <li> client authentication required\n <li> client authentication requested\n <li> no client authentication desired\n </li></li></li></ul>\n <P>\n Unlike <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setWantClientAuth\" class=\"docClass\">setWantClientAuth</a>(boolean), if this option is set and\n the client chooses not to provide authentication information\n about itself, <i>the negotiations will stop and the engine will\n begin its closure procedure</i>.\n <P>\n Calling this method overrides any previous setting made by\n this method or <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setWantClientAuth\" class=\"docClass\">setWantClientAuth</a>(boolean).</P></P></P></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>need</span> : Boolean<div class='sub-desc'><p>set to true if client authentication is required,\n          or false if no client authentication is desired.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-getNeedClientAuth\" class=\"docClass\">getNeedClientAuth</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setWantClientAuth\" class=\"docClass\">setWantClientAuth</a>(boolean)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-getWantClientAuth\" class=\"docClass\">getWantClientAuth</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-setUseClientMode\" class=\"docClass\">setUseClientMode</a>(boolean)</p>\n</div></li></ul></div></div></div><div id='method-setSSLParameters' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setSSLParameters' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setSSLParameters' class='name expandable'>setSSLParameters</a>( <span class='pre'>params</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Applies SSLParameters to this engine. ...</div><div class='long'><p>Applies SSLParameters to this engine.</p>\n\n<p> <p>This means:\n <ul>\n <li>If {@code params.getCipherSuites()} is non-null,\n   {@code setEnabledCipherSuites()} is called with that value.</li>\n <li>If {@code params.getProtocols()} is non-null,\n   {@code setEnabledProtocols()} is called with that value.</li>\n <li>If {@code params.getNeedClientAuth()} or\n   {@code params.getWantClientAuth()} return {@code true},\n   {@code setNeedClientAuth(true)} and\n   {@code setWantClientAuth(true)} are called, respectively;\n   otherwise {@code setWantClientAuth(false)} is called.</li>\n <li>If {@code params.getServerNames()} is non-null, the engine will\n   configure its server names with that value.</li>\n <li>If {@code params.getSNIMatchers()} is non-null, the engine will\n   configure its SNI matchers with that value.</li>\n </ul></p>\n        <p>Available since: <b>1.6</b></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>params</span> : Object {SSLParameters}<div class='sub-desc'><p>the parameters</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the setEnabledCipherSuites() or\n    the setEnabledProtocols() call fails</p>\n</div></li></ul></div></div></div><div id='method-setUseClientMode' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setUseClientMode' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode' class='name expandable'>setUseClientMode</a>( <span class='pre'>mode</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Configures the engine to use client (or server) mode when\n handshaking. ...</div><div class='long'><p>Configures the engine to use client (or server) mode when\n handshaking.\n <P>\n This method must be called before any handshaking occurs.\n Once handshaking has begun, the mode can not be reset for the\n life of this engine.\n <P>\n Servers normally authenticate themselves, and clients\n are not required to do so.</P></P></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>mode</span> : Boolean<div class='sub-desc'><p>true if the engine should start its handshaking\n          in \"client\" mode</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if a mode change is attempted\n          after the initial handshake has begun.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-getUseClientMode\" class=\"docClass\">getUseClientMode</a>()</p>\n</div></li></ul></div></div></div><div id='method-setWantClientAuth' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-setWantClientAuth' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-setWantClientAuth' class='name expandable'>setWantClientAuth</a>( <span class='pre'>want</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Configures the engine to request client authentication. ...</div><div class='long'><p>Configures the engine to <i>request</i> client authentication.\n This option is only useful for engines in the server mode.\n <P>\n An engine's client authentication setting is one of the following:\n <ul>\n <li> client authentication required\n <li> client authentication requested\n <li> no client authentication desired\n </li></li></li></ul>\n <P>\n Unlike <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setNeedClientAuth\" class=\"docClass\">setNeedClientAuth</a>(boolean), if this option is set and\n the client chooses not to provide authentication information\n about itself, <i>the negotiations will continue</i>.\n <P>\n Calling this method overrides any previous setting made by\n this method or <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setNeedClientAuth\" class=\"docClass\">setNeedClientAuth</a>(boolean).</P></P></P></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>want</span> : Boolean<div class='sub-desc'><p>set to true if client authentication is requested,\n          or false if no client authentication is desired.\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getWantClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-getWantClientAuth\" class=\"docClass\">getWantClientAuth</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-setNeedClientAuth\" class=\"docClass\">setNeedClientAuth</a>(boolean)\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-getNeedClientAuth\" rel=\"javax.net.ssl.SSLEngine-method-getNeedClientAuth\" class=\"docClass\">getNeedClientAuth</a>()\n@see <a href=\"#!/api/javax.net.ssl.SSLEngine-method-setUseClientMode\" rel=\"javax.net.ssl.SSLEngine-method-setUseClientMode\" class=\"docClass\">setUseClientMode</a>(boolean)</p>\n</div></li></ul></div></div></div><div id='method-unwrap' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-unwrap' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-unwrap' class='name expandable'>unwrap</a>( <span class='pre'>src, dsts, offset, length</span> ) : Object {javax.net.ssl.SSLEngineResult}<span class=\"signature\"></span></div><div class='description'><div class='short'>Attempts to decode SSL/TLS network data into a subsequence of\n plaintext application data buffers. ...</div><div class='long'><p>Attempts to decode SSL/TLS network data into a subsequence of\n plaintext application data buffers.  This <i>\"scattering\"</i>\n operation decodes, in a single invocation, a sequence of bytes\n into one or more of a given sequence of buffers.  Scattering\n unwraps are often useful when implementing network protocols or\n file formats that, for example, group data into segments\n consisting of one or more fixed-length headers followed by a\n variable-length body.  See\n java.nio.channels.ScatteringByteChannel for more\n information on scattering, and int, int) for more information on the subsequence\n behavior.\n <P>\n Depending on the state of the SSLEngine, this method may consume\n network data without producing any application data (for example,\n it may consume handshake data.)\n <P>\n The application is responsible for reliably obtaining the network\n data from the peer, and for invoking unwrap() on the data in the\n order it was received.  The application must properly synchronize\n multiple calls to this method.\n <P>\n If this <code>SSLEngine</code> has not yet started its initial\n handshake, this method will automatically start the handshake.\n <P>\n This method will attempt to consume one complete SSL/TLS network\n packet, but will never consume more than the sum of the bytes\n remaining in the buffers.  Each <code>ByteBuffer</code>'s\n position is updated to reflect the amount of data consumed or\n produced.  The limits remain the same.\n <P>\n The underlying memory used by the <code>src</code> and\n <code>dsts ByteBuffer</code>s must not be the same.\n <P>\n The inbound network buffer may be modified as a result of this\n call:  therefore if the network data packet is required for some\n secondary purpose, the data should be duplicated before calling this\n method.  Note:  the network data will not be useful to a second\n SSLEngine, as each SSLEngine contains unique random state which\n influences the SSL/TLS messages.\n <P>\n See the class description for more information on engine closure.</P></P></P></P></P></P></P></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>src</span> : Object {ByteBuffer}<div class='sub-desc'><p>a <code>ByteBuffer</code> containing inbound network data.</p>\n</div></li><li><span class='pre'>dsts</span> : Object {java.nio.ByteBuffer[]}<div class='sub-desc'><p>an array of <code>ByteBuffer</code>s to hold inbound\n          application data.</p>\n</div></li><li><span class='pre'>offset</span> : Number<div class='sub-desc'><p>The offset within the buffer array of the first buffer from\n          which bytes are to be transferred; it must be non-negative\n          and no larger than <code>dsts.length</code>.</p>\n</div></li><li><span class='pre'>length</span> : Number<div class='sub-desc'><p>The maximum number of buffers to be accessed; it must be\n          non-negative and no larger than\n          <code>dsts.length</code>&nbsp;-&nbsp;<code>offset</code>.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {javax.net.ssl.SSLEngineResult}</span><div class='sub-desc'><p>an <code>SSLEngineResult</code> describing the result\n          of this operation.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>SSLException\n          A problem was encountered while processing the\n          data that caused the <code>SSLEngine</code> to abort.\n          See the class description for more information on\n          engine closure.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IndexOutOfBoundsException\n          If the preconditions on the <code>offset</code> and\n          <code>length</code> parameters do not hold.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ReadOnlyBufferException\n          if any of the <code>dst</code> buffers are read-only.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException\n          if either <code>src</code> or <code>dsts</code>\n          is null, or if any element in the <code>dsts</code>\n          subsequence specified is null.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if the client/server mode\n          has not yet been set.\n@see java.nio.channels.ScatteringByteChannel\n@see java.nio.channels.ScatteringByteChannel#read(\n              ByteBuffer[], int, int)</p>\n</div></li></ul></div></div></div><div id='method-wrap' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='javax.net.ssl.SSLEngine'>javax.net.ssl.SSLEngine</span><br/><a href='source/SSLEngine.html#javax-net-ssl-SSLEngine-method-wrap' target='_blank' class='view-source'>view source</a></div><a href='#!/api/javax.net.ssl.SSLEngine-method-wrap' class='name expandable'>wrap</a>( <span class='pre'>srcs, offset, length, dst</span> ) : Object {javax.net.ssl.SSLEngineResult}<span class=\"signature\"></span></div><div class='description'><div class='short'>Attempts to encode plaintext bytes from a subsequence of data\n buffers into SSL/TLS network data. ...</div><div class='long'><p>Attempts to encode plaintext bytes from a subsequence of data\n buffers into SSL/TLS network data.  This <i>\"gathering\"</i>\n operation encodes, in a single invocation, a sequence of bytes\n from one or more of a given sequence of buffers.  Gathering\n wraps are often useful when implementing network protocols or\n file formats that, for example, group data into segments\n consisting of one or more fixed-length headers followed by a\n variable-length body.  See\n java.nio.channels.GatheringByteChannel for more\n information on gathering, and int, int) for more information on the subsequence\n behavior.\n <P>\n Depending on the state of the SSLEngine, this method may produce\n network data without consuming any application data (for example,\n it may generate handshake data.)\n <P>\n The application is responsible for reliably transporting the\n network data to the peer, and for ensuring that data created by\n multiple calls to wrap() is transported in the same order in which\n it was generated.  The application must properly synchronize\n multiple calls to this method.\n <P>\n If this <code>SSLEngine</code> has not yet started its initial\n handshake, this method will automatically start the handshake.\n <P>\n This method will attempt to produce SSL/TLS records, and will\n consume as much source data as possible, but will never consume\n more than the sum of the bytes remaining in each buffer.  Each\n <code>ByteBuffer</code>'s position is updated to reflect the\n amount of data consumed or produced.  The limits remain the\n same.\n <P>\n The underlying memory used by the <code>srcs</code> and\n <code>dst ByteBuffer</code>s must not be the same.\n <P>\n See the class description for more information on engine closure.</P></P></P></P></P></P></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>srcs</span> : Object {java.nio.ByteBuffer[]}<div class='sub-desc'><p>an array of <code>ByteBuffers</code> containing the\n          outbound application data</p>\n</div></li><li><span class='pre'>offset</span> : Number<div class='sub-desc'><p>The offset within the buffer array of the first buffer from\n          which bytes are to be retrieved; it must be non-negative\n          and no larger than <code>srcs.length</code></p>\n</div></li><li><span class='pre'>length</span> : Number<div class='sub-desc'><p>The maximum number of buffers to be accessed; it must be\n          non-negative and no larger than\n          <code>srcs.length</code>&nbsp;-&nbsp;<code>offset</code></p>\n</div></li><li><span class='pre'>dst</span> : Object {ByteBuffer}<div class='sub-desc'><p>a <code>ByteBuffer</code> to hold outbound network data</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {javax.net.ssl.SSLEngineResult}</span><div class='sub-desc'><p>an <code>SSLEngineResult</code> describing the result\n          of this operation.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>SSLException\n          A problem was encountered while processing the\n          data that caused the <code>SSLEngine</code> to abort.\n          See the class description for more information on\n          engine closure.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IndexOutOfBoundsException\n          if the preconditions on the <code>offset</code> and\n          <code>length</code> parameters do not hold.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ReadOnlyBufferException\n          if the <code>dst</code> buffer is read-only.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException\n          if either <code>srcs</code> or <code>dst</code>\n          is null, or if any element in the <code>srcs</code>\n          subsequence specified is null.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if the client/server mode\n          has not yet been set.\n@see java.nio.channels.GatheringByteChannel\n@see java.nio.channels.GatheringByteChannel#write(\n              ByteBuffer[], int, int)</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});