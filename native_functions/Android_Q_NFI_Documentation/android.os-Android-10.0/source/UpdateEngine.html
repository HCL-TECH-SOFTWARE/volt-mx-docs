<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-os-UpdateEngine'>/**@class android.os.UpdateEngine
</span>@extends java.lang.Object

 UpdateEngine handles calls to the update engine which takes care of A/B OTA
 updates. It wraps up the update engine Binder APIs and exposes them as
 SystemApis, which will be called by the system app responsible for OTAs.
 On a Google device, this will be GmsCore.

 The minimal flow is:
 &lt;ol&gt;
 &lt;li&gt;Create a new UpdateEngine instance.
 &lt;li&gt;Call {@link #bind}, optionally providing callbacks.
 &lt;li&gt;Call {@link #applyPayload}.
 &lt;/ol&gt;

 In addition, methods are provided to {@link #cancel} or
 {@link #suspend}/{@link #resume} application of an update.

 The APIs defined in this class and UpdateEngineCallback class must be in
 sync with the ones in
 {@code system/update_engine/binder_bindings/android/os/IUpdateEngine.aidl}
 and
 {@code system/update_engine/binder_bindings/android/os/IUpdateEngineCallback.aidl}.

 {@hide}
*/
var UpdateEngine = {

<span id='android-os-UpdateEngine-method-bind'>/**Prepares this instance for use. The callback will be notified on any
</span> status change, and when the update completes. A handler can be supplied
 to control which thread runs the callback, or null.
*/
bind : function(  ) {},

<span id='android-os-UpdateEngine-method-bind'>/**Equivalent to {@code bind(callback, null)}.
</span>*/
bind : function(  ) {},

<span id='android-os-UpdateEngine-method-applyPayload'>/**Applies the payload found at the given {@code url}. For non-streaming
</span> updates, the URL can be a local file using the {@code file://} scheme.

 &lt;p&gt;The {@code offset} and {@code size} parameters specify the location
 of the payload within the file represented by the URL. This is useful
 if the downloadable package at the URL contains more than just the
 update_engine payload (such as extra metadata). This is true for
 Google's OTA system, where the URL points to a zip file in which the
 payload is stored uncompressed within the zip file alongside other
 data.

 &lt;p&gt;The {@code headerKeyValuePairs} parameter is used to pass metadata
 to update_engine. In Google's implementation, this is stored as
 {@code payload_properties.txt} in the zip file. It's generated by the
 script {@code system/update_engine/scripts/brillo_update_payload}.
 The complete list of keys and their documentation is in
 {@code system/update_engine/common/constants.cc}, but an example
 might be:
 &lt;pre&gt;
 String[] pairs = {
   &quot;FILE_HASH=lURPCIkIAjtMOyB/EjQcl8zDzqtD6Ta3tJef6G/+z2k=&quot;,
   &quot;FILE_SIZE=871903868&quot;,
   &quot;METADATA_HASH=tBvj43QOB0Jn++JojcpVdbRLz0qdAuL+uTkSy7hokaw=&quot;,
   &quot;METADATA_SIZE=70604&quot;
 };
 &lt;/pre&gt;

 &lt;p&gt;The callback functions registered via {@code #bind} will be called
 during and at the end of the payload application.

 &lt;p&gt;By default the newly updated slot will be set active upon
 successfully finishing an update. Device will attempt to boot into the
 new slot on next reboot. This behavior can be customized by specifying
 {@code SWITCH_SLOT_ON_REBOOT=0} in {@code headerKeyValuePairs}, which
 allows the caller to later determine a good time to boot into the new
 slot. Calling {@code applyPayload} again with the same payload but with
 {@code SWITCH_SLOT_ON_REBOOT=1} will do the minimal work to set the new
 slot active, after verifying its integrity.
*/
applyPayload : function(  ) {},

<span id='android-os-UpdateEngine-method-cancel'>/**Permanently cancels an in-progress update.
</span>
 &lt;p&gt;See {@link #resetStatus} to undo a finshed update (only available
 before the updated system has been rebooted).

 &lt;p&gt;See {@link #suspend} for a way to temporarily stop an in-progress
 update with the ability to resume it later.
*/
cancel : function(  ) {},

<span id='android-os-UpdateEngine-method-suspend'>/**Suspends an in-progress update. This can be undone by calling
</span> {@link #resume}.
*/
suspend : function(  ) {},

<span id='android-os-UpdateEngine-method-resume'>/**Resumes a suspended update.
</span>*/
resume : function(  ) {},

<span id='android-os-UpdateEngine-method-resetStatus'>/**Resets the bootable flag on the non-current partition and all internal
</span> update_engine state. This can be used after an unwanted payload has been
 successfully applied and the device has not yet been rebooted to signal
 that we no longer want to boot into that updated system. After this call
 completes, update_engine will no longer report
 {@code UPDATED_NEED_REBOOT}, so your callback can remove any outstanding
 notification that rebooting into the new system is possible.
*/
resetStatus : function(  ) {},

<span id='android-os-UpdateEngine-method-unbind'>/**Unbinds the last bound callback function.
</span>*/
unbind : function(  ) {},

<span id='android-os-UpdateEngine-method-verifyPayloadMetadata'>/**Verifies that a payload associated with the given payload metadata
</span> {@code payloadMetadataFilename} can be safely applied to ths device.
 Returns {@code true} if the update can successfully be applied and
 returns {@code false} otherwise.
@param {String} payloadMetadataFilename the location of the metadata without the
 {@code file://} prefix.
*/
verifyPayloadMetadata : function(  ) {},


};</pre>
</body>
</html>
