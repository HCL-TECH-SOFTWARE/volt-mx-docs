<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-hardware-SensorAdditionalInfo'>/**@class android.hardware.SensorAdditionalInfo
</span>@extends java.lang.Object

 This class represents a {@link android.hardware.Sensor Sensor} additional information frame,
 which is reported through listener callback {@link android.hardware.SensorEventCallback#onSensorAdditionalInfo onSensorAdditionalInfo}.

 @see SensorManager
 @see SensorEventCallback
 @see Sensor

*/
var SensorAdditionalInfo = {

<span id='android-hardware-SensorAdditionalInfo-property-sensor'>/** The sensor that generated this event. See
</span> {@link android.hardware.SensorManager SensorManager} for details.
*/
sensor : &quot;null&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-type'>/** Type of this additional info frame.
</span>*/
type : &quot;null&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-serial'>/** Sequence number of frame for a certain type.
</span>*/
serial : &quot;null&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-floatValues'>/** Additional info payload data represented in float values. Depending on the type of
</span> information, this may be null.
*/
floatValues : &quot;null&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-intValues'>/** Additional info payload data represented in int values. Depending on the type of information,
</span> this may be null.
*/
intValues : &quot;null&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_FRAME_BEGIN'>/** Mark the beginning of a set of additional info frames.
</span>*/
TYPE_FRAME_BEGIN : &quot;0&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_FRAME_END'>/** Mark the end of a set of additional info frames.
</span>*/
TYPE_FRAME_END : &quot;1&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_UNTRACKED_DELAY'>/** Untracked delay. Delays that are introduced by data processing, such as filtering, which is
</span> not taken into account by sensor timestamps.

 Payload:
     floatValues[0]: delay estimation in seconds
     floatValues[1]: delay estimation standard deviation
*/
TYPE_UNTRACKED_DELAY : &quot;65536&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_INTERNAL_TEMPERATURE'>/** Internal temperature. Sensor hardware device internal temperature.
</span>
 Payload:
     floatValues[0]: internal temperature in Celsius.
*/
TYPE_INTERNAL_TEMPERATURE : &quot;65537&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_VEC3_CALIBRATION'>/** Vector calibration parameter. Calibration applied to a sensor with 3 elements vector output,
</span> such as accelerometer, gyro, etc.

 Payload:
     floatValues[0..11]: First 3 rows of a homogeneous matrix in row major order that captures
     any linear transformation, including rotation, scaling, shear, shift.
*/
TYPE_VEC3_CALIBRATION : &quot;65538&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_SENSOR_PLACEMENT'>/** Sensor placement.
</span>
 Provides the orientation and location of the sensor element in terms of the
 Android coordinate system. This data is given as a 3x4 matrix consisting of a 3x3 rotation
 matrix (R) concatenated with a 3x1 location vector (t). The rotation matrix provides the
 orientation of the Android device coordinate frame relative to the local coordinate frame of
 the sensor. Note that assuming the axes conventions of the sensor are the same as Android,
 this is the inverse of the matrix applied to raw samples read from the sensor to convert them
 into the Android representation. The location vector represents the translation from the
 origin of the Android sensor coordinate system to the geometric center of the sensor,
 specified in millimeters (mm).
 &lt;p&gt;
 &lt;b&gt;Payload&lt;/b&gt;:
     &lt;code&gt;floatValues[0..11]&lt;/code&gt;: 3x4 matrix in row major order [R; t]
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example&lt;/b&gt;:
     This raw buffer: &lt;code&gt;{0, 1, 0, 0, -1, 0, 0, 10, 0, 0, 1, -2.5}&lt;/code&gt;&lt;br&gt;
     Corresponds to this 3x4 matrix:
     &lt;table&gt;
      &lt;thead&gt;
       &lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;Orientation&lt;/td&gt;&lt;td&gt;Location&lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
       &lt;tr&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;
       &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;-2.5&lt;/td&gt;&lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
     The sensor is oriented such that:
     &lt;ul&gt;
        &lt;li&gt;The device X axis corresponds to the sensor's local -Y axis
        &lt;li&gt;The device Y axis corresponds to the sensor's local X axis
        &lt;li&gt;The device Z axis and sensor's local Z axis are equivalent
     &lt;/ul&gt;
     In other words, if viewing the origin of the Android coordinate system from the positive
     Z direction, the device coordinate frame is to be rotated 90° counter-clockwise about the
     Z axis to align with the sensor's local coordinate frame. Equivalently, a vector in the
     Android coordinate frame may be multiplied with R to rotate it 90° clockwise (270°
     counter-clockwise), yielding its representation in the sensor's coordinate frame.
     Relative to the origin of the Android coordinate system, the physical center of the
     sensor is located 10mm in the positive Y direction, and 2.5mm in the negative Z
     direction.
 &lt;/p&gt;
*/
TYPE_SENSOR_PLACEMENT : &quot;65539&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_SAMPLING'>/** Sampling parameter. Describes the raw sample period and estimated jitter of sample time in
</span> terms of standard deviation.

 Payload:
     floatValues[0]: raw sample period in seconds.
     floatValues[1]: standard deviation of sampling period.
*/
TYPE_SAMPLING : &quot;65540&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_LOCAL_GEOMAGNETIC_FIELD'>/** Local geo-magnetic Field.
</span>
 Additional into to sensor hardware.  Local geomagnetic field information based on
 device geo location. This type is primarily for for magnetic field calibration and rotation
 vector sensor fusion.

 float[3]: strength (uT), declination and inclination angle (rad).
 @hide
*/
TYPE_LOCAL_GEOMAGNETIC_FIELD : &quot;196608&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_LOCAL_GRAVITY'>/** Local gravity acceleration strength.
</span>
 Additional info to sensor hardware for accelerometer calibration.

 float: gravitational acceleration norm in m/s^2.
 @hide
*/
TYPE_LOCAL_GRAVITY : &quot;196609&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_DOCK_STATE'>/** Device dock state.
</span>
 Additional info to sensor hardware indicating dock states of device.

 int32_t: dock state following definition of {@link android.content.Intent#EXTRA_DOCK_STATE}.
          Undefined values are ignored.
 @hide
*/
TYPE_DOCK_STATE : &quot;196610&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_HIGH_PERFORMANCE_MODE'>/** High performance mode.
</span>
 Additional info to sensor hardware. Device is able to use up more power and take more
 resources to improve throughput and latency in high performance mode. One possible use case
 is virtual reality, when sensor latency need to be carefully controlled.

 int32_t: 1 or 0, denoting device is in or out of high performance mode, respectively.
          Other values are ignored.
 @hide
*/
TYPE_HIGH_PERFORMANCE_MODE : &quot;196611&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_MAGNETIC_FIELD_CALIBRATION'>/** Magnetic field calibration hint.
</span>
 Additional info to sensor hardware. Device is notified when manually triggered magnetic field
 calibration procedure is started or stopped. The calibration procedure is assumed timed out
 after 1 minute from start, even if an explicit stop is not received.

 int32_t: 1 for calibration start, 0 for stop, other values are ignored.
 @hide
*/
TYPE_MAGNETIC_FIELD_CALIBRATION : &quot;196612&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_CUSTOM_INFO'>/** Custom sensor info: array of float values interpreted by sensor based on the type
</span> Any type between TYPE_CUSTOM_INFO &lt;= info_type &lt; TYPE_DEBUG_INFO may be
 used to send custom sensor info.
 @hide
*/
TYPE_CUSTOM_INFO : &quot;268435456&quot;,
<span id='android-hardware-SensorAdditionalInfo-property-TYPE_DEBUG_INFO'>/**@hide */
</span>TYPE_DEBUG_INFO : &quot;1073741824&quot;,
<span id='android-hardware-SensorAdditionalInfo-method-createLocalGeomagneticField'>/**
</span>@hide 
*/
createLocalGeomagneticField : function(  ) {},

<span id='android-hardware-SensorAdditionalInfo-method-createCustomInfo'>/**
</span>@hide 
*/
createCustomInfo : function(  ) {},


};</pre>
</body>
</html>
