Ext.data.JsonP.android_hardware_SensorEvent({"tagname":"class","name":"android.hardware.SensorEvent","autodetected":{},"files":[{"filename":"SensorEvent.js","href":"SensorEvent.html#android-hardware-SensorEvent"}],"extends":"java.lang.Object","members":[{"name":"accuracy","tagname":"property","owner":"android.hardware.SensorEvent","id":"property-accuracy","meta":{}},{"name":"sensor","tagname":"property","owner":"android.hardware.SensorEvent","id":"property-sensor","meta":{}},{"name":"timestamp","tagname":"property","owner":"android.hardware.SensorEvent","id":"property-timestamp","meta":{}},{"name":"values","tagname":"property","owner":"android.hardware.SensorEvent","id":"property-values","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-android.hardware.SensorEvent","short_doc":"This class represents a Sensor event and\n holds information such as the sensor's type, the time-stamp, accuracy and o...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>android.hardware.SensorEvent</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/SensorEvent.html#android-hardware-SensorEvent' target='_blank'>SensorEvent.js</a></div></pre><div class='doc-contents'><p>This class represents a <a href=\"#!/api/android.hardware.Sensor\" rel=\"android.hardware.Sensor\" class=\"docClass\">Sensor</a> event and\n holds information such as the sensor's type, the time-stamp, accuracy and of\n course the sensor's <a href=\"#!/api/android.hardware.SensorEvent-property-values\" rel=\"android.hardware.SensorEvent-property-values\" class=\"docClass\">data</a>.</p>\n\n<p> <p>\n <u>Definition of the coordinate system used by the SensorEvent API.</u>\n </p></p>\n\n<p> <p>\n The coordinate-system is defined relative to the screen of the phone in its\n default orientation. The axes are not swapped when the device's screen\n orientation changes.\n </p></p>\n\n<p> <p>\n The X axis is horizontal and points to the right, the Y axis is vertical and\n points up and the Z axis points towards the outside of the front face of the\n screen. In this system, coordinates behind the screen have negative Z values.\n </p></p>\n\n<p> <p>\n <center><img src=\"../../../images/axis_device.png\"\n alt=\"Sensors coordinate-system diagram.\" border=\"0\" /></center>\n </p></p>\n\n<p> <p>\n <b>Note:</b> This coordinate system is different from the one used in the\n Android 2D APIs where the origin is in the top-left corner.\n </p></p>\n\n<p> @see SensorManager\n @see SensorEvent\n @see Sensor</p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-accuracy' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.hardware.SensorEvent'>android.hardware.SensorEvent</span><br/><a href='source/SensorEvent.html#android-hardware-SensorEvent-property-accuracy' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.hardware.SensorEvent-property-accuracy' class='name expandable'>accuracy</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The accuracy of this event. ...</div><div class='long'><p>The accuracy of this event. See <a href=\"#!/api/android.hardware.SensorManager\" rel=\"android.hardware.SensorManager\" class=\"docClass\">SensorManager</a> for details.</p>\n<p>Defaults to: <code>&quot;null&quot;</code></p></div></div></div><div id='property-sensor' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.hardware.SensorEvent'>android.hardware.SensorEvent</span><br/><a href='source/SensorEvent.html#android-hardware-SensorEvent-property-sensor' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.hardware.SensorEvent-property-sensor' class='name expandable'>sensor</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The sensor that generated this event. ...</div><div class='long'><p>The sensor that generated this event. See\n<a href=\"#!/api/android.hardware.SensorManager\" rel=\"android.hardware.SensorManager\" class=\"docClass\">SensorManager</a> for details.</p>\n<p>Defaults to: <code>&quot;null&quot;</code></p></div></div></div><div id='property-timestamp' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.hardware.SensorEvent'>android.hardware.SensorEvent</span><br/><a href='source/SensorEvent.html#android-hardware-SensorEvent-property-timestamp' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.hardware.SensorEvent-property-timestamp' class='name expandable'>timestamp</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The time in nanosecond at which the event happened ...</div><div class='long'><p>The time in nanosecond at which the event happened</p>\n<p>Defaults to: <code>&quot;null&quot;</code></p></div></div></div><div id='property-values' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.hardware.SensorEvent'>android.hardware.SensorEvent</span><br/><a href='source/SensorEvent.html#android-hardware-SensorEvent-property-values' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.hardware.SensorEvent-property-values' class='name expandable'>values</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The length and contents of the values array depends on\nwhich sensor type is being monitored (see\nalso android.hardwar...</div><div class='long'><p>\nThe length and contents of the <a href=\"#!/api/android.hardware.SensorEvent-property-values\" rel=\"android.hardware.SensorEvent-property-values\" class=\"docClass\">values</a> array depends on\nwhich <a href=\"#!/api/android.hardware.Sensor\" rel=\"android.hardware.Sensor\" class=\"docClass\">sensor</a> type is being monitored (see\nalso <a href=\"#!/api/android.hardware.SensorEvent\" rel=\"android.hardware.SensorEvent\" class=\"docClass\">android.hardware.SensorEvent</a> for a definition of the coordinate system used).\n</p>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_ACCELEROMETER\" rel=\"android.hardware.Sensor-property-TYPE_ACCELEROMETER\" class=\"docClass\">Sensor.TYPE_ACCELEROMETER</a>:</h4>\n\n\n<p> All values are in SI units (m/s<sup>2</sup>)</p>\n\n<ul>\n<li> values[0]: Acceleration minus Gx on the x-axis </li>\n<li> values[1]: Acceleration minus Gy on the y-axis </li>\n<li> values[2]: Acceleration minus Gz on the z-axis </li>\n</ul>\n\n\n\n\n<p>\nA sensor of this type measures the acceleration applied to the device\n(<b>Ad</b>). Conceptually, it does so by measuring forces applied to the\nsensor itself (<b>Fs</b>) using the relation:\n</p>\n\n\n<p><b><center>Ad = - &#8721;Fs / mass</center></b></p>\n\n<p>\nIn particular, the force of gravity is always influencing the measured\nacceleration:\n</p>\n\n\n<p><b><center>Ad = -g - &#8721;F / mass</center></b></p>\n\n<p>\nFor this reason, when the device is sitting on a table (and obviously not\naccelerating), the accelerometer reads a magnitude of <b>g</b> = 9.81\nm/s^2\n</p>\n\n\n\n\n<p>\nSimilarly, when the device is in free-fall and therefore dangerously\naccelerating towards to ground at 9.81 m/s^2, its accelerometer reads a\nmagnitude of 0 m/s^2.\n</p>\n\n\n\n\n<p>\nIt should be apparent that in order to measure the real acceleration of\nthe device, the contribution of the force of gravity must be eliminated.\nThis can be achieved by applying a <i>high-pass</i> filter. Conversely, a\n<i>low-pass</i> filter can be used to isolate the force of gravity.\n</p>\n\n\n\n\n<pre class=\"prettyprint\">\n\n    public void onSensorChanged(SensorEvent event)\n    {\n         // alpha is calculated as t / (t + dT)\n         // with t, the low-pass filter's time-constant\n         // and dT, the event delivery rate\n\n         final float alpha = 0.8;\n\n         gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];\n         gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];\n         gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];\n\n         linear_acceleration[0] = event.values[0] - gravity[0];\n         linear_acceleration[1] = event.values[1] - gravity[1];\n         linear_acceleration[2] = event.values[2] - gravity[2];\n    }\n</pre>\n\n\n\n\n<p>\n<u>Examples</u>:\n<ul>\n<li>When the device lies flat on a table and is pushed on its left side\ntoward the right, the x acceleration value is positive.</li>\n\n<li>When the device lies flat on a table, the acceleration value is\n+9.81, which correspond to the acceleration of the device (0 m/s^2) minus\nthe force of gravity (-9.81 m/s^2).</li>\n\n<li>When the device lies flat on a table and is pushed toward the sky\nwith an acceleration of A m/s^2, the acceleration value is equal to\nA+9.81 which correspond to the acceleration of the device (+A m/s^2)\nminus the force of gravity (-9.81 m/s^2).</li>\n</ul>\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_MAGNETIC_FIELD\" rel=\"android.hardware.Sensor-property-TYPE_MAGNETIC_FIELD\" class=\"docClass\">Sensor.TYPE_MAGNETIC_FIELD</a>:</h4>\nAll values are in micro-Tesla (uT) and measure the ambient magnetic field\nin the X, Y and Z axis.\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_GYROSCOPE\" rel=\"android.hardware.Sensor-property-TYPE_GYROSCOPE\" class=\"docClass\">Sensor.TYPE_GYROSCOPE</a>:\n</h4> All values are in radians/second and measure the rate of rotation\naround the device's local X, Y and Z axis. The coordinate system is the\nsame as is used for the acceleration sensor. Rotation is positive in the\ncounter-clockwise direction. That is, an observer looking from some\npositive location on the x, y or z axis at a device positioned on the\norigin would report positive rotation if the device appeared to be\nrotating counter clockwise. Note that this is the standard mathematical\ndefinition of positive rotation and does not agree with the definition of\nroll given earlier.\n<ul>\n<li> values[0]: Angular speed around the x-axis </li>\n<li> values[1]: Angular speed around the y-axis </li>\n<li> values[2]: Angular speed around the z-axis </li>\n</ul>\n<p>\nTypically the output of the gyroscope is integrated over time to\ncalculate a rotation describing the change of angles over the time step,\nfor example:\n</p>\n\n<pre class=\"prettyprint\">\n    private static final float NS2S = 1.0f / 1000000000.0f;\n    private final float[] deltaRotationVector = new float[4]();\n    private float timestamp;\n\n    public void onSensorChanged(SensorEvent event) {\n         // This time step's delta rotation to be multiplied by the current rotation\n         // after computing it from the gyro sample data.\n         if (timestamp != 0) {\n             final float dT = (event.timestamp - timestamp) * NS2S;\n             // Axis of the rotation sample, not normalized yet.\n             float axisX = event.values[0];\n             float axisY = event.values[1];\n             float axisZ = event.values[2];\n\n             // Calculate the angular speed of the sample\n             float omegaMagnitude = sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);\n\n             // Normalize the rotation vector if it's big enough to get the axis\n             if (omegaMagnitude > EPSILON) {\n                 axisX /= omegaMagnitude;\n                 axisY /= omegaMagnitude;\n                 axisZ /= omegaMagnitude;\n             }\n\n             // Integrate around this axis with the angular speed by the time step\n             // in order to get a delta rotation from this sample over the time step\n             // We will convert this axis-angle representation of the delta rotation\n             // into a quaternion before turning it into the rotation matrix.\n             float thetaOverTwo = omegaMagnitude * dT / 2.0f;\n             float sinThetaOverTwo = sin(thetaOverTwo);\n             float cosThetaOverTwo = cos(thetaOverTwo);\n             deltaRotationVector[0] = sinThetaOverTwo * axisX;\n             deltaRotationVector[1] = sinThetaOverTwo * axisY;\n             deltaRotationVector[2] = sinThetaOverTwo * axisZ;\n             deltaRotationVector[3] = cosThetaOverTwo;\n         }\n         timestamp = event.timestamp;\n         float[] deltaRotationMatrix = new float[9];\n         SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);\n         // User code should concatenate the delta rotation we computed with the current\n         // rotation in order to get the updated rotation.\n         // rotationCurrent = rotationCurrent * deltaRotationMatrix;\n    }\n</pre>\n<p>\nIn practice, the gyroscope noise and offset will introduce some errors\nwhich need to be compensated for. This is usually done using the\ninformation from other sensors, but is beyond the scope of this document.\n</p>\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_LIGHT\" rel=\"android.hardware.Sensor-property-TYPE_LIGHT\" class=\"docClass\">Sensor.TYPE_LIGHT</a>:</h4>\n<ul>\n<li>values[0]: Ambient light level in SI lux units </li>\n</ul>\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_PRESSURE\" rel=\"android.hardware.Sensor-property-TYPE_PRESSURE\" class=\"docClass\">Sensor.TYPE_PRESSURE</a>:</h4>\n<ul>\n<li>values[0]: Atmospheric pressure in hPa (millibar) </li>\n</ul>\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_PROXIMITY\" rel=\"android.hardware.Sensor-property-TYPE_PROXIMITY\" class=\"docClass\">Sensor.TYPE_PROXIMITY</a>:\n</h4>\n\n<ul>\n<li>values[0]: Proximity sensor distance measured in centimeters </li>\n</ul>\n\n<p>\n<b>Note:</b> Some proximity sensors only support a binary <i>near</i> or\n<i>far</i> measurement. In this case, the sensor should report its\nmaximum range value in\nthe <i>far</i> state and a lesser value in the <i>near</i> state.\n</p>\n\n <h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_GRAVITY\" rel=\"android.hardware.Sensor-property-TYPE_GRAVITY\" class=\"docClass\">Sensor.TYPE_GRAVITY</a>:</h4>\n <p>A three dimensional vector indicating the direction and magnitude of gravity.  Units\n are m/s^2. The coordinate system is the same as is used by the acceleration sensor.</p>\n <p><b>Note:</b> When the device is at rest, the output of the gravity sensor should be\n identical to that of the accelerometer.</p>\n\n <h4>\n <a href=\"#!/api/android.hardware.Sensor-property-TYPE_LINEAR_ACCELERATION\" rel=\"android.hardware.Sensor-property-TYPE_LINEAR_ACCELERATION\" class=\"docClass\">Sensor.TYPE_LINEAR_ACCELERATION</a>:\n </h4> A three dimensional vector indicating acceleration along each device axis, not\n including gravity. All values have units of m/s^2.  The coordinate system is the same as is\n used by the acceleration sensor.\n <p>The output of the accelerometer, gravity and  linear-acceleration sensors must obey the\n following relation:</p>\n <p><ul>acceleration = gravity + linear-acceleration</ul></p>\n\n <h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" rel=\"android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" class=\"docClass\">Sensor.TYPE_ROTATION_VECTOR</a>:</h4>\n <p>The rotation vector represents the orientation of the device as a combination of an\n <i>angle</i> and an <i>axis</i>, in which the device has rotated through an angle &#952\n around an axis &lt;x, y, z>.</p>\n <p>The three elements of the rotation vector are\n &lt;x*sin(&#952/2), y*sin(&#952/2), z*sin(&#952/2)>, such that the magnitude of the rotation\n vector is equal to sin(&#952/2), and the direction of the rotation vector is equal to the\n direction of the axis of rotation.</p>\n </p>\n\n\n<p>The three elements of the rotation vector are equal to\n the last three components of a <b>unit</b> quaternion\n &lt;cos(&amp;#952/2), x<em>sin(&amp;#952/2), y</em>sin(&amp;#952/2), z*sin(&amp;#952/2)>.</p>\n <p>Elements of the rotation vector are unitless.\n The x,y, and z axis are defined in the same way as the acceleration\n sensor.</p>\n The reference coordinate system is defined as a direct orthonormal basis,\n where:\n\n\n<ul>\n<li>X is defined as the vector product <b>Y.Z</b> (It is tangential to\nthe ground at the device's current location and roughly points East).</li>\n<li>Y is tangential to the ground at the device's current location and\npoints towards magnetic north.</li>\n<li>Z points towards the sky and is perpendicular to the ground.</li>\n</ul>\n\n\n\n\n<p>\n<center><img src=\"../../../images/axis_globe.png\"\nalt=\"World coordinate-system diagram.\" border=\"0\" /></center>\n</p>\n\n\n\n\n<ul>\n<li> values[0]: x*sin(&#952/2) </li>\n<li> values[1]: y*sin(&#952/2) </li>\n<li> values[2]: z*sin(&#952/2) </li>\n<li> values[3]: cos(&#952/2) </li>\n<li> values[4]: estimated heading Accuracy (in radians) (-1 if unavailable)</li>\n</ul>\n\n\n<p> values[3], originally optional, will always be present from SDK Level 18 onwards.\nvalues[4] is a new value that has been added in SDK Level 18.\n</p>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_ORIENTATION\" rel=\"android.hardware.Sensor-property-TYPE_ORIENTATION\" class=\"docClass\">Sensor.TYPE_ORIENTATION</a>:</h4>\n\n\n<p> All values are angles in degrees.</p>\n\n<ul>\n<li> values[0]: Azimuth, angle between the magnetic north direction and the\ny-axis, around the z-axis (0 to 359). 0=North, 90=East, 180=South,\n270=West\n\n\n<p>\nvalues[1]: Pitch, rotation around x-axis (-180 to 180), with positive\nvalues when the z-axis moves <b>toward</b> the y-axis.\n</p>\n\n<p>\nvalues[2]: Roll, rotation around the y-axis (-90 to 90)\nincreasing as the device moves clockwise.\n</p>\n</li></ul>\n\n\n\n\n<p>\n<b>Note:</b> This definition is different from <b>yaw, pitch and roll</b>\nused in aviation where the X axis is along the long side of the plane\n(tail to nose).\n</p>\n\n\n\n\n<p>\n<b>Note:</b> This sensor type exists for legacy reasons, please use\n<a href=\"#!/api/android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" rel=\"android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" class=\"docClass\">rotation vector sensor type</a> and\n<a href=\"#!/api/android.hardware.SensorManager-method-getRotationMatrix\" rel=\"android.hardware.SensorManager-method-getRotationMatrix\" class=\"docClass\">getRotationMatrix()</a> in conjunction with\n<a href=\"#!/api/android.hardware.SensorManager-method-remapCoordinateSystem\" rel=\"android.hardware.SensorManager-method-remapCoordinateSystem\" class=\"docClass\">remapCoordinateSystem()</a> and\n<a href=\"#!/api/android.hardware.SensorManager-method-getOrientation\" rel=\"android.hardware.SensorManager-method-getOrientation\" class=\"docClass\">getOrientation()</a> to\ncompute these values instead.\n</p>\n\n\n\n\n<p>\n<b>Important note:</b> For historical reasons the roll angle is positive\nin the clockwise direction (mathematically speaking, it should be\npositive in the counter-clockwise direction).\n</p>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_RELATIVE_HUMIDITY\" rel=\"android.hardware.Sensor-property-TYPE_RELATIVE_HUMIDITY\" class=\"docClass\">Sensor.TYPE_RELATIVE_HUMIDITY</a>:</h4>\n\n\n<ul>\n<li> values[0]: Relative ambient air humidity in percent </li>\n</ul>\n\n\n<p>\nWhen relative ambient air humidity and ambient temperature are\nmeasured, the dew point and absolute humidity can be calculated.\n</p>\n\n\n<p><u>Dew Point</u></p>\n\n<p>\nThe dew point is the temperature to which a given parcel of air must be\ncooled, at constant barometric pressure, for water vapor to condense\ninto water.\n</p>\n\n\n<center>\n<pre>                   ln(RH/100%) + m&#183;t/(T<sub>n</sub>+t)\nt<sub>d</sub>(t,RH) = T<sub>n</sub> &#183; ------------------------------\n                m - [ln(RH/100%) + m&#183;t/(T<sub>n</sub>+t)]\n</pre></center>\n\n\n<dl>\n<dt>t<sub>d</sub></dt> <dd>dew point temperature in &deg;C</dd>\n<dt>t</dt>             <dd>actual temperature in &deg;C</dd>\n<dt>RH</dt>            <dd>actual relative humidity in %</dd>\n<dt>m</dt>             <dd>17.62</dd>\n<dt>T<sub>n</sub></dt> <dd>243.12 &deg;C</dd>\n</dl>\n\n\n<p>for example:</p>\n\n\n<pre class=\"prettyprint\">\nh = Math.log(rh / 100.0) + (17.62 * t) / (243.12 + t);\ntd = 243.12 * h / (17.62 - h);\n</pre>\n\n\n<p><u>Absolute Humidity</u></p>\n\n<p>\nThe absolute humidity is the mass of water vapor in a particular volume\nof dry air. The unit is g/m<sup>3</sup>.\n</p>\n\n\n<center>\n<pre>                   RH/100%&#183;A&#183;exp(m&#183;t/(T<sub>n</sub>+t))\nd<sub>v</sub>(t,RH) = 216.7 &#183; -------------------------\n                          273.15 + t\n</pre></center>\n\n\n<dl>\n<dt>d<sub>v</sub></dt> <dd>absolute humidity in g/m<sup>3</sup></dd>\n<dt>t</dt>             <dd>actual temperature in &deg;C</dd>\n<dt>RH</dt>            <dd>actual relative humidity in %</dd>\n<dt>m</dt>             <dd>17.62</dd>\n<dt>T<sub>n</sub></dt> <dd>243.12 &deg;C</dd>\n<dt>A</dt>             <dd>6.112 hPa</dd>\n</dl>\n\n\n<p>for example:</p>\n\n\n<pre class=\"prettyprint\">\ndv = 216.7 *\n(rh / 100.0 * 6.112 * Math.exp(17.62 * t / (243.12 + t)) / (273.15 + t));\n</pre>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_AMBIENT_TEMPERATURE\" rel=\"android.hardware.Sensor-property-TYPE_AMBIENT_TEMPERATURE\" class=\"docClass\">Sensor.TYPE_AMBIENT_TEMPERATURE</a>:\n</h4>\n\n\n\n\n<ul>\n<li> values[0]: ambient (room) temperature in degree Celsius.</li>\n</ul>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_MAGNETIC_FIELD_UNCALIBRATED\" rel=\"android.hardware.Sensor-property-TYPE_MAGNETIC_FIELD_UNCALIBRATED\" class=\"docClass\">Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED</a>:</h4>\n\n\n<p>Similar to <a href=\"#!/api/android.hardware.Sensor-property-TYPE_MAGNETIC_FIELD\" rel=\"android.hardware.Sensor-property-TYPE_MAGNETIC_FIELD\" class=\"docClass\">android.hardware.Sensor.TYPE_MAGNETIC_FIELD</a>,\nbut the hard iron calibration is reported separately instead of being included\nin the measurement. Factory calibration and temperature compensation will still\nbe applied to the \"uncalibrated\" measurement. Assumptions that the magnetic field\nis due to the Earth's poles is avoided.</p>\n\n<p>\nThe values array is shown below:\n<ul>\n<li> values[0] = x_uncalib </li>\n<li> values[1] = y_uncalib </li>\n<li> values[2] = z_uncalib </li>\n<li> values[3] = x_bias </li>\n<li> values[4] = y_bias </li>\n<li> values[5] = z_bias </li>\n</ul>\n</p>\n\n\n<p>\nx_uncalib, y_uncalib, z_uncalib are the measured magnetic field in X, Y, Z axes.\nSoft iron and temperature calibrations are applied. But the hard iron\ncalibration is not applied. The values are in micro-Tesla (uT).\n</p>\n\n\n<p>\nx_bias, y_bias, z_bias give the iron bias estimated in X, Y, Z axes.\nEach field is a component of the estimated hard iron calibration.\nThe values are in micro-Tesla (uT).\n</p>\n\n\n<p> Hard iron - These distortions arise due to the magnetized iron, steel or permanent\nmagnets on the device.\nSoft iron - These distortions arise due to the interaction with the earth's magnetic\nfield.\n</p>\n\n\n<h4> <a href=\"#!/api/android.hardware.Sensor-property-TYPE_GAME_ROTATION_VECTOR\" rel=\"android.hardware.Sensor-property-TYPE_GAME_ROTATION_VECTOR\" class=\"docClass\">Sensor.TYPE_GAME_ROTATION_VECTOR</a>:</h4>\n\n\n<p>Identical to <a href=\"#!/api/android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" rel=\"android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" class=\"docClass\">android.hardware.Sensor.TYPE_ROTATION_VECTOR</a> except that it\ndoesn't use the geomagnetic field. Therefore the Y axis doesn't\npoint north, but instead to some other reference, that reference is\nallowed to drift by the same order of magnitude as the gyroscope\ndrift around the Z axis.</p>\n\n<p>\nIn the ideal case, a phone rotated and returning to the same real-world\norientation will report the same game rotation vector\n(without using the earth's geomagnetic field). However, the orientation\nmay drift somewhat over time. See <a href=\"#!/api/android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" rel=\"android.hardware.Sensor-property-TYPE_ROTATION_VECTOR\" class=\"docClass\">android.hardware.Sensor.TYPE_ROTATION_VECTOR</a>\nfor a detailed description of the values. This sensor will not have\nthe estimated heading accuracy value.\n</p>\n\n\n\n\n<h4> <a href=\"#!/api/android.hardware.Sensor-property-TYPE_GYROSCOPE_UNCALIBRATED\" rel=\"android.hardware.Sensor-property-TYPE_GYROSCOPE_UNCALIBRATED\" class=\"docClass\">Sensor.TYPE_GYROSCOPE_UNCALIBRATED</a>:</h4>\n\n\n<p>All values are in radians/second and measure the rate of rotation\naround the X, Y and Z axis. An estimation of the drift on each axis is\nreported as well.</p>\n\n<p>\nNo gyro-drift compensation is performed. Factory calibration and temperature\ncompensation is still applied to the rate of rotation (angular speeds).\n</p>\n\n\n<p>\nThe coordinate system is the same as is used for the\n<a href=\"#!/api/android.hardware.Sensor-property-TYPE_ACCELEROMETER\" rel=\"android.hardware.Sensor-property-TYPE_ACCELEROMETER\" class=\"docClass\">android.hardware.Sensor.TYPE_ACCELEROMETER</a>\nRotation is positive in the counter-clockwise direction (right-hand rule).\nThat is, an observer looking from some positive location on the x, y or z axis\nat a device positioned on the origin would report positive rotation if the device\nappeared to be rotating counter clockwise.\nThe range would at least be 17.45 rad/s (ie: ~1000 deg/s).\n<ul>\n<li> values[0] : angular speed (w/o drift compensation) around the X axis in rad/s </li>\n<li> values[1] : angular speed (w/o drift compensation) around the Y axis in rad/s </li>\n<li> values[2] : angular speed (w/o drift compensation) around the Z axis in rad/s </li>\n<li> values[3] : estimated drift around X axis in rad/s </li>\n<li> values[4] : estimated drift around Y axis in rad/s </li>\n<li> values[5] : estimated drift around Z axis in rad/s </li>\n</ul>\n</p>\n\n\n<p><b>Pro Tip:</b> Always use the length of the values array while performing operations\non it. In earlier versions, this used to be always 3 which has changed now. </p>\n\n\n<p>  <h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_POSE_6DOF\" rel=\"android.hardware.Sensor-property-TYPE_POSE_6DOF\" class=\"docClass\">Sensor.TYPE_POSE_6DOF</a>:</h4></p>\n\n<p>A TYPE_POSE_6DOF event consists of a rotation expressed as a quaternion and a translation\nexpressed in SI units. The event also contains a delta rotation and translation that show\nhow the device?s pose has changed since the previous sequence numbered pose.\nThe event uses the cannonical Android Sensor axes.</p>\n\n<ul>\n<li> values[0]: x*sin(&#952/2) </li>\n<li> values[1]: y*sin(&#952/2) </li>\n<li> values[2]: z*sin(&#952/2) </li>\n<li> values[3]: cos(&#952/2)   </li>\n\n\n<li> values[4]: Translation along x axis from an arbitrary origin. </li>\n<li> values[5]: Translation along y axis from an arbitrary origin. </li>\n<li> values[6]: Translation along z axis from an arbitrary origin. </li>\n\n<li> values[7]:  Delta quaternion rotation x*sin(&#952/2) </li>\n<li> values[8]:  Delta quaternion rotation y*sin(&#952/2) </li>\n<li> values[9]:  Delta quaternion rotation z*sin(&#952/2) </li>\n<li> values[10]: Delta quaternion rotation cos(&#952/2) </li>\n\n<li> values[11]: Delta translation along x axis. </li>\n<li> values[12]: Delta translation along y axis. </li>\n<li> values[13]: Delta translation along z axis. </li>\n\n<li> values[14]: Sequence number </li>\n\n</ul>\n\n\n<p>  <h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_STATIONARY_DETECT\" rel=\"android.hardware.Sensor-property-TYPE_STATIONARY_DETECT\" class=\"docClass\">Sensor.TYPE_STATIONARY_DETECT</a>:</h4></p>\n\n<p>A TYPE_STATIONARY_DETECT event is produced if the device has been\nstationary for at least 5 seconds with a maximal latency of 5\nadditional seconds. ie: it may take up anywhere from 5 to 10 seconds\nafte the device has been at rest to trigger this event.</p>\n\n<p>The only allowed value is 1.0.</p>\n\n<ul>\n <li> values[0]: 1.0 </li>\n</ul>\n\n\n<p>  <h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_MOTION_DETECT\" rel=\"android.hardware.Sensor-property-TYPE_MOTION_DETECT\" class=\"docClass\">Sensor.TYPE_MOTION_DETECT</a>:</h4></p>\n\n<p>A TYPE_MOTION_DETECT event is produced if the device has been in\nmotion  for at least 5 seconds with a maximal latency of 5\nadditional seconds. ie: it may take up anywhere from 5 to 10 seconds\nafte the device has been at rest to trigger this event.</p>\n\n<p>The only allowed value is 1.0.</p>\n\n<ul>\n <li> values[0]: 1.0 </li>\n</ul>\n\n\n<p>  <h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_HEART_BEAT\" rel=\"android.hardware.Sensor-property-TYPE_HEART_BEAT\" class=\"docClass\">Sensor.TYPE_HEART_BEAT</a>:</h4></p>\n\n<p>A sensor of this type returns an event everytime a hear beat peak is\ndetected.</p>\n\n<p>Peak here ideally corresponds to the positive peak in the QRS complex of\nan ECG signal.</p>\n\n<ul>\n <li> values[0]: confidence</li>\n</ul>\n\n\n\n\n<p>\nA confidence value of 0.0 indicates complete uncertainty - that a peak\nis as likely to be at the indicated timestamp as anywhere else.\nA confidence value of 1.0 indicates complete certainly - that a peak is\ncompletely unlikely to be anywhere else on the QRS complex.\n</p>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_LOW_LATENCY_OFFBODY_DETECT\" rel=\"android.hardware.Sensor-property-TYPE_LOW_LATENCY_OFFBODY_DETECT\" class=\"docClass\">Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT</a>:</h4>\n\n\n\n\n<p>\nA sensor of this type returns an event every time the device transitions\nfrom off-body to on-body and from on-body to off-body (e.g. a wearable\ndevice being removed from the wrist would trigger an event indicating an\noff-body transition). The event returned will contain a single value to\nindicate off-body state:\n</p>\n\n\n\n\n<ul>\n <li> values[0]: off-body state</li>\n</ul>\n\n\n\n\n<p>\n    Valid values for off-body state:\n<ul>\n <li> 1.0 (device is on-body)</li>\n <li> 0.0 (device is off-body)</li>\n</ul>\n</p>\n\n\n\n\n<p>\nWhen a sensor of this type is activated, it must deliver the initial\non-body or off-body event representing the current device state within\n5 seconds of activating the sensor.\n</p>\n\n\n\n\n<p>\nThis sensor must be able to detect and report an on-body to off-body\ntransition within 1 second of the device being removed from the body,\nand must be able to detect and report an off-body to on-body transition\nwithin 5 seconds of the device being put back onto the body.\n</p>\n\n\n\n\n<h4><a href=\"#!/api/android.hardware.Sensor-property-TYPE_ACCELEROMETER_UNCALIBRATED\" rel=\"android.hardware.Sensor-property-TYPE_ACCELEROMETER_UNCALIBRATED\" class=\"docClass\">Sensor.TYPE_ACCELEROMETER_UNCALIBRATED</a>:</h4>\n\n\n<p> All values are in SI\nunits (m/s<sup>2</sup>)</p>\n\n<p>Similar to <a href=\"#!/api/android.hardware.Sensor-property-TYPE_ACCELEROMETER\" rel=\"android.hardware.Sensor-property-TYPE_ACCELEROMETER\" class=\"docClass\">android.hardware.Sensor.TYPE_ACCELEROMETER</a>,\nFactory calibration and temperature compensation will still be applied\nto the \"uncalibrated\" measurement.</p>\n\n<p>\nThe values array is shown below:\n<ul>\n<li> values[0] = x_uncalib without bias compensation </li>\n<li> values[1] = y_uncalib without bias compensation </li>\n<li> values[2] = z_uncalib without bias compensation </li>\n<li> values[3] = estimated x_bias </li>\n<li> values[4] = estimated y_bias </li>\n<li> values[5] = estimated z_bias </li>\n</ul>\n</p>\n\n\n<p>\nx_uncalib, y_uncalib, z_uncalib are the measured acceleration in X, Y, Z\naxes similar to the  <a href=\"#!/api/android.hardware.Sensor-property-TYPE_ACCELEROMETER\" rel=\"android.hardware.Sensor-property-TYPE_ACCELEROMETER\" class=\"docClass\">android.hardware.Sensor.TYPE_ACCELEROMETER</a>,\nwithout any bias correction (factory bias compensation and any\ntemperature compensation is allowed).\nx_bias, y_bias, z_bias are the estimated biases.\n</p>\n\n\n<p>@see GeomagneticField</p>\n<p>Defaults to: <code>&quot;null&quot;</code></p></div></div></div></div></div></div></div>","meta":{}});