<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-opengl-GLSurfaceView-GLWrapper'>/**@class android.opengl.GLSurfaceView.GLWrapper
</span> An interface used to wrap a GL interface.
 &lt;p&gt;Typically
 used for implementing debugging and tracing on top of the default
 GL interface. You would typically use this by creating your own class
 that implemented all the GL methods by delegating to another GL instance.
 Then you could add your own behavior before or after calling the
 delegate. All the GLWrapper would do was instantiate and return the
 wrapper GL instance:
 &lt;pre class=&quot;prettyprint&quot;&gt;
 class MyGLWrapper implements GLWrapper {
     GL wrap(GL gl) {
         return new MyGLImplementation(gl);
     }
     static class MyGLImplementation implements GL,GL10,GL11,... {
         ...
     }
 }
 &lt;/pre&gt;
 @see #setGLWrapper(GLWrapper)
*/
var GLWrapper = {

<span id='android-opengl-GLSurfaceView-GLWrapper-method-wrap'>/**Wraps a gl interface in another gl interface.
</span>@param {Object {GL}} gl a GL interface that is to be wrapped.
@return {Object {javax.microedition.khronos.opengles.GL}} either the input argument or another GL object that wraps the input argument.
*/
wrap : function(  ) {},


};</pre>
</body>
</html>
