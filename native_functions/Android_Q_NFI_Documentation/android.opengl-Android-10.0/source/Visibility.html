<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-opengl-Visibility'>/**@class android.opengl.Visibility
</span>@extends java.lang.Object

 A collection of utility methods for computing the visibility of triangle
 meshes.

*/
var Visibility = {

<span id='android-opengl-Visibility-method-visibilityTest'>/**Test whether a given triangle mesh is visible on the screen. The mesh
</span> is specified as an indexed triangle list.
@param {Object {float[]}} ws the world space to screen space transform matrix, as an OpenGL
 column matrix.
@param {Number} wsOffset an index into the ws array where the data starts.
@param {Object {float[]}} positions the vertex positions (x, y, z).
@param {Number} positionsOffset the index in the positions array where the data
        starts.
@param {Object {char[]}} indices the indices of the triangle list. The indices are
 expressed as chars because they are unsigned 16-bit values.
@param {Number} indicesOffset the index in the indices array where the index data
        starts.
@param {Number} indexCount the number of indices in use. Typically a multiple of
 three. If not a multiple of three, the remaining one or two indices will
 be ignored.
@return {Number} 2 if all of the mesh is visible, 1 if some part of the mesh is
         visible, 0 if no part is visible.
@throws IllegalArgumentException if ws is null, wsOffset &lt; 0,
 positions is null, positionsOffset &lt; 0, indices is null,
 indicesOffset &lt; 0, indicesOffset &gt; indices.length - indexCount
*/
visibilityTest : function(  ) {},

<span id='android-opengl-Visibility-method-frustumCullSpheres'>/**Given an OpenGL ES ModelView-Projection matrix (which implicitly
</span> describes a frustum) and a list of spheres, determine which spheres
 intersect the frustum.
 &lt;p&gt;
 A ModelView-Projection matrix can be computed by multiplying the
 a Projection matrix by the a ModelView matrix (in that order.). There
 are several possible ways to obtain the current ModelView and
 Projection matrices. The most generally applicable way is to keep
 track of the current matrices in application code. If that is not
 convenient, there are two optional OpenGL ES extensions which may
 be used to read the current matrices from OpenGL ES:
 &lt;ul&gt;
 &lt;li&gt;GL10Ext.glQueryMatrixxOES
 &lt;li&gt;GL11.GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES and
 GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES
 &lt;/ul&gt;
 The problem with reading back the matrices is that your application
 will only work with devices that support the extension(s) that
 it uses.
 &lt;p&gt;
 A frustum is a six-sided truncated pyramid that defines the portion of
 world space that is visible in the view.
 &lt;p&gt;
 Spheres are described as four floating point values: x, y, z, and r, in
 world-space coordinates. R is the radius of the sphere.
 &lt;p&gt;
@param {Object {float[]}} mvp a float array containing the mode-view-projection matrix
@param {Number} mvpOffset The offset of the mvp data within the mvp array.
@param {Object {float[]}} spheres a float array containing the sphere data.
@param {Number} spheresOffset an offset into the sphere array where the sphere
        data starts
@param {Number} spheresCount the number of spheres to cull.
@param {Object {int[]}} results an integer array containing the indices of the spheres
 that are either contained entirely within or intersect the frustum.
@param {Number} resultsOffset an offset into the results array where the results
        start.
@param {Number} resultsCapacity the number of array elements available for storing
        results.
@return {Number} the number of spheres that intersected the frustum. Can be
 larger than resultsCapacity, in which case only the first resultsCapacity
 results are written into the results array.
@throws IllegalArgumentException if mvp is null, mvpOffset &lt; 0,
 mvpOffset &gt; mvp.length - 16, spheres is null, spheresOffset &lt; 0,
 spheresOffset &gt; spheres.length - sphereCount,
 results is null, resultsOffset &lt; 0, resultsOffset &gt; results.length -
 resultsCapacity.
*/
frustumCullSpheres : function(  ) {},

<span id='android-opengl-Visibility-method-computeBoundingSphere'>/**Compute a bounding sphere for a set of points. It is approximately the
</span> minimal bounding sphere of an axis-aligned box that bounds the points.
@param {Object {float[]}} positions positions in x, y, z triples
@param {Number} positionsOffset offset into positions array
@param {Number} positionsCount number of position triples to process
@param {Object {float[]}} sphere array containing the output as (x, y, z, r)
@param {Number} sphereOffset offset where the sphere data will be written
@throws IllegalArgumentException if positions is null,
 positionsOffset &lt; 0, positionsOffset &gt; positions.length - positionsCount,
 sphere is null, sphereOffset &lt; 0, sphereOffset &gt; sphere.length - 4.
*/
computeBoundingSphere : function(  ) {},


};</pre>
</body>
</html>
