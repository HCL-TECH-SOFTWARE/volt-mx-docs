Ext.data.JsonP.java_nio_channels_AsynchronousSocketChannel({"tagname":"class","name":"java.nio.channels.AsynchronousSocketChannel","autodetected":{},"files":[{"filename":"AsynchronousSocketChannel.js","href":"AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel"}],"extends":"java.lang.Object","since":"1.7","members":[{"name":"bind","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-bind","meta":{}},{"name":"connect","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-connect","meta":{}},{"name":"getLocalAddress","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-getLocalAddress","meta":{}},{"name":"getRemoteAddress","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-getRemoteAddress","meta":{}},{"name":"open","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-open","meta":{}},{"name":"provider","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-provider","meta":{}},{"name":"read","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-read","meta":{}},{"name":"setOption","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-setOption","meta":{}},{"name":"shutdownInput","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-shutdownInput","meta":{}},{"name":"shutdownOutput","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-shutdownOutput","meta":{}},{"name":"write","tagname":"method","owner":"java.nio.channels.AsynchronousSocketChannel","id":"method-write","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.nio.channels.AsynchronousSocketChannel","short_doc":"implements java.nio.channels.AsynchronousByteChannel\n\n implements java.nio.channels.NetworkChannel\n\nAn asynchronous c...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>java.nio.channels.AsynchronousSocketChannel</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel' target='_blank'>AsynchronousSocketChannel.js</a></div></pre><div class='doc-contents'><p>implements <a href=\"#!/api/java.nio.channels.AsynchronousByteChannel\" rel=\"java.nio.channels.AsynchronousByteChannel\" class=\"docClass\">java.nio.channels.AsynchronousByteChannel</a></p>\n\n<p> implements <a href=\"#!/api/java.nio.channels.NetworkChannel\" rel=\"java.nio.channels.NetworkChannel\" class=\"docClass\">java.nio.channels.NetworkChannel</a></p>\n\n<p>An asynchronous channel for stream-oriented connecting sockets.</p>\n\n<p> <p> Asynchronous socket channels are created in one of two ways. A newly-created\n {@code AsynchronousSocketChannel} is created by invoking one of the <a href=\"#!/api/java.nio.channels.AsynchronousSocketChannel-method-open\" rel=\"java.nio.channels.AsynchronousSocketChannel-method-open\" class=\"docClass\">open</a> methods defined by this class. A newly-created channel is open but\n not yet connected. A connected {@code AsynchronousSocketChannel} is created\n when a connection is made to the socket of an <a href=\"#!/api/java.nio.channels.AsynchronousServerSocketChannel\" rel=\"java.nio.channels.AsynchronousServerSocketChannel\" class=\"docClass\">java.nio.channels.AsynchronousServerSocketChannel</a>.\n It is not possible to create an asynchronous socket channel for an arbitrary,\n pre-existing socket.</p>\n\n<p> <p> A newly-created channel is connected by invoking its <a href=\"#!/api/java.nio.channels.AsynchronousSocketChannel-method-connect\" rel=\"java.nio.channels.AsynchronousSocketChannel-method-connect\" class=\"docClass\">connect</a>\n method; once connected, a channel remains connected until it is closed.  Whether\n or not a socket channel is connected may be determined by invoking its <a href=\"#!/api/java.nio.channels.AsynchronousSocketChannel-method-getRemoteAddress\" rel=\"java.nio.channels.AsynchronousSocketChannel-method-getRemoteAddress\" class=\"docClass\">getRemoteAddress</a> method. An attempt to invoke an I/O\n operation upon an unconnected channel will cause a <a href=\"#!/api/java.nio.channels.NotYetConnectedException\" rel=\"java.nio.channels.NotYetConnectedException\" class=\"docClass\">java.nio.channels.NotYetConnectedException</a>\n to be thrown.</p>\n\n<p> <p> Channels of this type are safe for use by multiple concurrent threads.\n They support concurrent reading and writing, though at most one read operation\n and one write operation can be outstanding at any time.\n If a thread initiates a read operation before a previous read operation has\n completed then a <a href=\"#!/api/java.nio.channels.ReadPendingException\" rel=\"java.nio.channels.ReadPendingException\" class=\"docClass\">java.nio.channels.ReadPendingException</a> will be thrown. Similarly, an\n attempt to initiate a write operation before a previous write has completed\n will throw a <a href=\"#!/api/java.nio.channels.WritePendingException\" rel=\"java.nio.channels.WritePendingException\" class=\"docClass\">java.nio.channels.WritePendingException</a>.</p>\n\n<p> <p> Socket options are configured using the setOption method. Asynchronous socket channels support the following options:\n <blockquote>\n <table border summary=\"Socket options\">\n   <tr>\n     <th>Option Name</th>\n     <th>Description</th>\n   </tr>\n   <tr>\n     <td> SO_SNDBUF </td>\n     <td> The size of the socket send buffer </td>\n   </tr>\n   <tr>\n     <td> SO_RCVBUF </td>\n     <td> The size of the socket receive buffer </td>\n   </tr>\n   <tr>\n     <td> SO_KEEPALIVE </td>\n     <td> Keep connection alive </td>\n   </tr>\n   <tr>\n     <td> SO_REUSEADDR </td>\n     <td> Re-use address </td>\n   </tr>\n   <tr>\n     <td> TCP_NODELAY </td>\n     <td> Disable the Nagle algorithm </td>\n   </tr>\n </table>\n </blockquote>\n Additional (implementation specific) options may also be supported.</p>\n\n<p> <h2>Timeouts</h2></p>\n\n<p> <p> The read\n and write\n methods defined by this class allow a timeout to be specified when initiating\n a read or write operation. If the timeout elapses before an operation completes\n then the operation completes with the exception <a href=\"#!/api/java.nio.channels.InterruptedByTimeoutException\" rel=\"java.nio.channels.InterruptedByTimeoutException\" class=\"docClass\">java.nio.channels.InterruptedByTimeoutException</a>. A timeout may leave the channel, or the\n underlying connection, in an inconsistent state. Where the implementation\n cannot guarantee that bytes have not been read from the channel then it puts\n the channel into an implementation specific <em>error state</em>. A subsequent\n attempt to initiate a {@code read} operation causes an unspecified runtime\n exception to be thrown. Similarly if a {@code write} operation times out and\n the implementation cannot guarantee bytes have not been written to the\n channel then further attempts to {@code write} to the channel cause an\n unspecified runtime exception to be thrown. When a timeout elapses then the\n state of the ByteBuffer, or the sequence of buffers, for the I/O\n operation is not defined. Buffers should be discarded or at least care must\n be taken to ensure that the buffers are not accessed while the channel remains\n open. All methods that accept timeout parameters treat values less than or\n equal to zero to mean that the I/O operation does not timeout.</p>\n        <p>Available since: <b>1.7</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-bind' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-bind' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-bind' class='name expandable'>bind</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>ConnectionPendingException\n          If a connection operation is already in progress on this channel</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>AlreadyBoundException               {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedAddressTypeException     {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClosedChannelException              {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException                         {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>SecurityException\n          If a security manager has been installed and its\n          checkListen method denies\n          the operation</p>\n</div></li></ul></div></div></div><div id='method-connect' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-connect' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-connect' class='name expandable'>connect</a>( <span class='pre'>remote</span> ) : Object {java.util.concurrent.Future}<span class=\"signature\"></span></div><div class='description'><div class='short'>Connects this channel. ...</div><div class='long'><p>Connects this channel.</p>\n\n<p> <p> This method initiates an operation to connect this channel. This\n method behaves in exactly the same manner as the Object, java.nio.channels.CompletionHandler) method except that\n instead of specifying a completion handler, this method returns a {@code\n Future} representing the pending result. The {@code Future}'s get method returns {@code null} on successful completion.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>remote</span> : Object {SocketAddress}<div class='sub-desc'><p>The remote address to which this channel is to be connected</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.util.concurrent.Future}</span><div class='sub-desc'><p>A {@code Future} object representing the pending result</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>UnresolvedAddressException\n          If the given remote address is not fully resolved</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>UnsupportedAddressTypeException\n          If the type of the given remote address is not supported</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>AlreadyConnectedException\n          If this channel is already connected</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ConnectionPendingException\n          If a connection operation is already in progress on this channel</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>SecurityException\n          If a security manager has been installed\n          and it does not permit access to the given remote endpoint</p>\n</div></li></ul></div></div></div><div id='method-getLocalAddress' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-getLocalAddress' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-getLocalAddress' class='name expandable'>getLocalAddress</a>( <span class='pre'></span> ) : Object {java.net.SocketAddress}<span class=\"signature\"></span></div><div class='description'><div class='short'>{@inheritDoc}\n \n If there is a security manager set, its {@code checkConnect} method is\n called with the local addres...</div><div class='long'><p>{@inheritDoc}\n <p>\n If there is a security manager set, its {@code checkConnect} method is\n called with the local address and {@code -1} as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n a {@code SocketAddress} representing the\n loopback address and the\n local port of the channel's socket is returned.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.net.SocketAddress}</span><div class='sub-desc'><p>The {@code SocketAddress} that the socket is bound to, or the\n          {@code SocketAddress} representing the loopback address if\n          denied by the security manager, or {@code null} if the\n          channel's socket is not bound</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>ClosedChannelException     {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException                {@inheritDoc}</p>\n</div></li></ul></div></div></div><div id='method-getRemoteAddress' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-getRemoteAddress' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-getRemoteAddress' class='name expandable'>getRemoteAddress</a>( <span class='pre'></span> ) : Object {java.net.SocketAddress}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the remote address to which this channel's socket is connected. ...</div><div class='long'><p>Returns the remote address to which this channel's socket is connected.</p>\n\n<p> <p> Where the channel is bound and connected to an Internet Protocol\n socket address then the return value from this method is of type java.net.InetSocketAddress.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.net.SocketAddress}</span><div class='sub-desc'><p>The remote address; {@code null} if the channel's socket is not\n          connected</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>ClosedChannelException\n          If the channel is closed</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException\n          If an I/O error occurs</p>\n</div></li></ul></div></div></div><div id='method-open' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-open' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-open' class='name expandable'>open</a>( <span class='pre'></span> ) : Object {java.nio.channels.AsynchronousSocketChannel}<span class=\"signature\"></span></div><div class='description'><div class='short'>Opens an asynchronous socket channel. ...</div><div class='long'><p>Opens an asynchronous socket channel.</p>\n\n<p> <p> This method returns an asynchronous socket channel that is bound to\n the <em>default group</em>.This method is equivalent to evaluating the\n expression:\n <blockquote></blockquote></p>\n\n<pre> open((AsynchronousChannelGroup)null);\n </pre>\n\n\n<p></p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.nio.channels.AsynchronousSocketChannel}</span><div class='sub-desc'><p>A new asynchronous socket channel</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException\n          If an I/O error occurs</p>\n</div></li></ul></div></div></div><div id='method-provider' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-provider' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-provider' class='name expandable'>provider</a>( <span class='pre'></span> ) : Object {java.nio.channels.spi.AsynchronousChannelProvider}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the provider that created this channel. ...</div><div class='long'><p>Returns the provider that created this channel.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.nio.channels.spi.AsynchronousChannelProvider}</span><div class='sub-desc'><p>The provider that created this channel</p>\n</div></li></ul></div></div></div><div id='method-read' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-read' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-read' class='name expandable'>read</a>( <span class='pre'>dsts, offset, length, timeout, unit, attachment, handler, handler</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Reads a sequence of bytes from this channel into a subsequence of the\n given buffers. ...</div><div class='long'><p>Reads a sequence of bytes from this channel into a subsequence of the\n given buffers. This operation, sometimes called a <em>scattering read</em>,\n is often useful when implementing network protocols that group data into\n segments consisting of one or more fixed-length headers followed by a\n variable-length body. The {@code handler} parameter is a completion\n handler that is invoked when the read operation completes (or fails). The\n result passed to the completion handler is the number of bytes read or\n {@code -1} if no bytes could be read because the channel has reached\n end-of-stream.</p>\n\n<p> <p> This method initiates a read of up to <i>r</i> bytes from this channel,\n where <i>r</i> is the total number of bytes remaining in the specified\n subsequence of the given buffer array, that is,</p>\n\n<p> <blockquote></blockquote></p>\n\n<pre> dsts[offset].remaining()\n     + dsts[offset+1].remaining()\n     + ... + dsts[offset+length-1].remaining()</pre>\n\n\n<pre><code>ockquote&gt;\n</code></pre>\n\n<p> at the moment that the read is attempted.</p>\n\n<p> <p> Suppose that a byte sequence of length <i>n</i> is read, where\n <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.\n Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence\n are transferred into buffer <tt>dsts[offset]</tt>, up to the next\n <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer\n <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence\n is transferred into the given buffers.  As many bytes as possible are\n transferred into each buffer, hence the final position of each updated\n buffer, except the last updated buffer, is guaranteed to be equal to\n that buffer's limit. The underlying operating system may impose a limit\n on the number of buffers that may be used in an I/O operation. Where the\n number of buffers (with bytes remaining), exceeds this limit, then the\n I/O operation is performed with the maximum number of buffers allowed by\n the operating system.</p>\n\n<p> <p> If a timeout is specified and the timeout elapses before the operation\n completes then it completes with the exception <a href=\"#!/api/java.nio.channels.InterruptedByTimeoutException\" rel=\"java.nio.channels.InterruptedByTimeoutException\" class=\"docClass\">java.nio.channels.InterruptedByTimeoutException</a>. Where a timeout occurs, and the\n implementation cannot guarantee that bytes have not been read, or will not\n be read from the channel into the given buffers, then further attempts to\n read from the channel will cause an unspecific runtime exception to be\n thrown.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>dsts</span> : Object {java.nio.ByteBuffer[]}<div class='sub-desc'><p>The buffers into which bytes are to be transferred</p>\n</div></li><li><span class='pre'>offset</span> : Number<div class='sub-desc'><p>The offset within the buffer array of the first buffer into which\n          bytes are to be transferred; must be non-negative and no larger than\n          {@code dsts.length}</p>\n</div></li><li><span class='pre'>length</span> : Number<div class='sub-desc'><p>The maximum number of buffers to be accessed; must be non-negative\n          and no larger than {@code dsts.length - offset}</p>\n</div></li><li><span class='pre'>timeout</span> : Number<div class='sub-desc'><p>The maximum time for the I/O operation to complete</p>\n</div></li><li><span class='pre'>unit</span> : Object {TimeUnit}<div class='sub-desc'><p>The time unit of the {@code timeout} argument</p>\n</div></li><li><span class='pre'>attachment</span> : Object {Object}<div class='sub-desc'><p>The object to attach to the I/O operation; can be {@code null}</p>\n</div></li><li><span class='pre'>handler</span> : Object {java.nio.channels.CompletionHandler}<div class='sub-desc'><p>The handler for consuming the result</p>\n</div></li><li><span class='pre'>handler</span> : Object<div class='sub-desc'><p>The handler for consuming the result</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IndexOutOfBoundsException\n          If the pre-conditions for the {@code offset}  and {@code length}\n          parameter aren't met</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException\n          If the buffer is read-only</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ReadPendingException\n          If a read operation is already in progress on this channel</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NotYetConnectedException\n          If this channel is not yet connected</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ShutdownChannelGroupException\n          If the channel group has terminated</p>\n</div></li></ul></div></div></div><div id='method-setOption' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-setOption' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-setOption' class='name expandable'>setOption</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException                {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClosedChannelException                  {@inheritDoc}</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException                             {@inheritDoc}</p>\n</div></li></ul></div></div></div><div id='method-shutdownInput' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-shutdownInput' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-shutdownInput' class='name expandable'>shutdownInput</a>( <span class='pre'></span> ) : Object {java.nio.channels.AsynchronousSocketChannel}<span class=\"signature\"></span></div><div class='description'><div class='short'>Shutdown the connection for reading without closing the channel. ...</div><div class='long'><p>Shutdown the connection for reading without closing the channel.</p>\n\n<p> <p> Once shutdown for reading then further reads on the channel will\n return {@code -1}, the end-of-stream indication. If the input side of the\n connection is already shutdown then invoking this method has no effect.\n The effect on an outstanding read operation is system dependent and\n therefore not specified. The effect, if any, when there is data in the\n socket receive buffer that has not been read, or data arrives subsequently,\n is also system dependent.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.nio.channels.AsynchronousSocketChannel}</span><div class='sub-desc'><p>The channel</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NotYetConnectedException\n          If this channel is not yet connected</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClosedChannelException\n          If this channel is closed</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException\n          If some other I/O error occurs</p>\n</div></li></ul></div></div></div><div id='method-shutdownOutput' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-shutdownOutput' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-shutdownOutput' class='name expandable'>shutdownOutput</a>( <span class='pre'></span> ) : Object {java.nio.channels.AsynchronousSocketChannel}<span class=\"signature\"></span></div><div class='description'><div class='short'>Shutdown the connection for writing without closing the channel. ...</div><div class='long'><p>Shutdown the connection for writing without closing the channel.</p>\n\n<p> <p> Once shutdown for writing then further attempts to write to the\n channel will throw <a href=\"#!/api/java.nio.channels.ClosedChannelException\" rel=\"java.nio.channels.ClosedChannelException\" class=\"docClass\">java.nio.channels.ClosedChannelException</a>. If the output side of\n the connection is already shutdown then invoking this method has no\n effect. The effect on an outstanding write operation is system dependent\n and therefore not specified.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.nio.channels.AsynchronousSocketChannel}</span><div class='sub-desc'><p>The channel</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>NotYetConnectedException\n          If this channel is not yet connected</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ClosedChannelException\n          If this channel is closed</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException\n          If some other I/O error occurs</p>\n</div></li></ul></div></div></div><div id='method-write' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousSocketChannel'>java.nio.channels.AsynchronousSocketChannel</span><br/><a href='source/AsynchronousSocketChannel.html#java-nio-channels-AsynchronousSocketChannel-method-write' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousSocketChannel-method-write' class='name expandable'>write</a>( <span class='pre'>srcs, offset, length, timeout, unit, attachment, handler, handler</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Writes a sequence of bytes to this channel from a subsequence of the given\n buffers. ...</div><div class='long'><p>Writes a sequence of bytes to this channel from a subsequence of the given\n buffers. This operation, sometimes called a <em>gathering write</em>, is\n often useful when implementing network protocols that group data into\n segments consisting of one or more fixed-length headers followed by a\n variable-length body. The {@code handler} parameter is a completion\n handler that is invoked when the write operation completes (or fails).\n The result passed to the completion handler is the number of bytes written.</p>\n\n<p> <p> This method initiates a write of up to <i>r</i> bytes to this channel,\n where <i>r</i> is the total number of bytes remaining in the specified\n subsequence of the given buffer array, that is,</p>\n\n<p> <blockquote></blockquote></p>\n\n<pre> srcs[offset].remaining()\n     + srcs[offset+1].remaining()\n     + ... + srcs[offset+length-1].remaining()</pre>\n\n\n<pre><code>ockquote&gt;\n</code></pre>\n\n<p> at the moment that the write is attempted.</p>\n\n<p> <p> Suppose that a byte sequence of length <i>n</i> is written, where\n <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.\n Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence\n are written from buffer <tt>srcs[offset]</tt>, up to the next\n <tt>srcs[offset+1].remaining()</tt> bytes are written from buffer\n <tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is\n written.  As many bytes as possible are written from each buffer, hence\n the final position of each updated buffer, except the last updated\n buffer, is guaranteed to be equal to that buffer's limit. The underlying\n operating system may impose a limit on the number of buffers that may be\n used in an I/O operation. Where the number of buffers (with bytes\n remaining), exceeds this limit, then the I/O operation is performed with\n the maximum number of buffers allowed by the operating system.</p>\n\n<p> <p> If a timeout is specified and the timeout elapses before the operation\n completes then it completes with the exception <a href=\"#!/api/java.nio.channels.InterruptedByTimeoutException\" rel=\"java.nio.channels.InterruptedByTimeoutException\" class=\"docClass\">java.nio.channels.InterruptedByTimeoutException</a>. Where a timeout occurs, and the\n implementation cannot guarantee that bytes have not been written, or will\n not be written to the channel from the given buffers, then further attempts\n to write to the channel will cause an unspecific runtime exception to be\n thrown.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>srcs</span> : Object {java.nio.ByteBuffer[]}<div class='sub-desc'><p>The buffers from which bytes are to be retrieved</p>\n</div></li><li><span class='pre'>offset</span> : Number<div class='sub-desc'><p>The offset within the buffer array of the first buffer from which\n          bytes are to be retrieved; must be non-negative and no larger\n          than {@code srcs.length}</p>\n</div></li><li><span class='pre'>length</span> : Number<div class='sub-desc'><p>The maximum number of buffers to be accessed; must be non-negative\n          and no larger than {@code srcs.length - offset}</p>\n</div></li><li><span class='pre'>timeout</span> : Number<div class='sub-desc'><p>The maximum time for the I/O operation to complete</p>\n</div></li><li><span class='pre'>unit</span> : Object {TimeUnit}<div class='sub-desc'><p>The time unit of the {@code timeout} argument</p>\n</div></li><li><span class='pre'>attachment</span> : Object {Object}<div class='sub-desc'><p>The object to attach to the I/O operation; can be {@code null}</p>\n</div></li><li><span class='pre'>handler</span> : Object {java.nio.channels.CompletionHandler}<div class='sub-desc'><p>The handler for consuming the result</p>\n</div></li><li><span class='pre'>handler</span> : Object<div class='sub-desc'><p>The handler for consuming the result</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IndexOutOfBoundsException\n          If the pre-conditions for the {@code offset}  and {@code length}\n          parameter aren't met</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>WritePendingException\n          If a write operation is already in progress on this channel</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NotYetConnectedException\n          If this channel is not yet connected</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ShutdownChannelGroupException\n          If the channel group has terminated</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});