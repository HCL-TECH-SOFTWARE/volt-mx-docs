Ext.data.JsonP.java_nio_channels_AsynchronousByteChannel({"tagname":"class","name":"java.nio.channels.AsynchronousByteChannel","autodetected":{},"files":[{"filename":"AsynchronousByteChannel.js","href":"AsynchronousByteChannel.html#java-nio-channels-AsynchronousByteChannel"}],"since":"1.7","members":[{"name":"read","tagname":"method","owner":"java.nio.channels.AsynchronousByteChannel","id":"method-read","meta":{}},{"name":"write","tagname":"method","owner":"java.nio.channels.AsynchronousByteChannel","id":"method-write","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.nio.channels.AsynchronousByteChannel","short_doc":"implements java.nio.channels.AsynchronousChannel\n\n An asynchronous channel that can read and write bytes. ...","classIcon":"icon-class","superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/AsynchronousByteChannel.html#java-nio-channels-AsynchronousByteChannel' target='_blank'>AsynchronousByteChannel.js</a></div></pre><div class='doc-contents'><p>implements <a href=\"#!/api/java.nio.channels.AsynchronousChannel\" rel=\"java.nio.channels.AsynchronousChannel\" class=\"docClass\">java.nio.channels.AsynchronousChannel</a></p>\n\n<p> An asynchronous channel that can read and write bytes.</p>\n\n<p> <p> Some channels may not allow more than one read or write to be outstanding\n at any given time. If a thread invokes a read method before a previous read\n operation has completed then a <a href=\"#!/api/java.nio.channels.ReadPendingException\" rel=\"java.nio.channels.ReadPendingException\" class=\"docClass\">java.nio.channels.ReadPendingException</a> will be thrown.\n Similarly, if a write method is invoked before a previous write has completed\n then <a href=\"#!/api/java.nio.channels.WritePendingException\" rel=\"java.nio.channels.WritePendingException\" class=\"docClass\">java.nio.channels.WritePendingException</a> is thrown. Whether or not other kinds of\n I/O operations may proceed concurrently with a read operation depends upon\n the type of the channel.</p>\n\n<p> <p> Note that ByteBuffers are not safe for use by\n multiple concurrent threads. When a read or write operation is initiated then\n care must be taken to ensure that the buffer is not accessed until the\n operation completes.</p>\n\n<p> @see Channels#newInputStream(AsynchronousByteChannel)\n @see Channels#newOutputStream(AsynchronousByteChannel)</p>\n        <p>Available since: <b>1.7</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-read' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousByteChannel'>java.nio.channels.AsynchronousByteChannel</span><br/><a href='source/AsynchronousByteChannel.html#java-nio-channels-AsynchronousByteChannel-method-read' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousByteChannel-method-read' class='name expandable'>read</a>( <span class='pre'>dst</span> ) : Object {java.util.concurrent.Future}<span class=\"signature\"></span></div><div class='description'><div class='short'>Reads a sequence of bytes from this channel into the given buffer. ...</div><div class='long'><p>Reads a sequence of bytes from this channel into the given buffer.</p>\n\n<p> <p> This method initiates an asynchronous read operation to read a\n sequence of bytes from this channel into the given buffer. The method\n behaves in exactly the same manner as the read(ByteBuffer,Object,CompletionHandler) method except that instead\n of specifying a completion handler, this method returns a {@code Future}\n representing the pending result. The {@code Future}'s get method returns the number of bytes read or {@code -1} if no bytes\n could be read because the channel has reached end-of-stream.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>dst</span> : Object {ByteBuffer}<div class='sub-desc'><p>The buffer into which bytes are to be transferred</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.util.concurrent.Future}</span><div class='sub-desc'><p>A Future representing the result of the operation</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException\n          If the buffer is read-only</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>ReadPendingException\n          If the channel does not allow more than one read to be outstanding\n          and a previous read has not completed</p>\n</div></li></ul></div></div></div><div id='method-write' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.nio.channels.AsynchronousByteChannel'>java.nio.channels.AsynchronousByteChannel</span><br/><a href='source/AsynchronousByteChannel.html#java-nio-channels-AsynchronousByteChannel-method-write' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.nio.channels.AsynchronousByteChannel-method-write' class='name expandable'>write</a>( <span class='pre'>src</span> ) : Object {java.util.concurrent.Future}<span class=\"signature\"></span></div><div class='description'><div class='short'>Writes a sequence of bytes to this channel from the given buffer. ...</div><div class='long'><p>Writes a sequence of bytes to this channel from the given buffer.</p>\n\n<p> <p> This method initiates an asynchronous write operation to write a\n sequence of bytes to this channel from the given buffer. The method\n behaves in exactly the same manner as the write(ByteBuffer,Object,CompletionHandler) method except that instead\n of specifying a completion handler, this method returns a {@code Future}\n representing the pending result. The {@code Future}'s get method returns the number of bytes written.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>src</span> : Object {ByteBuffer}<div class='sub-desc'><p>The buffer from which bytes are to be retrieved</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.util.concurrent.Future}</span><div class='sub-desc'><p>A Future representing the result of the operation</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>WritePendingException\n          If the channel does not allow more than one write to be outstanding\n          and a previous write has not completed</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});