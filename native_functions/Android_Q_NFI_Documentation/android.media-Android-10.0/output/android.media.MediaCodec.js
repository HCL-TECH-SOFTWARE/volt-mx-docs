Ext.data.JsonP.android_media_MediaCodec({"tagname":"class","name":"android.media.MediaCodec","autodetected":{},"files":[{"filename":"MediaCodec.js","href":"MediaCodec.html#android-media-MediaCodec"}],"extends":"java.lang.Object","members":[{"name":"BUFFER_FLAG_CODEC_CONFIG","tagname":"property","owner":"android.media.MediaCodec","id":"property-BUFFER_FLAG_CODEC_CONFIG","meta":{}},{"name":"BUFFER_FLAG_END_OF_STREAM","tagname":"property","owner":"android.media.MediaCodec","id":"property-BUFFER_FLAG_END_OF_STREAM","meta":{}},{"name":"BUFFER_FLAG_KEY_FRAME","tagname":"property","owner":"android.media.MediaCodec","id":"property-BUFFER_FLAG_KEY_FRAME","meta":{}},{"name":"BUFFER_FLAG_PARTIAL_FRAME","tagname":"property","owner":"android.media.MediaCodec","id":"property-BUFFER_FLAG_PARTIAL_FRAME","meta":{}},{"name":"BUFFER_FLAG_SYNC_FRAME","tagname":"property","owner":"android.media.MediaCodec","id":"property-BUFFER_FLAG_SYNC_FRAME","meta":{"deprecated":{"text":"<p>Use <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" class=\"docClass\">BUFFER_FLAG_KEY_FRAME</a> instead.</p>\n"}}},{"name":"CONFIGURE_FLAG_ENCODE","tagname":"property","owner":"android.media.MediaCodec","id":"property-CONFIGURE_FLAG_ENCODE","meta":{}},{"name":"CRYPTO_MODE_AES_CBC","tagname":"property","owner":"android.media.MediaCodec","id":"property-CRYPTO_MODE_AES_CBC","meta":{}},{"name":"CRYPTO_MODE_AES_CTR","tagname":"property","owner":"android.media.MediaCodec","id":"property-CRYPTO_MODE_AES_CTR","meta":{}},{"name":"CRYPTO_MODE_UNENCRYPTED","tagname":"property","owner":"android.media.MediaCodec","id":"property-CRYPTO_MODE_UNENCRYPTED","meta":{}},{"name":"INFO_OUTPUT_BUFFERS_CHANGED","tagname":"property","owner":"android.media.MediaCodec","id":"property-INFO_OUTPUT_BUFFERS_CHANGED","meta":{"deprecated":{"text":"<p>This return value can be ignored as <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">getOutputBuffers</a> has been deprecated.  Client should\nrequest a current buffer using on of the get-buffer or\nget-image methods each time one has been dequeued.</p>\n"}}},{"name":"INFO_OUTPUT_FORMAT_CHANGED","tagname":"property","owner":"android.media.MediaCodec","id":"property-INFO_OUTPUT_FORMAT_CHANGED","meta":{}},{"name":"INFO_TRY_AGAIN_LATER","tagname":"property","owner":"android.media.MediaCodec","id":"property-INFO_TRY_AGAIN_LATER","meta":{}},{"name":"PARAMETER_KEY_HDR10_PLUS_INFO","tagname":"property","owner":"android.media.MediaCodec","id":"property-PARAMETER_KEY_HDR10_PLUS_INFO","meta":{}},{"name":"PARAMETER_KEY_OFFSET_TIME","tagname":"property","owner":"android.media.MediaCodec","id":"property-PARAMETER_KEY_OFFSET_TIME","meta":{}},{"name":"PARAMETER_KEY_REQUEST_SYNC_FRAME","tagname":"property","owner":"android.media.MediaCodec","id":"property-PARAMETER_KEY_REQUEST_SYNC_FRAME","meta":{}},{"name":"PARAMETER_KEY_SUSPEND","tagname":"property","owner":"android.media.MediaCodec","id":"property-PARAMETER_KEY_SUSPEND","meta":{}},{"name":"PARAMETER_KEY_SUSPEND_TIME","tagname":"property","owner":"android.media.MediaCodec","id":"property-PARAMETER_KEY_SUSPEND_TIME","meta":{}},{"name":"PARAMETER_KEY_VIDEO_BITRATE","tagname":"property","owner":"android.media.MediaCodec","id":"property-PARAMETER_KEY_VIDEO_BITRATE","meta":{}},{"name":"VIDEO_SCALING_MODE_SCALE_TO_FIT","tagname":"property","owner":"android.media.MediaCodec","id":"property-VIDEO_SCALING_MODE_SCALE_TO_FIT","meta":{}},{"name":"VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING","tagname":"property","owner":"android.media.MediaCodec","id":"property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING","meta":{}},{"name":"configure","tagname":"method","owner":"android.media.MediaCodec","id":"method-configure","meta":{}},{"name":"createByCodecName","tagname":"method","owner":"android.media.MediaCodec","id":"method-createByCodecName","meta":{}},{"name":"createDecoderByType","tagname":"method","owner":"android.media.MediaCodec","id":"method-createDecoderByType","meta":{}},{"name":"createEncoderByType","tagname":"method","owner":"android.media.MediaCodec","id":"method-createEncoderByType","meta":{}},{"name":"createInputSurface","tagname":"method","owner":"android.media.MediaCodec","id":"method-createInputSurface","meta":{}},{"name":"createPersistentInputSurface","tagname":"method","owner":"android.media.MediaCodec","id":"method-createPersistentInputSurface","meta":{}},{"name":"dequeueInputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-dequeueInputBuffer","meta":{}},{"name":"dequeueOutputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-dequeueOutputBuffer","meta":{}},{"name":"flush","tagname":"method","owner":"android.media.MediaCodec","id":"method-flush","meta":{}},{"name":"getCanonicalName","tagname":"method","owner":"android.media.MediaCodec","id":"method-getCanonicalName","meta":{}},{"name":"getCodecInfo","tagname":"method","owner":"android.media.MediaCodec","id":"method-getCodecInfo","meta":{}},{"name":"getInputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-getInputBuffer","meta":{}},{"name":"getInputBuffers","tagname":"method","owner":"android.media.MediaCodec","id":"method-getInputBuffers","meta":{"deprecated":{"text":"<p>Use the new <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffer\" rel=\"android.media.MediaCodec-method-getInputBuffer\" class=\"docClass\">getInputBuffer</a> method instead\n each time an input buffer is dequeued.</p>\n\n<p> <b>Note:</b> As of API 21, dequeued input buffers are\n automatically cleared.</p>\n\n<p> <em>Do not use this method if using an input surface.</em></p>\n"}}},{"name":"getInputFormat","tagname":"method","owner":"android.media.MediaCodec","id":"method-getInputFormat","meta":{}},{"name":"getInputImage","tagname":"method","owner":"android.media.MediaCodec","id":"method-getInputImage","meta":{}},{"name":"getMetrics","tagname":"method","owner":"android.media.MediaCodec","id":"method-getMetrics","meta":{}},{"name":"getName","tagname":"method","owner":"android.media.MediaCodec","id":"method-getName","meta":{}},{"name":"getOutputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-getOutputBuffer","meta":{}},{"name":"getOutputBuffers","tagname":"method","owner":"android.media.MediaCodec","id":"method-getOutputBuffers","meta":{"deprecated":{"text":"<p>Use the new <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffer\" rel=\"android.media.MediaCodec-method-getOutputBuffer\" class=\"docClass\">getOutputBuffer</a> method instead\n each time an output buffer is dequeued.  This method is not\n supported if codec is configured in asynchronous mode.</p>\n\n<p> <b>Note:</b> As of API 21, the position and limit of output\n buffers that are dequeued will be set to the valid data\n range.</p>\n\n<p> <em>Do not use this method if using an output surface.</em></p>\n"}}},{"name":"getOutputFormat","tagname":"method","owner":"android.media.MediaCodec","id":"method-getOutputFormat","meta":{}},{"name":"getOutputImage","tagname":"method","owner":"android.media.MediaCodec","id":"method-getOutputImage","meta":{}},{"name":"queueInputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-queueInputBuffer","meta":{}},{"name":"queueSecureInputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-queueSecureInputBuffer","meta":{}},{"name":"release","tagname":"method","owner":"android.media.MediaCodec","id":"method-release","meta":{}},{"name":"releaseOutputBuffer","tagname":"method","owner":"android.media.MediaCodec","id":"method-releaseOutputBuffer","meta":{}},{"name":"reset","tagname":"method","owner":"android.media.MediaCodec","id":"method-reset","meta":{}},{"name":"setAudioPresentation","tagname":"method","owner":"android.media.MediaCodec","id":"method-setAudioPresentation","meta":{}},{"name":"setCallback","tagname":"method","owner":"android.media.MediaCodec","id":"method-setCallback","meta":{}},{"name":"setInputSurface","tagname":"method","owner":"android.media.MediaCodec","id":"method-setInputSurface","meta":{}},{"name":"setOnFrameRenderedListener","tagname":"method","owner":"android.media.MediaCodec","id":"method-setOnFrameRenderedListener","meta":{}},{"name":"setOutputSurface","tagname":"method","owner":"android.media.MediaCodec","id":"method-setOutputSurface","meta":{}},{"name":"setParameters","tagname":"method","owner":"android.media.MediaCodec","id":"method-setParameters","meta":{}},{"name":"setVideoScalingMode","tagname":"method","owner":"android.media.MediaCodec","id":"method-setVideoScalingMode","meta":{}},{"name":"signalEndOfInputStream","tagname":"method","owner":"android.media.MediaCodec","id":"method-signalEndOfInputStream","meta":{}},{"name":"start","tagname":"method","owner":"android.media.MediaCodec","id":"method-start","meta":{}},{"name":"stop","tagname":"method","owner":"android.media.MediaCodec","id":"method-stop","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-android.media.MediaCodec","short_doc":"MediaCodec class can be used to access low-level media codecs, i.e. ...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>android.media.MediaCodec</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/MediaCodec.html#android-media-MediaCodec' target='_blank'>MediaCodec.js</a></div></pre><div class='doc-contents'><p>MediaCodec class can be used to access low-level media codecs, i.e. encoder/decoder components.\n It is part of the Android low-level multimedia support infrastructure (normally used together\n with <a href=\"#!/api/android.media.MediaExtractor\" rel=\"android.media.MediaExtractor\" class=\"docClass\">android.media.MediaExtractor</a>, <a href=\"#!/api/android.media.MediaSync\" rel=\"android.media.MediaSync\" class=\"docClass\">android.media.MediaSync</a>, <a href=\"#!/api/android.media.MediaMuxer\" rel=\"android.media.MediaMuxer\" class=\"docClass\">android.media.MediaMuxer</a>, <a href=\"#!/api/android.media.MediaCrypto\" rel=\"android.media.MediaCrypto\" class=\"docClass\">android.media.MediaCrypto</a>,\n <a href=\"#!/api/android.media.MediaDrm\" rel=\"android.media.MediaDrm\" class=\"docClass\">android.media.MediaDrm</a>, <a href=\"#!/api/android.media.Image\" rel=\"android.media.Image\" class=\"docClass\">android.media.Image</a>, Surface, and <a href=\"#!/api/android.media.AudioTrack\" rel=\"android.media.AudioTrack\" class=\"docClass\">android.media.AudioTrack</a>.)\n <p>\n <center><object style=\"width: 540px; height: 205px;\" type=\"image/svg+xml\"\n   data=\"../../../images/media/mediacodec_buffers.svg\"><img\n   src=\"../../../images/media/mediacodec_buffers.png\" style=\"width: 540px; height: 205px\"\n   alt=\"MediaCodec buffer flow diagram\"></object></center>\n <p>\n In broad terms, a codec processes input data to generate output data. It processes data\n asynchronously and uses a set of input and output buffers. At a simplistic level, you request\n (or receive) an empty input buffer, fill it up with data and send it to the codec for\n processing. The codec uses up the data and transforms it into one of its empty output buffers.\n Finally, you request (or receive) a filled output buffer, consume its contents and release it\n back to the codec.</p>\n\n<p> <h3>Data Types</h3>\n <p>\n Codecs operate on three kinds of data: compressed data, raw audio data and raw video data.\n All three kinds of data can be processed using ByteBuffers, but you should use\n a Surface for raw video data to improve codec performance. Surface uses native video\n buffers without mapping or copying them to ByteBuffers; thus, it is much more efficient.\n You normally cannot access the raw video data when using a Surface, but you can use the\n <a href=\"#!/api/android.media.ImageReader\" rel=\"android.media.ImageReader\" class=\"docClass\">android.media.ImageReader</a> class to access unsecured decoded (raw) video frames. This may still be more\n efficient than using ByteBuffers, as some native buffers may be mapped into {@linkplain\n ByteBuffer#isDirect direct} ByteBuffers. When using ByteBuffer mode, you can access raw video\n frames using the <a href=\"#!/api/android.media.Image\" rel=\"android.media.Image\" class=\"docClass\">android.media.Image</a> class and <a href=\"#!/api/android.media.MediaCodec-method-getInputImage\" rel=\"android.media.MediaCodec-method-getInputImage\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputImage\" rel=\"android.media.MediaCodec-method-getOutputImage\" class=\"docClass\">OutputImage(int)</a>.</p>\n\n<p> <h4>Compressed Buffers</h4>\n <p>\n Input buffers (for decoders) and output buffers (for encoders) contain compressed data according\n to the {@linkplain <a href=\"#!/api/android.media.MediaFormat-property-KEY_MIME\" rel=\"android.media.MediaFormat-property-KEY_MIME\" class=\"docClass\">android.media.MediaFormat.KEY_MIME</a> format's type}. For video types this is normally a single\n compressed video frame. For audio data this is normally a single access unit (an encoded audio\n segment typically containing a few milliseconds of audio as dictated by the format type), but\n this requirement is slightly relaxed in that a buffer may contain multiple encoded access units\n of audio. In either case, buffers do not start or end on arbitrary byte boundaries, but rather on\n frame/access unit boundaries unless they are flagged with <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_PARTIAL_FRAME\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_PARTIAL_FRAME\" class=\"docClass\">BUFFER_FLAG_PARTIAL_FRAME</a>.</p>\n\n<p> <h4>Raw Audio Buffers</h4>\n <p>\n Raw audio buffers contain entire frames of PCM audio data, which is one sample for each channel\n in channel order. Each PCM audio sample is either a 16 bit signed integer or a float,\n in native byte order.\n Raw audio buffers in the float PCM encoding are only possible\n if the MediaFormat's {@linkplain <a href=\"#!/api/android.media.MediaFormat-property-KEY_PCM_ENCODING\" rel=\"android.media.MediaFormat-property-KEY_PCM_ENCODING\" class=\"docClass\">android.media.MediaFormat.KEY_PCM_ENCODING</a>}\n is set to {@linkplain <a href=\"#!/api/android.media.AudioFormat-property-ENCODING_PCM_FLOAT\" rel=\"android.media.AudioFormat-property-ENCODING_PCM_FLOAT\" class=\"docClass\">android.media.AudioFormat.ENCODING_PCM_FLOAT</a>} during MediaCodec\n <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure(&amp;hellip;)</a>\n and confirmed by <a href=\"#!/api/android.media.MediaCodec-method-getOutputFormat\" rel=\"android.media.MediaCodec-method-getOutputFormat\" class=\"docClass\">getOutputFormat</a> for decoders\n or <a href=\"#!/api/android.media.MediaCodec-method-getInputFormat\" rel=\"android.media.MediaCodec-method-getInputFormat\" class=\"docClass\">getInputFormat</a> for encoders.\n A sample method to check for float PCM in the MediaFormat is as follows:</p>\n\n<p> <pre class=prettyprint>\n static boolean isPcmFloat(MediaFormat format) {\n   return format.getInteger(MediaFormat.KEY_PCM_ENCODING, AudioFormat.ENCODING_PCM_16BIT)\n       == AudioFormat.ENCODING_PCM_FLOAT;\n }</pre></p>\n\n<p> In order to extract, in a short array,\n one channel of a buffer containing 16 bit signed integer audio data,\n the following code may be used:</p>\n\n<p> <pre class=prettyprint>\n // Assumes the buffer PCM encoding is 16 bit.\n short[] getSamplesForChannel(MediaCodec codec, int bufferId, int channelIx) {\n   ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);\n   MediaFormat format = codec.getOutputFormat(bufferId);\n   ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();\n   int numChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);\n   if (channelIx &lt; 0 || channelIx &gt;= numChannels) {\n     return null;\n   }\n   short[] res = new short[samples.remaining() / numChannels];\n   for (int i = 0; i &lt; res.length; ++i) {\n     res[i] = samples.get(i * numChannels + channelIx);\n   }\n   return res;\n }</pre></p>\n\n<p> <h4>Raw Video Buffers</h4>\n <p>\n In ByteBuffer mode video buffers are laid out according to their {@linkplain\n <a href=\"#!/api/android.media.MediaFormat-property-KEY_COLOR_FORMAT\" rel=\"android.media.MediaFormat-property-KEY_COLOR_FORMAT\" class=\"docClass\">android.media.MediaFormat.KEY_COLOR_FORMAT</a> color format}. You can get the supported color formats as an array\n from <a href=\"#!/api/android.media.MediaCodec-method-getCodecInfo\" rel=\"android.media.MediaCodec-method-getCodecInfo\" class=\"docClass\">getCodecInfo</a>{@code .}<a href=\"#!/api/android.media.MediaCodecInfo-method-getCapabilitiesForType\" rel=\"android.media.MediaCodecInfo-method-getCapabilitiesForType\" class=\"docClass\">getCapabilitiesForType(&amp;hellip;)</a>{@code .}<a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities-property-colorFormats\" rel=\"android.media.MediaCodecInfo.CodecCapabilities-property-colorFormats\" class=\"docClass\">colorFormats</a>.\n Video codecs may support three kinds of color formats:\n <ul>\n <li><strong>native raw video format:</strong> This is marked by <a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities-property-COLOR_FormatSurface\" rel=\"android.media.MediaCodecInfo.CodecCapabilities-property-COLOR_FormatSurface\" class=\"docClass\">android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface</a> and it can be used with an input or output Surface.</li>\n <li><strong>flexible YUV buffers</strong> (such as <a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities-property-COLOR_FormatYUV420Flexible\" rel=\"android.media.MediaCodecInfo.CodecCapabilities-property-COLOR_FormatYUV420Flexible\" class=\"docClass\">android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible</a>): These can be used with an input/output Surface,\n as well as in ByteBuffer mode, by using <a href=\"#!/api/android.media.MediaCodec-method-getInputImage\" rel=\"android.media.MediaCodec-method-getInputImage\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputImage\" rel=\"android.media.MediaCodec-method-getOutputImage\" class=\"docClass\">OutputImage(int)</a>.</li>\n <li><strong>other, specific formats:</strong> These are normally only supported in ByteBuffer\n mode. Some color formats are vendor specific. Others are defined in <a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities\" rel=\"android.media.MediaCodecInfo.CodecCapabilities\" class=\"docClass\">android.media.MediaCodecInfo.CodecCapabilities</a>.\n For color formats that are equivalent to a flexible format, you can still use <a href=\"#!/api/android.media.MediaCodec-method-getInputImage\" rel=\"android.media.MediaCodec-method-getInputImage\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputImage\" rel=\"android.media.MediaCodec-method-getOutputImage\" class=\"docClass\">OutputImage(int)</a>.</li>\n </ul>\n <p>\n All video codecs support flexible YUV 4:2:0 buffers since android.os.Build.VERSION_CODES.LOLLIPOP_MR1.</p>\n\n<p> <h4>Accessing Raw Video ByteBuffers on Older Devices</h4>\n <p>\n Prior to android.os.Build.VERSION_CODES.LOLLIPOP and <a href=\"#!/api/android.media.Image\" rel=\"android.media.Image\" class=\"docClass\">android.media.Image</a> support, you need to\n use the <a href=\"#!/api/android.media.MediaFormat-property-KEY_STRIDE\" rel=\"android.media.MediaFormat-property-KEY_STRIDE\" class=\"docClass\">android.media.MediaFormat.KEY_STRIDE</a> and <a href=\"#!/api/android.media.MediaFormat-property-KEY_SLICE_HEIGHT\" rel=\"android.media.MediaFormat-property-KEY_SLICE_HEIGHT\" class=\"docClass\">android.media.MediaFormat.KEY_SLICE_HEIGHT</a> output format\n values to understand the layout of the raw output buffers.\n <p class=note>\n Note that on some devices the slice-height is advertised as 0. This could mean either that the\n slice-height is the same as the frame height, or that the slice-height is the frame height\n aligned to some value (usually a power of 2). Unfortunately, there is no standard and simple way\n to tell the actual slice height in this case. Furthermore, the vertical stride of the {@code U}\n plane in planar formats is also not specified or defined, though usually it is half of the slice\n height.\n <p>\n The <a href=\"#!/api/android.media.MediaFormat-property-KEY_WIDTH\" rel=\"android.media.MediaFormat-property-KEY_WIDTH\" class=\"docClass\">android.media.MediaFormat.KEY_WIDTH</a> and <a href=\"#!/api/android.media.MediaFormat-property-KEY_HEIGHT\" rel=\"android.media.MediaFormat-property-KEY_HEIGHT\" class=\"docClass\">android.media.MediaFormat.KEY_HEIGHT</a> keys specify the size of the\n video frames; however, for most encondings the video (picture) only occupies a portion of the\n video frame. This is represented by the 'crop rectangle'.\n <p>\n You need to use the following keys to get the crop rectangle of raw output images from the\n {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-getOutputFormat\" rel=\"android.media.MediaCodec-method-getOutputFormat\" class=\"docClass\">getOutputFormat</a> output format}. If these keys are not present, the video occupies the\n entire video frame.The crop rectangle is understood in the context of the output frame\n <em>before</em> applying any {@linkplain <a href=\"#!/api/android.media.MediaFormat-property-KEY_ROTATION\" rel=\"android.media.MediaFormat-property-KEY_ROTATION\" class=\"docClass\">android.media.MediaFormat.KEY_ROTATION</a> rotation}.\n <table style=\"width: 0%\">\n  <thead>\n   <tr>\n    <th>Format Key</th>\n    <th>Type</th>\n    <th>Description</th>\n   </tr>\n  </thead>\n  <tbody>\n   <tr>\n    <td>{@code \"crop-left\"}</td>\n    <td>Integer</td>\n    <td>The left-coordinate (x) of the crop rectangle</td>\n   </tr><tr>\n    <td>{@code \"crop-top\"}</td>\n    <td>Integer</td>\n    <td>The top-coordinate (y) of the crop rectangle</td>\n   </tr><tr>\n    <td>{@code \"crop-right\"}</td>\n    <td>Integer</td>\n    <td>The right-coordinate (x) <strong>MINUS 1</strong> of the crop rectangle</td>\n   </tr><tr>\n    <td>{@code \"crop-bottom\"}</td>\n    <td>Integer</td>\n    <td>The bottom-coordinate (y) <strong>MINUS 1</strong> of the crop rectangle</td>\n   </tr><tr>\n    <td colspan=3>\n     The right and bottom coordinates can be understood as the coordinates of the right-most\n     valid column/bottom-most valid row of the cropped output image.\n    </td>\n   </tr>\n  </tbody>\n </table>\n <p>\n The size of the video frame (before rotation) can be calculated as such:\n <pre class=prettyprint>\n MediaFormat format = decoder.getOutputFormat(&hellip;);\n int width = format.getInteger(MediaFormat.KEY_WIDTH);\n if (format.containsKey(\"crop-left\") &amp;&amp; format.containsKey(\"crop-right\")) {\n     width = format.getInteger(\"crop-right\") + 1 - format.getInteger(\"crop-left\");\n }\n int height = format.getInteger(MediaFormat.KEY_HEIGHT);\n if (format.containsKey(\"crop-top\") &amp;&amp; format.containsKey(\"crop-bottom\")) {\n     height = format.getInteger(\"crop-bottom\") + 1 - format.getInteger(\"crop-top\");\n }\n </pre>\n <p class=note>\n Also note that the meaning of <a href=\"#!/api/android.media.MediaCodec.BufferInfo-property-offset\" rel=\"android.media.MediaCodec.BufferInfo-property-offset\" class=\"docClass\">android.media.MediaCodec.BufferInfo.offset</a> was not consistent across\n devices. On some devices the offset pointed to the top-left pixel of the crop rectangle, while on\n most devices it pointed to the top-left pixel of the entire frame.</p>\n\n<p> <h3>States</h3>\n <p>\n During its life a codec conceptually exists in one of three states: Stopped, Executing or\n Released. The Stopped collective state is actually the conglomeration of three states:\n Uninitialized, Configured and Error, whereas the Executing state conceptually progresses through\n three sub-states: Flushed, Running and End-of-Stream.\n <p>\n <center><object style=\"width: 516px; height: 353px;\" type=\"image/svg+xml\"\n   data=\"../../../images/media/mediacodec_states.svg\"><img\n   src=\"../../../images/media/mediacodec_states.png\" style=\"width: 519px; height: 356px\"\n   alt=\"MediaCodec state diagram\"></object></center>\n <p>\n When you create a codec using one of the factory methods, the codec is in the Uninitialized\n state. First, you need to configure it via <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure(&amp;hellip;)</a>, which brings\n it to the Configured state, then call <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> to move it to the Executing state. In this\n state you can process data through the buffer queue manipulation described above.\n <p>\n The Executing state has three sub-states: Flushed, Running and End-of-Stream. Immediately after\n <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> the codec is in the Flushed sub-state, where it holds all the buffers. As soon\n as the first input buffer is dequeued, the codec moves to the Running sub-state, where it spends\n most of its life. When you queue an input buffer with the {@linkplain <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" class=\"docClass\">BUFFER_FLAG_END_OF_STREAM</a>\n end-of-stream marker}, the codec transitions to the End-of-Stream sub-state. In this state the\n codec no longer accepts further input buffers, but still generates output buffers until the\n end-of-stream is reached on the output. You can move back to the Flushed sub-state at any time\n while in the Executing state using <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a>.\n <p>\n Call <a href=\"#!/api/android.media.MediaCodec-method-stop\" rel=\"android.media.MediaCodec-method-stop\" class=\"docClass\">stop</a> to return the codec to the Uninitialized state, whereupon it may be configured\n again. When you are done using a codec, you must release it by calling <a href=\"#!/api/android.media.MediaCodec-method-release\" rel=\"android.media.MediaCodec-method-release\" class=\"docClass\">release</a>.\n <p>\n On rare occasions the codec may encounter an error and move to the Error state. This is\n communicated using an invalid return value from a queuing operation, or sometimes via an\n exception. Call <a href=\"#!/api/android.media.MediaCodec-method-reset\" rel=\"android.media.MediaCodec-method-reset\" class=\"docClass\">reset</a> to make the codec usable again. You can call it from any state to\n move the codec back to the Uninitialized state. Otherwise, call <a href=\"#!/api/android.media.MediaCodec-method-release\" rel=\"android.media.MediaCodec-method-release\" class=\"docClass\">release</a> to move to the\n terminal Released state.</p>\n\n<p> <h3>Creation</h3>\n <p>\n Use <a href=\"#!/api/android.media.MediaCodecList\" rel=\"android.media.MediaCodecList\" class=\"docClass\">android.media.MediaCodecList</a> to create a MediaCodec for a specific <a href=\"#!/api/android.media.MediaFormat\" rel=\"android.media.MediaFormat\" class=\"docClass\">android.media.MediaFormat</a>. When\n decoding a file or a stream, you can get the desired format from <a href=\"#!/api/android.media.MediaExtractor-method-getTrackFormat\" rel=\"android.media.MediaExtractor-method-getTrackFormat\" class=\"docClass\">android.media.MediaExtractor.getTrackFormat</a>. Inject any specific features that\n you want to add using <a href=\"#!/api/android.media.MediaFormat-method-setFeatureEnabled\" rel=\"android.media.MediaFormat-method-setFeatureEnabled\" class=\"docClass\">android.media.MediaFormat.setFeatureEnabled</a>, then\n call <a href=\"#!/api/android.media.MediaCodecList-method-findDecoderForFormat\" rel=\"android.media.MediaCodecList-method-findDecoderForFormat\" class=\"docClass\">android.media.MediaCodecList.findDecoderForFormat</a> to get the\n name of a codec that can handle that specific media format. Finally, create the codec using\n <a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a>.\n <p class=note>\n <strong>Note:</strong> On android.os.Build.VERSION_CODES.LOLLIPOP, the format to\n {@code MediaCodecList.findDecoder}/{@code EncoderForFormat} must not contain a {@linkplain\n <a href=\"#!/api/android.media.MediaFormat-property-KEY_FRAME_RATE\" rel=\"android.media.MediaFormat-property-KEY_FRAME_RATE\" class=\"docClass\">android.media.MediaFormat.KEY_FRAME_RATE</a> frame rate}. Use\n <code class=prettyprint>format.setString(MediaFormat.KEY_FRAME_RATE, null)</code>\n to clear any existing frame rate setting in the format.\n <p>\n You can also create the preferred codec for a specific MIME type using <a href=\"#!/api/android.media.MediaCodec-method-createDecoderByType\" rel=\"android.media.MediaCodec-method-createDecoderByType\" class=\"docClass\">createDecoder</a>/<a href=\"#!/api/android.media.MediaCodec-method-createEncoderByType\" rel=\"android.media.MediaCodec-method-createEncoderByType\" class=\"docClass\">EncoderByType(String)</a>.\n This, however, cannot be used to inject features, and may create a codec that cannot handle the\n specific desired media format.</p>\n\n<p> <h4>Creating secure decoders</h4>\n <p>\n On versions android.os.Build.VERSION_CODES.KITKAT_WATCH and earlier, secure codecs might\n not be listed in <a href=\"#!/api/android.media.MediaCodecList\" rel=\"android.media.MediaCodecList\" class=\"docClass\">android.media.MediaCodecList</a>, but may still be available on the system. Secure codecs\n that exist can be instantiated by name only, by appending {@code \".secure\"} to the name of a\n regular codec (the name of all secure codecs must end in {@code \".secure\"}.) <a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a> will throw an {@code IOException} if the codec is not present on the system.\n <p>\n From android.os.Build.VERSION_CODES.LOLLIPOP onwards, you should use the <a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities-property-FEATURE_SecurePlayback\" rel=\"android.media.MediaCodecInfo.CodecCapabilities-property-FEATURE_SecurePlayback\" class=\"docClass\">android.media.MediaCodecInfo.CodecCapabilities.FEATURE_SecurePlayback</a> feature in the media format to create a secure decoder.</p>\n\n<p> <h3>Initialization</h3>\n <p>\n After creating the codec, you can set a callback using <a href=\"#!/api/android.media.MediaCodec-method-setCallback\" rel=\"android.media.MediaCodec-method-setCallback\" class=\"docClass\">setCallback</a> if you\n want to process data asynchronously. Then, {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a> configure} the codec using the\n specific media format. This is when you can specify the output Surface for video\n producers &ndash; codecs that generate raw video data (e.g. video decoders). This is also when\n you can set the decryption parameters for secure codecs (see <a href=\"#!/api/android.media.MediaCrypto\" rel=\"android.media.MediaCrypto\" class=\"docClass\">android.media.MediaCrypto</a>). Finally, since\n some codecs can operate in multiple modes, you must specify whether you want it to work as a\n decoder or an encoder.\n <p>\n Since android.os.Build.VERSION_CODES.LOLLIPOP, you can query the resulting input and\n output format in the Configured state. You can use this to verify the resulting configuration,\n e.g. color formats, before starting the codec.\n <p>\n If you want to process raw input video buffers natively with a video consumer &ndash; a codec\n that processes raw video input, such as a video encoder &ndash; create a destination Surface for\n your input data using <a href=\"#!/api/android.media.MediaCodec-method-createInputSurface\" rel=\"android.media.MediaCodec-method-createInputSurface\" class=\"docClass\">createInputSurface</a> after configuration. Alternately, set up the\n codec to use a previously created {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-createPersistentInputSurface\" rel=\"android.media.MediaCodec-method-createPersistentInputSurface\" class=\"docClass\">createPersistentInputSurface</a> persistent input\n surface} by calling <a href=\"#!/api/android.media.MediaCodec-method-setInputSurface\" rel=\"android.media.MediaCodec-method-setInputSurface\" class=\"docClass\">setInputSurface</a>.</p>\n\n<p> <h4 id=CSD><a name=\"CSD\"></a>Codec-specific Data</h4>\n <p>\n Some formats, notably AAC audio and MPEG4, H.264 and H.265 video formats require the actual data\n to be prefixed by a number of buffers containing setup data, or codec specific data. When\n processing such compressed formats, this data must be submitted to the codec after <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> and before any frame data. Such data must be marked using the flag <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a> in a call to <a href=\"#!/api/android.media.MediaCodec-method-queueInputBuffer\" rel=\"android.media.MediaCodec-method-queueInputBuffer\" class=\"docClass\">queueInputBuffer</a>.\n <p>\n Codec-specific data can also be included in the format passed to <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a> in\n ByteBuffer entries with keys \"csd-0\", \"csd-1\", etc. These keys are always included in the track\n <a href=\"#!/api/android.media.MediaFormat\" rel=\"android.media.MediaFormat\" class=\"docClass\">android.media.MediaFormat</a> obtained from the <a href=\"#!/api/android.media.MediaExtractor-method-getTrackFormat\" rel=\"android.media.MediaExtractor-method-getTrackFormat\" class=\"docClass\">android.media.MediaExtractor</a>.\n Codec-specific data in the format is automatically submitted to the codec upon <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a>;\n you <strong>MUST NOT</strong> submit this data explicitly. If the format did not contain codec\n specific data, you can choose to submit it using the specified number of buffers in the correct\n order, according to the format requirements. In case of H.264 AVC, you can also concatenate all\n codec-specific data and submit it as a single codec-config buffer.\n <p>\n Android uses the following codec-specific data buffers. These are also required to be set in\n the track format for proper <a href=\"#!/api/android.media.MediaMuxer\" rel=\"android.media.MediaMuxer\" class=\"docClass\">android.media.MediaMuxer</a> track configuration. Each parameter set and the\n codec-specific-data sections marked with (<sup><em></em></sup>) must start with a start code of\n {@code \"\\x00\\x00\\x00\\x01\"}.\n <p>\n <style>td.NA { background: #ccc; } .mid > tr > td { vertical-align: middle; }</style>\n <table>\n  <thead>\n   <th>Format</th>\n   <th>CSD buffer #0</th>\n   <th>CSD buffer #1</th>\n   <th>CSD buffer #2</th>\n  </thead>\n  <tbody class=mid>\n   <tr>\n    <td>AAC</td>\n    <td>Decoder-specific information from ESDS<sup></sup></td>\n    <td class=NA>Not Used</td>\n    <td class=NA>Not Used</td>\n   </tr>\n   <tr>\n    <td>VORBIS</td>\n    <td>Identification header</td>\n    <td>Setup header</td>\n    <td class=NA>Not Used</td>\n   </tr>\n   <tr>\n    <td>OPUS</td>\n    <td>Identification header</td>\n    <td>Pre-skip in nanosecs<br>\n        (unsigned 64-bit {@linkplain ByteOrder#nativeOrder native-order} integer.)<br>\n        This overrides the pre-skip value in the identification header.</td>\n    <td>Seek Pre-roll in nanosecs<br>\n        (unsigned 64-bit {@linkplain ByteOrder#nativeOrder native-order} integer.)</td>\n   </tr>\n   <tr>\n    <td>FLAC</td>\n    <td>mandatory metadata block (called the STREAMINFO block),<br>\n        optionally followed by any number of other metadata blocks</td>\n    <td class=NA>Not Used</td>\n    <td class=NA>Not Used</td>\n   </tr>\n   <tr>\n    <td>MPEG-4</td>\n    <td>Decoder-specific information from ESDS<sup><em></em></sup></td>\n    <td class=NA>Not Used</td>\n    <td class=NA>Not Used</td>\n   </tr>\n   <tr>\n    <td>H.264 AVC</td>\n    <td>SPS (Sequence Parameter Sets<sup></sup>)</td>\n    <td>PPS (Picture Parameter Sets<sup><em></em></sup>)</td>\n    <td class=NA>Not Used</td>\n   </tr>\n   <tr>\n    <td>H.265 HEVC</td>\n    <td>VPS (Video Parameter Sets<sup></sup>) +<br>\n     SPS (Sequence Parameter Sets<sup><em></em></sup>) +<br>\n     PPS (Picture Parameter Sets<sup></sup>)</td>\n    <td class=NA>Not Used</td>\n    <td class=NA>Not Used</td>\n   </tr>\n   <tr>\n    <td>VP9</td>\n    <td>VP9 <a href=\"http://wiki.webmproject.org/vp9-codecprivate\">CodecPrivate</a> Data\n        (optional)</td>\n    <td class=NA>Not Used</td>\n    <td class=NA>Not Used</td>\n   </tr>\n  </tbody>\n </table></p>\n\n<p> <p class=note>\n <strong>Note:</strong> care must be taken if the codec is flushed immediately or shortly\n after start, before any output buffer or output format change has been returned, as the codec\n specific data may be lost during the flush. You must resubmit the data using buffers marked with\n <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a> after such flush to ensure proper codec operation.\n <p>\n Encoders (or codecs that generate compressed data) will create and return the codec specific data\n before any valid output buffer in output buffers marked with the {@linkplain\n <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a> codec-config flag}. Buffers containing codec-specific-data have no\n meaningful timestamps.</p>\n\n<p> <h3>Data Processing</h3>\n <p>\n Each codec maintains a set of input and output buffers that are referred to by a buffer-ID in\n API calls. After a successful call to <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> the client \"owns\" neither input nor output\n buffers. In synchronous mode, call <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">OutputBuffer(&amp;hellip;)</a> to obtain (get ownership of) an input or output\n buffer from the codec. In asynchronous mode, you will automatically receive available buffers via\n the android.media.MediaCodec.Callback.onInput/<a href=\"#!/api/android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" class=\"docClass\">OutputBufferAvailable(&amp;hellip;)</a> callbacks.\n <p>\n Upon obtaining an input buffer, fill it with data and submit it to the codec using <a href=\"#!/api/android.media.MediaCodec-method-queueInputBuffer\" rel=\"android.media.MediaCodec-method-queueInputBuffer\" class=\"docClass\">queueInputBuffer</a> &ndash; or <a href=\"#!/api/android.media.MediaCodec-method-queueSecureInputBuffer\" rel=\"android.media.MediaCodec-method-queueSecureInputBuffer\" class=\"docClass\">queueSecureInputBuffer</a> if using decryption. Do not submit multiple input buffers with the same\n timestamp (unless it is <a href=\"#CSD\">codec-specific data</a> marked as such).\n <p>\n The codec in turn will return a read-only output buffer via the <a href=\"#!/api/android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" class=\"docClass\">onOutputBufferAvailable</a> callback in asynchronous mode, or in\n response to a <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a> call in synchronous mode. After the\n output buffer has been processed, call one of the <a href=\"#!/api/android.media.MediaCodec-method-releaseOutputBuffer\" rel=\"android.media.MediaCodec-method-releaseOutputBuffer\" class=\"docClass\">releaseOutputBuffer</a> methods to return the buffer to the codec.\n <p>\n While you are not required to resubmit/release buffers immediately to the codec, holding onto\n input and/or output buffers may stall the codec, and this behavior is device dependent.\n <strong>Specifically, it is possible that a codec may hold off on generating output buffers until\n <em>all</em> outstanding buffers have been released/resubmitted.</strong> Therefore, try to\n hold onto to available buffers as little as possible.\n <p>\n Depending on the API version, you can process data in three ways:\n <table>\n  <thead>\n   <tr>\n    <th>Processing Mode</th>\n    <th>API version &lt;= 20<br>Jelly Bean/KitKat</th>\n    <th>API version >= 21<br>Lollipop and later</th>\n   </tr>\n  </thead>\n  <tbody>\n   <tr>\n    <td>Synchronous API using buffer arrays</td>\n    <td>Supported</td>\n    <td>Deprecated</td>\n   </tr>\n   <tr>\n    <td>Synchronous API using buffers</td>\n    <td class=NA>Not Available</td>\n    <td>Supported</td>\n   </tr>\n   <tr>\n    <td>Asynchronous API using buffers</td>\n    <td class=NA>Not Available</td>\n    <td>Supported</td>\n   </tr>\n  </tbody>\n </table></p>\n\n<p> <h4>Asynchronous Processing using Buffers</h4>\n <p>\n Since android.os.Build.VERSION_CODES.LOLLIPOP, the preferred method is to process data\n asynchronously by setting a callback before calling <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a>. Asynchronous\n mode changes the state transitions slightly, because you must call <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> after <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> to transition the codec to the Running sub-state and start receiving input buffers.\n Similarly, upon an initial call to {@code start} the codec will move directly to the Running\n sub-state and start passing available input buffers via the callback.\n <p>\n <center><object style=\"width: 516px; height: 353px;\" type=\"image/svg+xml\"\n   data=\"../../../images/media/mediacodec_async_states.svg\"><img\n   src=\"../../../images/media/mediacodec_async_states.png\" style=\"width: 516px; height: 353px\"\n   alt=\"MediaCodec state diagram for asynchronous operation\"></object></center>\n <p>\n MediaCodec is typically used like this in asynchronous mode:\n <pre class=prettyprint>\n MediaCodec codec = MediaCodec.createByCodecName(name);\n MediaFormat mOutputFormat; // member variable\n codec.setCallback(new MediaCodec.Callback() {\n   {@literal @Override}\n   void onInputBufferAvailable(MediaCodec mc, int inputBufferId) {\n     ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);\n     // fill inputBuffer with valid data\n     &hellip;\n     codec.queueInputBuffer(inputBufferId, &hellip;);\n   }</pre></p>\n\n<p>   {@literal @Override}\n   void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, &hellip;) {\n     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);\n     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A\n     // bufferFormat is equivalent to mOutputFormat\n     // outputBuffer is ready to be processed or rendered.\n     &hellip;\n     codec.releaseOutputBuffer(outputBufferId, &hellip;);\n   }</p>\n\n<p>   {@literal @Override}\n   void onOutputFormatChanged(MediaCodec mc, MediaFormat format) {\n     // Subsequent data will conform to new format.\n     // Can ignore if using getOutputFormat(outputBufferId)\n     mOutputFormat = format; // option B\n   }</p>\n\n<p>   {@literal @Override}\n   void onError(&hellip;) {\n     &hellip;\n   }\n });\n codec.configure(format, &hellip;);\n mOutputFormat = codec.getOutputFormat(); // option B\n codec.start();\n // wait for processing to complete\n codec.stop();\n codec.release();</p>\n\n<p> <h4>Synchronous Processing using Buffers</h4>\n <p>\n Since android.os.Build.VERSION_CODES.LOLLIPOP, you should retrieve input and output\n buffers using <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffer\" rel=\"android.media.MediaCodec-method-getInputBuffer\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffer\" rel=\"android.media.MediaCodec-method-getOutputBuffer\" class=\"docClass\">OutputBuffer(int)</a> and/or\n <a href=\"#!/api/android.media.MediaCodec-method-getInputImage\" rel=\"android.media.MediaCodec-method-getInputImage\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputImage\" rel=\"android.media.MediaCodec-method-getOutputImage\" class=\"docClass\">OutputImage(int)</a> even when using the\n codec in synchronous mode. This allows certain optimizations by the framework, e.g. when\n processing dynamic content. This optimization is disabled if you call <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffers\" rel=\"android.media.MediaCodec-method-getInputBuffers\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">OutputBuffers()</a>.</p>\n\n<p> <p class=note>\n <strong>Note:</strong> do not mix the methods of using buffers and buffer arrays at the same\n time. Specifically, only call {@code getInput}/{@code OutputBuffers} directly after <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> or after having dequeued an output buffer ID with the value of <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED\" class=\"docClass\">INFO_OUTPUT_FORMAT_CHANGED</a>.\n <p>\n MediaCodec is typically used like this in synchronous mode:</p>\n\n<pre> MediaCodec codec = MediaCodec.createByCodecName(name);\n codec.configure(format, &hellip;);\n MediaFormat outputFormat = codec.getOutputFormat(); // option B\n codec.start();\n for (;;) {\n   int inputBufferId = codec.dequeueInputBuffer(timeoutUs);\n   if (inputBufferId &gt;= 0) {\n     ByteBuffer inputBuffer = codec.getInputBuffer(&hellip;);\n     // fill inputBuffer with valid data\n     &hellip;\n     codec.queueInputBuffer(inputBufferId, &hellip;);\n   }\n   int outputBufferId = codec.dequeueOutputBuffer(&hellip;);\n   if (outputBufferId &gt;= 0) {\n     ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);\n     MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A\n     // bufferFormat is identical to outputFormat\n     // outputBuffer is ready to be processed or rendered.\n     &hellip;\n     codec.releaseOutputBuffer(outputBufferId, &hellip;);\n   } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n     // Subsequent data will conform to new format.\n     // Can ignore if using getOutputFormat(outputBufferId)\n     outputFormat = codec.getOutputFormat(); // option B\n   }\n }\n codec.stop();\n codec.release();</pre>\n\n\n<p> <h4>Synchronous Processing using Buffer Arrays (deprecated)</h4>\n <p>\n In versions android.os.Build.VERSION_CODES.KITKAT_WATCH and before, the set of input and\n output buffers are represented by the {@code ByteBuffer[]} arrays. After a successful call to\n <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a>, retrieve the buffer arrays using <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffers\" rel=\"android.media.MediaCodec-method-getInputBuffers\" class=\"docClass\">getInput</a>/<a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">OutputBuffers()</a>. Use the buffer ID-s as indices into these arrays (when\n non-negative), as demonstrated in the sample below. Note that there is no inherent correlation\n between the size of the arrays and the number of input and output buffers used by the system,\n although the array size provides an upper bound.</p>\n\n<pre> MediaCodec codec = MediaCodec.createByCodecName(name);\n codec.configure(format, &hellip;);\n codec.start();\n ByteBuffer[] inputBuffers = codec.getInputBuffers();\n ByteBuffer[] outputBuffers = codec.getOutputBuffers();\n for (;;) {\n   int inputBufferId = codec.dequeueInputBuffer(&hellip;);\n   if (inputBufferId &gt;= 0) {\n     // fill inputBuffers[inputBufferId] with valid data\n     &hellip;\n     codec.queueInputBuffer(inputBufferId, &hellip;);\n   }\n   int outputBufferId = codec.dequeueOutputBuffer(&hellip;);\n   if (outputBufferId &gt;= 0) {\n     // outputBuffers[outputBufferId] is ready to be processed or rendered.\n     &hellip;\n     codec.releaseOutputBuffer(outputBufferId, &hellip;);\n   } else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n     outputBuffers = codec.getOutputBuffers();\n   } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n     // Subsequent data will conform to new format.\n     MediaFormat format = codec.getOutputFormat();\n   }\n }\n codec.stop();\n codec.release();</pre>\n\n\n<p> <h4>End-of-stream Handling</h4>\n <p>\n When you reach the end of the input data, you must signal it to the codec by specifying the\n <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" class=\"docClass\">BUFFER_FLAG_END_OF_STREAM</a> flag in the call to <a href=\"#!/api/android.media.MediaCodec-method-queueInputBuffer\" rel=\"android.media.MediaCodec-method-queueInputBuffer\" class=\"docClass\">queueInputBuffer</a>. You can do this on the last valid input buffer, or by submitting an additional\n empty input buffer with the end-of-stream flag set. If using an empty buffer, the timestamp will\n be ignored.\n <p>\n The codec will continue to return output buffers until it eventually signals the end of the\n output stream by specifying the same end-of-stream flag in the <a href=\"#!/api/android.media.MediaCodec.BufferInfo\" rel=\"android.media.MediaCodec.BufferInfo\" class=\"docClass\">android.media.MediaCodec.BufferInfo</a> set in <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a> or returned via <a href=\"#!/api/android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" class=\"docClass\">onOutputBufferAvailable</a>. This can be set on the last valid output buffer, or on an empty buffer\n after the last valid output buffer. The timestamp of such empty buffer should be ignored.\n <p>\n Do not submit additional input buffers after signaling the end of the input stream, unless the\n codec has been flushed, or stopped and restarted.</p>\n\n<p> <h4>Using an Output Surface</h4>\n <p>\n The data processing is nearly identical to the ByteBuffer mode when using an output Surface; however, the output buffers will not be accessible, and are represented as {@code null}\n values. E.g. <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffer\" rel=\"android.media.MediaCodec-method-getOutputBuffer\" class=\"docClass\">getOutputBuffer</a>/android.media.Image(int) will\n return {@code null} and <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">getOutputBuffers</a> will return an array containing only {@code\n null}-s.\n <p>\n When using an output Surface, you can select whether or not to render each output buffer on the\n surface. You have three choices:\n <ul>\n <li><strong>Do not render the buffer:</strong> Call boolean)\n releaseOutputBuffer(bufferId, false).</li>\n <li><strong>Render the buffer with the default timestamp:</strong> Call boolean) releaseOutputBuffer(bufferId, true).</li>\n <li><strong>Render the buffer with a specific timestamp:</strong> Call long) releaseOutputBuffer(bufferId, timestamp).</li>\n </ul>\n <p>\n Since android.os.Build.VERSION_CODES.M, the default timestamp is the {@linkplain\n <a href=\"#!/api/android.media.MediaCodec.BufferInfo-property-presentationTimeUs\" rel=\"android.media.MediaCodec.BufferInfo-property-presentationTimeUs\" class=\"docClass\">android.media.MediaCodec.BufferInfo.presentationTimeUs</a> presentation timestamp} of the buffer (converted to nanoseconds).\n It was not defined prior to that.\n <p>\n Also since android.os.Build.VERSION_CODES.M, you can change the output Surface\n dynamically using <a href=\"#!/api/android.media.MediaCodec-method-setOutputSurface\" rel=\"android.media.MediaCodec-method-setOutputSurface\" class=\"docClass\">setOutputSurface</a>.\n <p>\n When rendering output to a Surface, the Surface may be configured to drop excessive frames (that\n are not consumed by the Surface in a timely manner). Or it may be configured to not drop excessive\n frames. In the latter mode if the Surface is not consuming output frames fast enough, it will\n eventually block the decoder. Prior to android.os.Build.VERSION_CODES.Q the exact behavior\n was undefined, with the exception that View surfaces (SuerfaceView or TextureView) always dropped\n excessive frames. Since android.os.Build.VERSION_CODES.Q the default behavior is to drop\n excessive frames. Applications can opt out of this behavior for non-View surfaces (such as\n ImageReader or SurfaceTexture) by targeting SDK android.os.Build.VERSION_CODES.Q and\n setting the key {@code \"allow-frame-drop\"} to {@code 0} in their configure format.</p>\n\n<p> <h4>Transformations When Rendering onto Surface</h4></p>\n\n<p> If the codec is configured into Surface mode, any crop rectangle, {@linkplain\n <a href=\"#!/api/android.media.MediaFormat-property-KEY_ROTATION\" rel=\"android.media.MediaFormat-property-KEY_ROTATION\" class=\"docClass\">android.media.MediaFormat.KEY_ROTATION</a> rotation} and {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-setVideoScalingMode\" rel=\"android.media.MediaCodec-method-setVideoScalingMode\" class=\"docClass\">setVideoScalingMode</a> video scaling\n mode} will be automatically applied with one exception:\n <p class=note>\n Prior to the android.os.Build.VERSION_CODES.M release, software decoders may not\n have applied the rotation when being rendered onto a Surface. Unfortunately, there is no standard\n and simple way to identify software decoders, or if they apply the rotation other than by trying\n it out.\n <p>\n There are also some caveats.\n <p class=note>\n Note that the pixel aspect ratio is not considered when displaying the output onto the\n Surface. This means that if you are using <a href=\"#!/api/android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT\" rel=\"android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT\" class=\"docClass\">VIDEO_SCALING_MODE_SCALE_TO_FIT</a> mode, you\n must position the output Surface so that it has the proper final display aspect ratio. Conversely,\n you can only use <a href=\"#!/api/android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING\" rel=\"android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING\" class=\"docClass\">VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING</a> mode for content with\n square pixels (pixel aspect ratio or 1:1).\n <p class=note>\n Note also that as of android.os.Build.VERSION_CODES.N release, <a href=\"#!/api/android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING\" rel=\"android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING\" class=\"docClass\">VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING</a> mode may not work correctly for videos rotated\n by 90 or 270 degrees.\n <p class=note>\n When setting the video scaling mode, note that it must be reset after each time the output\n buffers change. Since the <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" class=\"docClass\">INFO_OUTPUT_BUFFERS_CHANGED</a> event is deprecated, you can\n do this after each time the output format changes.</p>\n\n<p> <h4>Using an Input Surface</h4>\n <p>\n When using an input Surface, there are no accessible input buffers, as buffers are automatically\n passed from the input surface to the codec. Calling <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a> will throw an {@code IllegalStateException}, and <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffers\" rel=\"android.media.MediaCodec-method-getInputBuffers\" class=\"docClass\">getInputBuffers</a>\n returns a bogus {@code ByteBuffer[]} array that <strong>MUST NOT</strong> be written into.\n <p>\n Call <a href=\"#!/api/android.media.MediaCodec-method-signalEndOfInputStream\" rel=\"android.media.MediaCodec-method-signalEndOfInputStream\" class=\"docClass\">signalEndOfInputStream</a> to signal end-of-stream. The input surface will stop\n submitting data to the codec immediately after this call.\n <p></p>\n\n<p> <h3>Seeking &amp; Adaptive Playback Support</h3>\n <p>\n Video decoders (and in general codecs that consume compressed video data) behave differently\n regarding seek and format change whether or not they support and are configured for adaptive\n playback. You can check if a decoder supports {@linkplain\n <a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities-property-FEATURE_AdaptivePlayback\" rel=\"android.media.MediaCodecInfo.CodecCapabilities-property-FEATURE_AdaptivePlayback\" class=\"docClass\">android.media.MediaCodecInfo.CodecCapabilities.FEATURE_AdaptivePlayback</a> adaptive playback} via <a href=\"#!/api/android.media.MediaCodecInfo.CodecCapabilities-method-isFeatureSupported\" rel=\"android.media.MediaCodecInfo.CodecCapabilities-method-isFeatureSupported\" class=\"docClass\">android.media.MediaCodecInfo.CodecCapabilities.isFeatureSupported(String)</a>. Adaptive\n playback support for video decoders is only activated if you configure the codec to decode onto a\n Surface.</p>\n\n<p> <h4 id=KeyFrames><a name=\"KeyFrames\"></a>Stream Boundary and Key Frames</h4>\n <p>\n It is important that the input data after <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> or <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> starts at a suitable\n stream boundary: the first frame must a key frame. A <em>key frame</em> can be decoded\n completely on its own (for most codecs this means an I-frame), and no frames that are to be\n displayed after a key frame refer to frames before the key frame.\n <p>\n The following table summarizes suitable key frames for various video formats.\n <table>\n  <thead>\n   <tr>\n    <th>Format</th>\n    <th>Suitable key frame</th>\n   </tr>\n  </thead>\n  <tbody class=mid>\n   <tr>\n    <td>VP9/VP8</td>\n    <td>a suitable intraframe where no subsequent frames refer to frames prior to this frame.<br>\n      <i>(There is no specific name for such key frame.)</i></td>\n   </tr>\n   <tr>\n    <td>H.265 HEVC</td>\n    <td>IDR or CRA</td>\n   </tr>\n   <tr>\n    <td>H.264 AVC</td>\n    <td>IDR</td>\n   </tr>\n   <tr>\n    <td>MPEG-4<br>H.263<br>MPEG-2</td>\n    <td>a suitable I-frame where no subsequent frames refer to frames prior to this frame.<br>\n      <i>(There is no specific name for such key frame.)</i></td>\n   </tr>\n  </tbody>\n </table></p>\n\n<p> <h4>For decoders that do not support adaptive playback (including when not decoding onto a\n Surface)</h4>\n <p>\n In order to start decoding data that is not adjacent to previously submitted data (i.e. after a\n seek) you <strong>MUST</strong> flush the decoder. Since all output buffers are immediately\n revoked at the point of the flush, you may want to first signal then wait for the end-of-stream\n before you call {@code flush}. It is important that the input data after a flush starts at a\n suitable stream boundary/key frame.\n <p class=note>\n <strong>Note:</strong> the format of the data submitted after a flush must not change; <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> does not support format discontinuities; for that, a full <a href=\"#!/api/android.media.MediaCodec-method-stop\" rel=\"android.media.MediaCodec-method-stop\" class=\"docClass\">stop</a> - <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure(&amp;hellip;)</a> - <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> cycle is necessary.</p>\n\n<p> <p class=note>\n <strong>Also note:</strong> if you flush the codec too soon after <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> &ndash;\n generally, before the first output buffer or output format change is received &ndash; you\n will need to resubmit the codec-specific-data to the codec. See the <a\n href=\"#CSD\">codec-specific-data section</a> for more info.</p>\n\n<p> <h4>For decoders that support and are configured for adaptive playback</h4>\n <p>\n In order to start decoding data that is not adjacent to previously submitted data (i.e. after a\n seek) it is <em>not necessary</em> to flush the decoder; however, input data after the\n discontinuity must start at a suitable stream boundary/key frame.\n <p>\n For some video formats - namely H.264, H.265, VP8 and VP9 - it is also possible to change the\n picture size or configuration mid-stream. To do this you must package the entire new\n codec-specific configuration data together with the key frame into a single buffer (including\n any start codes), and submit it as a <strong>regular</strong> input buffer.\n <p>\n You will receive an <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED\" class=\"docClass\">INFO_OUTPUT_FORMAT_CHANGED</a> return value from <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a> or a <a href=\"#!/api/android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" class=\"docClass\">onOutputFormatChanged</a> callback just after the picture-size change takes place and before any\n frames with the new size have been returned.\n <p class=note>\n <strong>Note:</strong> just as the case for codec-specific data, be careful when calling\n <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> shortly after you have changed the picture size. If you have not received\n confirmation of the picture size change, you will need to repeat the request for the new picture\n size.</p>\n\n<p> <h3>Error handling</h3>\n <p>\n The factory methods <a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a> and <a href=\"#!/api/android.media.MediaCodec-method-createDecoderByType\" rel=\"android.media.MediaCodec-method-createDecoderByType\" class=\"docClass\">createDecoder</a>/<a href=\"#!/api/android.media.MediaCodec-method-createEncoderByType\" rel=\"android.media.MediaCodec-method-createEncoderByType\" class=\"docClass\">EncoderByType</a> throw {@code IOException} on failure\n which you must catch or declare to pass up. MediaCodec methods throw {@code\n IllegalStateException} when the method is called from a codec state that does not allow it; this\n is typically due to incorrect application API usage. Methods involving secure buffers may throw\n <a href=\"#!/api/android.media.MediaCodec.CryptoException\" rel=\"android.media.MediaCodec.CryptoException\" class=\"docClass\">android.media.MediaCodec.CryptoException</a>, which has further error information obtainable from <a href=\"#!/api/android.media.MediaCodec.CryptoException-method-getErrorCode\" rel=\"android.media.MediaCodec.CryptoException-method-getErrorCode\" class=\"docClass\">android.media.MediaCodec.CryptoException.getErrorCode</a>.\n <p>\n Internal codec errors result in a <a href=\"#!/api/android.media.MediaCodec.CodecException\" rel=\"android.media.MediaCodec.CodecException\" class=\"docClass\">android.media.MediaCodec.CodecException</a>, which may be due to media content\n corruption, hardware failure, resource exhaustion, and so forth, even when the application is\n correctly using the API. The recommended action when receiving a {@code CodecException}\n can be determined by calling <a href=\"#!/api/android.media.MediaCodec.CodecException-method-isRecoverable\" rel=\"android.media.MediaCodec.CodecException-method-isRecoverable\" class=\"docClass\">android.media.MediaCodec.CodecException.isRecoverable</a> and <a href=\"#!/api/android.media.MediaCodec.CodecException-method-isTransient\" rel=\"android.media.MediaCodec.CodecException-method-isTransient\" class=\"docClass\">android.media.MediaCodec.CodecException.isTransient</a>:\n <ul>\n <li><strong>recoverable errors:</strong> If {@code isRecoverable()} returns true, then call\n <a href=\"#!/api/android.media.MediaCodec-method-stop\" rel=\"android.media.MediaCodec-method-stop\" class=\"docClass\">stop</a>, <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure(&amp;hellip;)</a>, and <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> to recover.</li>\n <li><strong>transient errors:</strong> If {@code isTransient()} returns true, then resources are\n temporarily unavailable and the method may be retried at a later time.</li>\n <li><strong>fatal errors:</strong> If both {@code isRecoverable()} and {@code isTransient()}\n return false, then the {@code CodecException} is fatal and the codec must be {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-reset\" rel=\"android.media.MediaCodec-method-reset\" class=\"docClass\">reset</a>\n reset} or {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-release\" rel=\"android.media.MediaCodec-method-release\" class=\"docClass\">release</a> released}.</li>\n </ul>\n <p>\n Both {@code isRecoverable()} and {@code isTransient()} do not return true at the same time.</p>\n\n<p> <h2 id=History><a name=\"History\"></a>Valid API Calls and API History</h2>\n <p>\n This sections summarizes the valid API calls in each state and the API history of the MediaCodec\n class. For API version numbers, see android.os.Build.VERSION_CODES.</p>\n\n<p> <style>\n .api > tr > th, .api > tr > td { text-align: center; padding: 4px 4px; }\n .api > tr > th     { vertical-align: bottom; }\n .api > tr > td     { vertical-align: middle; }\n .sml > tr > th, .sml > tr > td { text-align: center; padding: 2px 4px; }\n .fn { text-align: left; }\n .fn > code > a { font: 14px/19px Roboto Condensed, sans-serif; }\n .deg45 {\n   white-space: nowrap; background: none; border: none; vertical-align: bottom;\n   width: 30px; height: 83px;\n }\n .deg45 > div {\n   transform: skew(-45deg, 0deg) translate(1px, -67px);\n   transform-origin: bottom left 0;\n   width: 30px; height: 20px;\n }\n .deg45 > div > div { border: 1px solid #ddd; background: #999; height: 90px; width: 42px; }\n .deg45 > div > div > div { transform: skew(45deg, 0deg) translate(-55px, 55px) rotate(-45deg); }\n </style></p>\n\n<p> <table align=\"right\" style=\"width: 0%\">\n  <thead>\n   <tr><th>Symbol</th><th>Meaning</th></tr>\n  </thead>\n  <tbody class=sml>\n   <tr><td>&#9679;</td><td>Supported</td></tr>\n   <tr><td>&#8277;</td><td>Semantics changed</td></tr>\n   <tr><td>&#9675;</td><td>Experimental support</td></tr>\n   <tr><td>[ ]</td><td>Deprecated</td></tr>\n   <tr><td>&#9099;</td><td>Restricted to surface input mode</td></tr>\n   <tr><td>&#9094;</td><td>Restricted to surface output mode</td></tr>\n   <tr><td>&#9639;</td><td>Restricted to ByteBuffer input mode</td></tr>\n   <tr><td>&#8617;</td><td>Restricted to synchronous mode</td></tr>\n   <tr><td>&#8644;</td><td>Restricted to asynchronous mode</td></tr>\n   <tr><td>( )</td><td>Can be called, but shouldn't</td></tr>\n  </tbody>\n </table></p>\n\n<p> <table style=\"width: 100%;\">\n  <thead class=api>\n   <tr>\n    <th class=deg45><div><div style=\"background:#4285f4\"><div>Uninitialized</div></div></div></th>\n    <th class=deg45><div><div style=\"background:#f4b400\"><div>Configured</div></div></div></th>\n    <th class=deg45><div><div style=\"background:#e67c73\"><div>Flushed</div></div></div></th>\n    <th class=deg45><div><div style=\"background:#0f9d58\"><div>Running</div></div></div></th>\n    <th class=deg45><div><div style=\"background:#f7cb4d\"><div>End of Stream</div></div></div></th>\n    <th class=deg45><div><div style=\"background:#db4437\"><div>Error</div></div></div></th>\n    <th class=deg45><div><div style=\"background:#666\"><div>Released</div></div></div></th>\n    <th></th>\n    <th colspan=\"8\">SDK Version</th>\n   </tr>\n   <tr>\n    <th colspan=\"7\">State</th>\n    <th>Method</th>\n    <th>16</th>\n    <th>17</th>\n    <th>18</th>\n    <th>19</th>\n    <th>20</th>\n    <th>21</th>\n    <th>22</th>\n    <th>23</th>\n   </tr>\n  </thead>\n  <tbody class=api>\n   <tr>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-createDecoderByType\" rel=\"android.media.MediaCodec-method-createDecoderByType\" class=\"docClass\">createDecoderByType</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-createEncoderByType\" rel=\"android.media.MediaCodec-method-createEncoderByType\" class=\"docClass\">createEncoderByType</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-createPersistentInputSurface\" rel=\"android.media.MediaCodec-method-createPersistentInputSurface\" class=\"docClass\">createPersistentInputSurface</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#8277;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>18+</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-createInputSurface\" rel=\"android.media.MediaCodec-method-createInputSurface\" class=\"docClass\">createInputSurface</a></td>\n    <td></td>\n    <td></td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>(16+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9639;</td>\n    <td>&#9639;</td>\n    <td>&#9639;</td>\n    <td>&#8277;&#9639;&#8617;</td>\n    <td>&#9639;&#8617;</td>\n    <td>&#9639;&#8617;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#8277;&#8617;</td>\n    <td>&#8617;</td>\n    <td>&#8617;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getCodecInfo\" rel=\"android.media.MediaCodec-method-getCodecInfo\" class=\"docClass\">getCodecInfo</a></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>(21+)</td>\n    <td>21+</td>\n    <td>(21+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getInputBuffer\" rel=\"android.media.MediaCodec-method-getInputBuffer\" class=\"docClass\">getInputBuffer</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>(16+)</td>\n    <td>(16+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getInputBuffers\" rel=\"android.media.MediaCodec-method-getInputBuffers\" class=\"docClass\">getInputBuffers</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>[&#8277;&#8617;]</td>\n    <td>[&#8617;]</td>\n    <td>[&#8617;]</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>21+</td>\n    <td>(21+)</td>\n    <td>(21+)</td>\n    <td>(21+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getInputFormat\" rel=\"android.media.MediaCodec-method-getInputFormat\" class=\"docClass\">getInputFormat</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>(21+)</td>\n    <td>21+</td>\n    <td>(21+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getInputImage\" rel=\"android.media.MediaCodec-method-getInputImage\" class=\"docClass\">getInputImage</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9675;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getName\" rel=\"android.media.MediaCodec-method-getName\" class=\"docClass\">getName</a></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>(21+)</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffer\" rel=\"android.media.MediaCodec-method-getOutputBuffer\" class=\"docClass\">getOutputBuffer</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">getOutputBuffers</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>[&#8277;&#8617;]</td>\n    <td>[&#8617;]</td>\n    <td>[&#8617;]</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>21+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getOutputFormat\" rel=\"android.media.MediaCodec-method-getOutputFormat\" class=\"docClass\">getOutputFormat</a>()</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>(21+)</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getOutputFormat\" rel=\"android.media.MediaCodec-method-getOutputFormat\" class=\"docClass\">getOutputFormat</a>(int)</td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>(21+)</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-getOutputImage\" rel=\"android.media.MediaCodec-method-getOutputImage\" class=\"docClass\">getOutputImage</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9675;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>(16+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-queueInputBuffer\" rel=\"android.media.MediaCodec-method-queueInputBuffer\" class=\"docClass\">queueInputBuffer</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#8277;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>(16+)</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-queueSecureInputBuffer\" rel=\"android.media.MediaCodec-method-queueSecureInputBuffer\" class=\"docClass\">queueSecureInputBuffer</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#8277;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-release\" rel=\"android.media.MediaCodec-method-release\" class=\"docClass\">release</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn>boolean)</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#8277;</td>\n    <td>&#9679;</td>\n    <td>&#8277;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn>long)</td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n   </tr>\n   <tr>\n    <td>21+</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>21+</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-reset\" rel=\"android.media.MediaCodec-method-reset\" class=\"docClass\">reset</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>21+</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn>setCallback</td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>Handler) &#8277;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>23+</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-setInputSurface\" rel=\"android.media.MediaCodec-method-setInputSurface\" class=\"docClass\">setInputSurface</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9099;</td>\n   </tr>\n   <tr>\n    <td>23+</td>\n    <td>23+</td>\n    <td>23+</td>\n    <td>23+</td>\n    <td>23+</td>\n    <td>(23+)</td>\n    <td>(23+)</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-setOnFrameRenderedListener\" rel=\"android.media.MediaCodec-method-setOnFrameRenderedListener\" class=\"docClass\">setOnFrameRenderedListener</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9675; &#9094;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>23+</td>\n    <td>23+</td>\n    <td>23+</td>\n    <td>23+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-setOutputSurface\" rel=\"android.media.MediaCodec-method-setOutputSurface\" class=\"docClass\">setOutputSurface</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9094;</td>\n   </tr>\n   <tr>\n    <td>19+</td>\n    <td>19+</td>\n    <td>19+</td>\n    <td>19+</td>\n    <td>19+</td>\n    <td>(19+)</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-setParameters\" rel=\"android.media.MediaCodec-method-setParameters\" class=\"docClass\">setParameters</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>(16+)</td>\n    <td>(16+)</td>\n    <td>16+</td>\n    <td>(16+)</td>\n    <td>(16+)</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-setVideoScalingMode\" rel=\"android.media.MediaCodec-method-setVideoScalingMode\" class=\"docClass\">setVideoScalingMode</a></td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n    <td>&#9094;</td>\n   </tr>\n   <tr>\n    <td>(29+)</td>\n    <td>29+</td>\n    <td>29+</td>\n    <td>29+</td>\n    <td>(29+)</td>\n    <td>(29+)</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-setAudioPresentation\" rel=\"android.media.MediaCodec-method-setAudioPresentation\" class=\"docClass\">setAudioPresentation</a></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>18+</td>\n    <td>18+</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-signalEndOfInputStream\" rel=\"android.media.MediaCodec-method-signalEndOfInputStream\" class=\"docClass\">signalEndOfInputStream</a></td>\n    <td></td>\n    <td></td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n    <td>&#9099;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>16+</td>\n    <td>21+(&#8644;)</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#8277;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n   <tr>\n    <td>-</td>\n    <td>-</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>16+</td>\n    <td>-</td>\n    <td>-</td>\n    <td class=fn><a href=\"#!/api/android.media.MediaCodec-method-stop\" rel=\"android.media.MediaCodec-method-stop\" class=\"docClass\">stop</a></td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n    <td>&#9679;</td>\n   </tr>\n  </tbody>\n </table></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-BUFFER_FLAG_CODEC_CONFIG' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG' class='name expandable'>BUFFER_FLAG_CODEC_CONFIG</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>This indicated that the buffer marked as such contains codec\ninitialization / codec specific data instead of media data. ...</div><div class='long'><p>This indicated that the buffer marked as such contains codec\ninitialization / codec specific data instead of media data.</p>\n<p>Defaults to: <code>&quot;2&quot;</code></p></div></div></div><div id='property-BUFFER_FLAG_END_OF_STREAM' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-BUFFER_FLAG_END_OF_STREAM' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM' class='name expandable'>BUFFER_FLAG_END_OF_STREAM</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>This signals the end of stream, i.e. ...</div><div class='long'><p>This signals the end of stream, i.e. no buffers will be available\nafter this, unless of course, <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> follows.</p>\n<p>Defaults to: <code>&quot;4&quot;</code></p></div></div></div><div id='property-BUFFER_FLAG_KEY_FRAME' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-BUFFER_FLAG_KEY_FRAME' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME' class='name expandable'>BUFFER_FLAG_KEY_FRAME</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>This indicates that the (encoded) buffer marked as such contains\nthe data for a key frame. ...</div><div class='long'><p>This indicates that the (encoded) buffer marked as such contains\nthe data for a key frame.</p>\n<p>Defaults to: <code>&quot;1&quot;</code></p></div></div></div><div id='property-BUFFER_FLAG_PARTIAL_FRAME' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-BUFFER_FLAG_PARTIAL_FRAME' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-BUFFER_FLAG_PARTIAL_FRAME' class='name expandable'>BUFFER_FLAG_PARTIAL_FRAME</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>This indicates that the buffer only contains part of a frame,\nand the decoder should batch the data until a buffer wi...</div><div class='long'><p>This indicates that the buffer only contains part of a frame,\nand the decoder should batch the data until a buffer without\nthis flag appears before decoding the frame.</p>\n<p>Defaults to: <code>&quot;8&quot;</code></p></div></div></div><div id='property-BUFFER_FLAG_SYNC_FRAME' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-BUFFER_FLAG_SYNC_FRAME' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-BUFFER_FLAG_SYNC_FRAME' class='name expandable'>BUFFER_FLAG_SYNC_FRAME</a> : String<span class=\"signature\"><span class='deprecated' >deprecated</span></span></div><div class='description'><div class='short'>This indicates that the (encoded) buffer marked as such contains\nthe data for a key frame. ...</div><div class='long'><p>This indicates that the (encoded) buffer marked as such contains\nthe data for a key frame.</p>\n<p>Defaults to: <code>&quot;1&quot;</code></p>        <div class='rounded-box deprecated-box deprecated-tag-box'>\n        <p>This property has been <strong>deprecated</strong> </p>\n        <p>Use <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" class=\"docClass\">BUFFER_FLAG_KEY_FRAME</a> instead.</p>\n\n        </div>\n</div></div></div><div id='property-CONFIGURE_FLAG_ENCODE' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-CONFIGURE_FLAG_ENCODE' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-CONFIGURE_FLAG_ENCODE' class='name expandable'>CONFIGURE_FLAG_ENCODE</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>If this codec is to be used as an encoder, pass this flag. ...</div><div class='long'><p>If this codec is to be used as an encoder, pass this flag.</p>\n<p>Defaults to: <code>&quot;1&quot;</code></p></div></div></div><div id='property-CRYPTO_MODE_AES_CBC' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-CRYPTO_MODE_AES_CBC' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-CRYPTO_MODE_AES_CBC' class='name expandable'>CRYPTO_MODE_AES_CBC</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n<p>Defaults to: <code>&quot;2&quot;</code></p></div></div></div><div id='property-CRYPTO_MODE_AES_CTR' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-CRYPTO_MODE_AES_CTR' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-CRYPTO_MODE_AES_CTR' class='name expandable'>CRYPTO_MODE_AES_CTR</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n<p>Defaults to: <code>&quot;1&quot;</code></p></div></div></div><div id='property-CRYPTO_MODE_UNENCRYPTED' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-CRYPTO_MODE_UNENCRYPTED' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-CRYPTO_MODE_UNENCRYPTED' class='name expandable'>CRYPTO_MODE_UNENCRYPTED</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n<p>Defaults to: <code>&quot;0&quot;</code></p></div></div></div><div id='property-INFO_OUTPUT_BUFFERS_CHANGED' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED' class='name expandable'>INFO_OUTPUT_BUFFERS_CHANGED</a> : String<span class=\"signature\"><span class='deprecated' >deprecated</span></span></div><div class='description'><div class='short'>The output buffers have changed, the client must refer to the new\nset of output buffers returned by getOutputBuffers ...</div><div class='long'><p>The output buffers have changed, the client must refer to the new\nset of output buffers returned by <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">getOutputBuffers</a> from\nthis point on.</p>\n\n<p>Additionally, this event signals that the video scaling mode\nmay have been reset to the default.</p>\n\n<p>Defaults to: <code>&quot;-3&quot;</code></p>        <div class='rounded-box deprecated-box deprecated-tag-box'>\n        <p>This property has been <strong>deprecated</strong> </p>\n        <p>This return value can be ignored as <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffers\" rel=\"android.media.MediaCodec-method-getOutputBuffers\" class=\"docClass\">getOutputBuffers</a> has been deprecated.  Client should\nrequest a current buffer using on of the get-buffer or\nget-image methods each time one has been dequeued.</p>\n\n        </div>\n</div></div></div><div id='property-INFO_OUTPUT_FORMAT_CHANGED' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED' class='name expandable'>INFO_OUTPUT_FORMAT_CHANGED</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The output format has changed, subsequent data will follow the new\nformat. ...</div><div class='long'><p>The output format has changed, subsequent data will follow the new\nformat. <a href=\"#!/api/android.media.MediaCodec-method-getOutputFormat\" rel=\"android.media.MediaCodec-method-getOutputFormat\" class=\"docClass\">getOutputFormat</a>() returns the new format.  Note, that\nyou can also use the new <a href=\"#!/api/android.media.MediaCodec-method-getOutputFormat\" rel=\"android.media.MediaCodec-method-getOutputFormat\" class=\"docClass\">getOutputFormat</a>(int) method to\nget the format for a specific output buffer.  This frees you from\nhaving to track output format changes.</p>\n<p>Defaults to: <code>&quot;-2&quot;</code></p></div></div></div><div id='property-INFO_TRY_AGAIN_LATER' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-INFO_TRY_AGAIN_LATER' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-INFO_TRY_AGAIN_LATER' class='name expandable'>INFO_TRY_AGAIN_LATER</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>If a non-negative timeout had been specified in the call\nto dequeueOutputBuffer, indicates that the call timed out. ...</div><div class='long'><p>If a non-negative timeout had been specified in the call\nto <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a>, indicates that the call timed out.</p>\n<p>Defaults to: <code>&quot;-1&quot;</code></p></div></div></div><div id='property-PARAMETER_KEY_HDR10_PLUS_INFO' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-PARAMETER_KEY_HDR10_PLUS_INFO' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-PARAMETER_KEY_HDR10_PLUS_INFO' class='name expandable'>PARAMETER_KEY_HDR10_PLUS_INFO</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Set the HDR10+ metadata on the next queued input frame. ...</div><div class='long'><p>Set the HDR10+ metadata on the next queued input frame.</p>\n\n<p>Provide a byte array of data that's conforming to the\nuser_data_registered_itu_t_t35() syntax of SEI message for ST 2094-40.</p>\n\n<p><p>\nFor decoders:\n<p>\nWhen a decoder is configured for one of the HDR10+ profiles that uses\nout-of-band metadata (such as <a href=\"#!/api/android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile2HDR10Plus\" rel=\"android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile2HDR10Plus\" class=\"docClass\">android.media.MediaCodecInfo.CodecProfileLevel.VP9Profile2HDR10Plus</a> or <a href=\"#!/api/android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile3HDR10Plus\" rel=\"android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile3HDR10Plus\" class=\"docClass\">android.media.MediaCodecInfo.CodecProfileLevel.VP9Profile3HDR10Plus</a>), this\nparameter sets the HDR10+ metadata on the next input buffer queued\nto the decoder. A decoder supporting these profiles must propagate\nthe metadata to the format of the output buffer corresponding to this\nparticular input buffer (under key <a href=\"#!/api/android.media.MediaFormat-property-KEY_HDR10_PLUS_INFO\" rel=\"android.media.MediaFormat-property-KEY_HDR10_PLUS_INFO\" class=\"docClass\">android.media.MediaFormat.KEY_HDR10_PLUS_INFO</a>).\nThe metadata should be applied to that output buffer and the buffers\nfollowing it (in display order), until the next output buffer (in\ndisplay order) upon which an HDR10+ metadata is set.\n<p>\nThis parameter shouldn't be set if the decoder is not configured for\nan HDR10+ profile that uses out-of-band metadata. In particular,\nit shouldn't be set for HDR10+ profiles that uses in-band metadata\nwhere the metadata is embedded in the input buffers, for example\n<a href=\"#!/api/android.media.MediaCodecInfo.CodecProfileLevel-property-HEVCProfileMain10HDR10Plus\" rel=\"android.media.MediaCodecInfo.CodecProfileLevel-property-HEVCProfileMain10HDR10Plus\" class=\"docClass\">android.media.MediaCodecInfo.CodecProfileLevel.HEVCProfileMain10HDR10Plus</a>.\n<p>\nFor encoders:\n<p>\nWhen an encoder is configured for one of the HDR10+ profiles and the\noperates in byte buffer input mode (instead of surface input mode),\nthis parameter sets the HDR10+ metadata on the next input buffer queued\nto the encoder. For the HDR10+ profiles that uses out-of-band metadata\n(such as <a href=\"#!/api/android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile2HDR10Plus\" rel=\"android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile2HDR10Plus\" class=\"docClass\">android.media.MediaCodecInfo.CodecProfileLevel.VP9Profile2HDR10Plus</a>,\nor <a href=\"#!/api/android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile3HDR10Plus\" rel=\"android.media.MediaCodecInfo.CodecProfileLevel-property-VP9Profile3HDR10Plus\" class=\"docClass\">android.media.MediaCodecInfo.CodecProfileLevel.VP9Profile3HDR10Plus</a>),\nthe metadata must be propagated to the format of the output buffer\ncorresponding to this particular input buffer (under key <a href=\"#!/api/android.media.MediaFormat-property-KEY_HDR10_PLUS_INFO\" rel=\"android.media.MediaFormat-property-KEY_HDR10_PLUS_INFO\" class=\"docClass\">android.media.MediaFormat.KEY_HDR10_PLUS_INFO</a>). For the HDR10+ profiles that uses\nin-band metadata (such as <a href=\"#!/api/android.media.MediaCodecInfo.CodecProfileLevel-property-HEVCProfileMain10HDR10Plus\" rel=\"android.media.MediaCodecInfo.CodecProfileLevel-property-HEVCProfileMain10HDR10Plus\" class=\"docClass\">android.media.MediaCodecInfo.CodecProfileLevel.HEVCProfileMain10HDR10Plus</a>), the\nmetadata info must be embedded in the corresponding output buffer itself.\n<p>\nThis parameter shouldn't be set if the encoder is not configured for\nan HDR10+ profile, or if it's operating in surface input mode.\n<p></p>\n\n<p>@see MediaFormat#KEY_HDR10_PLUS_INFO</p>\n<p>Defaults to: <code>&quot;hdr10-plus-info&quot;</code></p></div></div></div><div id='property-PARAMETER_KEY_OFFSET_TIME' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-PARAMETER_KEY_OFFSET_TIME' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-PARAMETER_KEY_OFFSET_TIME' class='name expandable'>PARAMETER_KEY_OFFSET_TIME</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Specify an offset (in micro-second) to be added on top of the timestamps\nonward. ...</div><div class='long'><p>Specify an offset (in micro-second) to be added on top of the timestamps\nonward. A typical use case is to apply an adjust to the timestamps after\na period of pause by the user.</p>\n\n<p>This parameter can only be used on an encoder in \"surface-input\" mode.</p>\n\n<p>The value is a long int, indicating the timestamp offset to be applied.</p>\n\n<p>@see <a href=\"#!/api/android.media.MediaCodec-method-setParameters\" rel=\"android.media.MediaCodec-method-setParameters\" class=\"docClass\">setParameters</a>(Bundle)</p>\n<p>Defaults to: <code>&quot;time-offset-us&quot;</code></p></div></div></div><div id='property-PARAMETER_KEY_REQUEST_SYNC_FRAME' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-PARAMETER_KEY_REQUEST_SYNC_FRAME' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-PARAMETER_KEY_REQUEST_SYNC_FRAME' class='name expandable'>PARAMETER_KEY_REQUEST_SYNC_FRAME</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Request that the encoder produce a sync frame \"soon\". ...</div><div class='long'><p>Request that the encoder produce a sync frame \"soon\".\nProvide an Integer with the value 0.</p>\n\n<p>@see <a href=\"#!/api/android.media.MediaCodec-method-setParameters\" rel=\"android.media.MediaCodec-method-setParameters\" class=\"docClass\">setParameters</a>(Bundle)</p>\n<p>Defaults to: <code>&quot;request-sync&quot;</code></p></div></div></div><div id='property-PARAMETER_KEY_SUSPEND' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-PARAMETER_KEY_SUSPEND' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-PARAMETER_KEY_SUSPEND' class='name expandable'>PARAMETER_KEY_SUSPEND</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Temporarily suspend/resume encoding of input data. ...</div><div class='long'><p>Temporarily suspend/resume encoding of input data. While suspended\ninput data is effectively discarded instead of being fed into the\nencoder. This parameter really only makes sense to use with an encoder\nin \"surface-input\" mode, as the client code has no control over the\ninput-side of the encoder in that case.\nThe value is an Integer object containing the value 1 to suspend\nor the value 0 to resume.</p>\n\n<p>@see <a href=\"#!/api/android.media.MediaCodec-method-setParameters\" rel=\"android.media.MediaCodec-method-setParameters\" class=\"docClass\">setParameters</a>(Bundle)</p>\n<p>Defaults to: <code>&quot;drop-input-frames&quot;</code></p></div></div></div><div id='property-PARAMETER_KEY_SUSPEND_TIME' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-PARAMETER_KEY_SUSPEND_TIME' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-PARAMETER_KEY_SUSPEND_TIME' class='name expandable'>PARAMETER_KEY_SUSPEND_TIME</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>When PARAMETER_KEY_SUSPEND is present, the client can also\noptionally use this key to specify the timestamp (in micro...</div><div class='long'><p>When <a href=\"#!/api/android.media.MediaCodec-property-PARAMETER_KEY_SUSPEND\" rel=\"android.media.MediaCodec-property-PARAMETER_KEY_SUSPEND\" class=\"docClass\">PARAMETER_KEY_SUSPEND</a> is present, the client can also\noptionally use this key to specify the timestamp (in micro-second)\nat which the suspend/resume operation takes effect.</p>\n\n<p>Note that the specified timestamp must be greater than or equal to the\ntimestamp of any previously queued suspend/resume operations.</p>\n\n<p>The value is a long int, indicating the timestamp to suspend/resume.</p>\n\n<p>@see <a href=\"#!/api/android.media.MediaCodec-method-setParameters\" rel=\"android.media.MediaCodec-method-setParameters\" class=\"docClass\">setParameters</a>(Bundle)</p>\n<p>Defaults to: <code>&quot;drop-start-time-us&quot;</code></p></div></div></div><div id='property-PARAMETER_KEY_VIDEO_BITRATE' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-PARAMETER_KEY_VIDEO_BITRATE' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-PARAMETER_KEY_VIDEO_BITRATE' class='name expandable'>PARAMETER_KEY_VIDEO_BITRATE</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Change a video encoder's target bitrate on the fly. ...</div><div class='long'><p>Change a video encoder's target bitrate on the fly. The value is an\nInteger object containing the new bitrate in bps.</p>\n\n<p>@see <a href=\"#!/api/android.media.MediaCodec-method-setParameters\" rel=\"android.media.MediaCodec-method-setParameters\" class=\"docClass\">setParameters</a>(Bundle)</p>\n<p>Defaults to: <code>&quot;video-bitrate&quot;</code></p></div></div></div><div id='property-VIDEO_SCALING_MODE_SCALE_TO_FIT' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT' class='name expandable'>VIDEO_SCALING_MODE_SCALE_TO_FIT</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The content is scaled to the surface dimensions ...</div><div class='long'><p>The content is scaled to the surface dimensions</p>\n<p>Defaults to: <code>&quot;1&quot;</code></p></div></div></div><div id='property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING' class='name expandable'>VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING</a> : String<span class=\"signature\"></span></div><div class='description'><div class='short'>The content is scaled, maintaining its aspect ratio, the whole\nsurface area is used, content may be cropped. ...</div><div class='long'><p>The content is scaled, maintaining its aspect ratio, the whole\nsurface area is used, content may be cropped.</p>\n\n<p><p class=note>\nThis mode is only suitable for content with 1:1 pixel aspect ratio as you cannot\nconfigure the pixel aspect ratio for a Surface.\n<p class=note>\nAs of android.os.Build.VERSION_CODES.N release, this mode may not work if\nthe video is {@linkplain <a href=\"#!/api/android.media.MediaFormat-property-KEY_ROTATION\" rel=\"android.media.MediaFormat-property-KEY_ROTATION\" class=\"docClass\">android.media.MediaFormat.KEY_ROTATION</a> rotated} by 90 or 270 degrees.</p>\n<p>Defaults to: <code>&quot;2&quot;</code></p></div></div></div></div></div><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-configure' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-configure' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-configure' class='name expandable'>configure</a>( <span class='pre'>format, surface, flags, descrambler</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Configure a component to be used with a descrambler. ...</div><div class='long'><p>Configure a component to be used with a descrambler.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>format</span> : Object {MediaFormat}<div class='sub-desc'><p>The format of the input data (decoder) or the desired\n               format of the output data (encoder). Passing {@code null}\n               as {@code format} is equivalent to passing an\n               an empty mediaformat.</p>\n</div></li><li><span class='pre'>surface</span> : Object {Surface}<div class='sub-desc'><p>Specify a surface on which to render the output of this\n                decoder. Pass {@code null} as {@code surface} if the\n                codec does not generate raw video output (e.g. not a video\n                decoder) and/or if you want to configure the codec for\n                ByteBuffer output.</p>\n</div></li><li><span class='pre'>flags</span> : Number<div class='sub-desc'><p>Specify <a href=\"#!/api/android.media.MediaCodec-property-CONFIGURE_FLAG_ENCODE\" rel=\"android.media.MediaCodec-property-CONFIGURE_FLAG_ENCODE\" class=\"docClass\">CONFIGURE_FLAG_ENCODE</a> to configure the\n                component as an encoder.</p>\n</div></li><li><span class='pre'>descrambler</span> : Object {MediaDescrambler}<div class='sub-desc'><p>Specify a descrambler object to facilitate secure\n                descrambling of the media data, or null for non-secure codecs.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the surface has been released (or is invalid),\n or the format is unacceptable (e.g. missing a mandatory key),\n or the flags are not set properly\n (e.g. missing <a href=\"#!/api/android.media.MediaCodec-property-CONFIGURE_FLAG_ENCODE\" rel=\"android.media.MediaCodec-property-CONFIGURE_FLAG_ENCODE\" class=\"docClass\">CONFIGURE_FLAG_ENCODE</a> for an encoder).</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Uninitialized state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>CryptoException upon DRM error.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-createByCodecName' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-createByCodecName' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-createByCodecName' class='name expandable'>createByCodecName</a>( <span class='pre'>name</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>If you know the exact name of the component you want to instantiate\n use this method to instantiate it. ...</div><div class='long'><p>If you know the exact name of the component you want to instantiate\n use this method to instantiate it. Use with caution.\n Likely to be used with information obtained from <a href=\"#!/api/android.media.MediaCodecList\" rel=\"android.media.MediaCodecList\" class=\"docClass\">android.media.MediaCodecList</a></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>name</span> : String<div class='sub-desc'><p>The name of the codec to be instantiated.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException if the codec cannot be created.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if name is not valid.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if name is null.</p>\n</div></li></ul></div></div></div><div id='method-createDecoderByType' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-createDecoderByType' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-createDecoderByType' class='name expandable'>createDecoderByType</a>( <span class='pre'>type</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Instantiate the preferred decoder supporting input data of the given mime type. ...</div><div class='long'><p>Instantiate the preferred decoder supporting input data of the given mime type.</p>\n\n<p> The following is a partial list of defined mime types and their semantics:\n <ul>\n <li>\"video/x-vnd.on2.vp8\" - VP8 video (i.e. video in .webm)\n <li>\"video/x-vnd.on2.vp9\" - VP9 video (i.e. video in .webm)\n <li>\"video/avc\" - H.264/AVC video\n <li>\"video/hevc\" - H.265/HEVC video\n <li>\"video/mp4v-es\" - MPEG4 video\n <li>\"video/3gpp\" - H.263 video\n <li>\"audio/3gpp\" - AMR narrowband audio\n <li>\"audio/amr-wb\" - AMR wideband audio\n <li>\"audio/mpeg\" - MPEG1/2 audio layer III\n <li>\"audio/mp4a-latm\" - AAC audio (note, this is raw AAC packets, not packaged in LATM!)\n <li>\"audio/vorbis\" - vorbis audio\n <li>\"audio/g711-alaw\" - G.711 alaw audio\n <li>\"audio/g711-mlaw\" - G.711 ulaw audio\n </li></li></li></li></li></li></li></li></li></li></li></li></li></ul></p>\n\n<p> <strong>Note:</strong> It is preferred to use <a href=\"#!/api/android.media.MediaCodecList-method-findDecoderForFormat\" rel=\"android.media.MediaCodecList-method-findDecoderForFormat\" class=\"docClass\">android.media.MediaCodecList.findDecoderForFormat</a>\n and <a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a> to ensure that the resulting codec can handle a\n given format.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>type</span> : String<div class='sub-desc'><p>The mime type of the input data.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException if the codec cannot be created.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if type is not a valid mime type.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if type is null.</p>\n</div></li></ul></div></div></div><div id='method-createEncoderByType' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-createEncoderByType' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-createEncoderByType' class='name expandable'>createEncoderByType</a>( <span class='pre'>type</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Instantiate the preferred encoder supporting output data of the given mime type. ...</div><div class='long'><p>Instantiate the preferred encoder supporting output data of the given mime type.</p>\n\n<p> <strong>Note:</strong> It is preferred to use <a href=\"#!/api/android.media.MediaCodecList-method-findEncoderForFormat\" rel=\"android.media.MediaCodecList-method-findEncoderForFormat\" class=\"docClass\">android.media.MediaCodecList.findEncoderForFormat</a>\n and <a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a> to ensure that the resulting codec can handle a\n given format.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>type</span> : String<div class='sub-desc'><p>The desired mime type of the output data.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IOException if the codec cannot be created.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if type is not a valid mime type.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if type is null.</p>\n</div></li></ul></div></div></div><div id='method-createInputSurface' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-createInputSurface' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-createInputSurface' class='name expandable'>createInputSurface</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Requests a Surface to use as the input to an encoder, in place of input buffers. ...</div><div class='long'><p>Requests a Surface to use as the input to an encoder, in place of input buffers.  This\n may only be called after <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a> and before <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a>.\n <p>\n The application is responsible for calling release() on the Surface when\n done.\n <p>\n The Surface must be rendered with a hardware-accelerated API, such as OpenGL ES.\n android.view.Surface.lockCanvas(android.graphics.Rect) may fail or produce\n unexpected results.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Configured state.</p>\n</div></li></ul></div></div></div><div id='method-createPersistentInputSurface' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-createPersistentInputSurface' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-createPersistentInputSurface' class='name expandable'>createPersistentInputSurface</a>( <span class='pre'></span> ) : Object {android.view.Surface}<span class=\"signature\"></span></div><div class='description'><div class='short'>Create a persistent input surface that can be used with codecs that normally have an input\n surface, such as video en...</div><div class='long'><p>Create a persistent input surface that can be used with codecs that normally have an input\n surface, such as video encoders. A persistent input can be reused by subsequent\n <a href=\"#!/api/android.media.MediaCodec\" rel=\"android.media.MediaCodec\" class=\"docClass\">android.media.MediaCodec</a> or <a href=\"#!/api/android.media.MediaRecorder\" rel=\"android.media.MediaRecorder\" class=\"docClass\">android.media.MediaRecorder</a> instances, but can only be used by at\n most one codec or recorder instance concurrently.\n <p>\n The application is responsible for calling release() on the Surface when done.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {android.view.Surface}</span><div class='sub-desc'><p>an input surface that can be used with <a href=\"#!/api/android.media.MediaCodec-method-setInputSurface\" rel=\"android.media.MediaCodec-method-setInputSurface\" class=\"docClass\">setInputSurface</a>.</p>\n</div></li></ul></div></div></div><div id='method-dequeueInputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-dequeueInputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-dequeueInputBuffer' class='name expandable'>dequeueInputBuffer</a>( <span class='pre'>timeoutUs</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the index of an input buffer to be filled with valid data\n or -1 if no such buffer is currently available. ...</div><div class='long'><p>Returns the index of an input buffer to be filled with valid data\n or -1 if no such buffer is currently available.\n This method will return immediately if timeoutUs == 0, wait indefinitely\n for the availability of an input buffer if timeoutUs &lt; 0 or wait up\n to \"timeoutUs\" microseconds if timeoutUs &gt; 0.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>timeoutUs</span> : Number<div class='sub-desc'><p>The timeout in microseconds, a negative timeout indicates \"infinite\".</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state,\n         or codec is configured in asynchronous mode.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-dequeueOutputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-dequeueOutputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-dequeueOutputBuffer' class='name expandable'>dequeueOutputBuffer</a>( <span class='pre'>info, timeoutUs</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Dequeue an output buffer, block at most \"timeoutUs\" microseconds. ...</div><div class='long'><p>Dequeue an output buffer, block at most \"timeoutUs\" microseconds.\n Returns the index of an output buffer that has been successfully\n decoded or one of the INFO_* constants.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>info</span> : Object {MediaCodec.BufferInfo}<div class='sub-desc'><p>Will be filled with buffer meta data.</p>\n</div></li><li><span class='pre'>timeoutUs</span> : Number<div class='sub-desc'><p>The timeout in microseconds, a negative timeout indicates \"infinite\".</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state,\n         or codec is configured in asynchronous mode.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-flush' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-flush' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-flush' class='name expandable'>flush</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Flush both input and output ports of the component. ...</div><div class='long'><p>Flush both input and output ports of the component.\n <p>\n Upon return, all indices previously returned in calls to <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a> and <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a> &mdash; or obtained\n via <a href=\"#!/api/android.media.MediaCodec.Callback-method-onInputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onInputBufferAvailable\" class=\"docClass\">onInputBufferAvailable</a> or\n <a href=\"#!/api/android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" class=\"docClass\">onOutputBufferAvailable</a> callbacks &mdash; become\n invalid, and all buffers are owned by the codec.\n <p>\n If the codec is configured in asynchronous mode, call <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a>\n after {@code flush} has returned to resume codec operations. The codec\n will not request input buffers until this has happened.\n <strong>Note, however, that there may still be outstanding {@code onOutputBufferAvailable}\n callbacks that were not handled prior to calling {@code flush}.\n The indices returned via these callbacks also become invalid upon calling {@code flush} and\n should be discarded.</strong>\n <p>\n If the codec is configured in synchronous mode, codec will resume\n automatically if it is configured with an input surface.  Otherwise, it\n will resume when <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a> is called.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getCanonicalName' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getCanonicalName' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getCanonicalName' class='name expandable'>getCanonicalName</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Retrieve the underlying codec name. ...</div><div class='long'><p>Retrieve the underlying codec name.</p>\n\n<p> This method is similar to <a href=\"#!/api/android.media.MediaCodec-method-getName\" rel=\"android.media.MediaCodec-method-getName\" class=\"docClass\">getName</a>, except that it returns the underlying component\n name even if an alias was used to create this MediaCodec object by name,</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div><div id='method-getCodecInfo' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getCodecInfo' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getCodecInfo' class='name expandable'>getCodecInfo</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Get the codec info. ...</div><div class='long'><p>Get the codec info. If the codec was created by createDecoderByType\n or createEncoderByType, what component is chosen is not known beforehand,\n and thus the caller does not have the MediaCodecInfo.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div><div id='method-getInputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getInputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getInputBuffer' class='name expandable'>getInputBuffer</a>( <span class='pre'>index</span> ) : Object {java.nio.ByteBuffer}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a cleared, writable ByteBuffer\n object for a dequeued input buffer index to contain the input data. ...</div><div class='long'><p>Returns a cleared, writable ByteBuffer\n object for a dequeued input buffer index to contain the input data.</p>\n\n<p> After calling this method any ByteBuffer or Image object\n previously returned for the same input index MUST no longer\n be used.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned input buffer previously\n              returned from a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a>,\n              or received via an onInputBufferAvailable callback.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.nio.ByteBuffer}</span><div class='sub-desc'><p>the input buffer, or null if the index is not a dequeued\n input buffer, or if the codec is configured for surface input.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getInputBuffers' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getInputBuffers' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getInputBuffers' class='name expandable'>getInputBuffers</a>( <span class='pre'></span> )<span class=\"signature\"><span class='deprecated' >deprecated</span></span></div><div class='description'><div class='short'>Retrieve the set of input buffers. ...</div><div class='long'><p>Retrieve the set of input buffers.  Call this after start()\n returns. After calling this method, any ByteBuffers\n previously returned by an earlier call to this method MUST no\n longer be used.</p>\n        <div class='rounded-box deprecated-box deprecated-tag-box'>\n        <p>This method has been <strong>deprecated</strong> </p>\n        <p>Use the new <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffer\" rel=\"android.media.MediaCodec-method-getInputBuffer\" class=\"docClass\">getInputBuffer</a> method instead\n each time an input buffer is dequeued.</p>\n\n<p> <b>Note:</b> As of API 21, dequeued input buffers are\n automatically cleared.</p>\n\n<p> <em>Do not use this method if using an input surface.</em></p>\n\n        </div>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state,\n         or codec is configured in asynchronous mode.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getInputFormat' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getInputFormat' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getInputFormat' class='name expandable'>getInputFormat</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Call this after configure returns successfully to\n get the input format accepted by the codec. ...</div><div class='long'><p>Call this after <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a> returns successfully to\n get the input format accepted by the codec. Do this to\n determine what optional configuration parameters were\n supported by the codec.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing or\n                               Configured state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getInputImage' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getInputImage' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getInputImage' class='name expandable'>getInputImage</a>( <span class='pre'>index</span> ) : Object {android.media.Image}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a writable Image object for a dequeued input buffer\n index to contain the raw input video frame. ...</div><div class='long'><p>Returns a writable Image object for a dequeued input buffer\n index to contain the raw input video frame.</p>\n\n<p> After calling this method any ByteBuffer or Image object\n previously returned for the same input index MUST no longer\n be used.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned input buffer previously\n              returned from a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a>,\n              or received via an onInputBufferAvailable callback.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {android.media.Image}</span><div class='sub-desc'><p>the input image, or null if the index is not a\n dequeued input buffer, or not a ByteBuffer that contains a\n raw image.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getMetrics' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getMetrics' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getMetrics' class='name expandable'>getMetrics</a>( <span class='pre'></span> ) : Object {android.os.PersistableBundle}<span class=\"signature\"></span></div><div class='description'><div class='short'>Return Metrics data about the current codec instance. ...</div><div class='long'><p>Return Metrics data about the current codec instance.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {android.os.PersistableBundle}</span><div class='sub-desc'><p>a PersistableBundle containing the set of attributes and values\n available for the media being handled by this instance of MediaCodec\n The attributes are descibed in MetricsConstants.</p>\n\n<p> Additional vendor-specific fields may also be present in\n the return value.</p>\n</div></li></ul></div></div></div><div id='method-getName' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getName' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getName' class='name expandable'>getName</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Retrieve the codec name. ...</div><div class='long'><p>Retrieve the codec name.</p>\n\n<p> If the codec was created by createDecoderByType or createEncoderByType, what component is\n chosen is not known beforehand. This method returns the name of the codec that was\n selected by the platform.</p>\n\n<p> <strong>Note:</strong> Implementations may provide multiple aliases (codec\n names) for the same underlying codec, any of which can be used to instantiate the same\n underlying codec in <a href=\"#!/api/android.media.MediaCodec-method-createByCodecName\" rel=\"android.media.MediaCodec-method-createByCodecName\" class=\"docClass\">createByCodecName</a>. This method returns the\n name used to create the codec in this case.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div><div id='method-getOutputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getOutputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getOutputBuffer' class='name expandable'>getOutputBuffer</a>( <span class='pre'>index</span> ) : Object {java.nio.ByteBuffer}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a read-only ByteBuffer for a dequeued output buffer\n index. ...</div><div class='long'><p>Returns a read-only ByteBuffer for a dequeued output buffer\n index. The position and limit of the returned buffer are set\n to the valid output data.</p>\n\n<p> After calling this method, any ByteBuffer or Image object\n previously returned for the same output index MUST no longer\n be used.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned output buffer previously\n              returned from a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a>,\n              or received via an onOutputBufferAvailable callback.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.nio.ByteBuffer}</span><div class='sub-desc'><p>the output buffer, or null if the index is not a dequeued\n output buffer, or the codec is configured with an output surface.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getOutputBuffers' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getOutputBuffers' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getOutputBuffers' class='name expandable'>getOutputBuffers</a>( <span class='pre'></span> )<span class=\"signature\"><span class='deprecated' >deprecated</span></span></div><div class='description'><div class='short'>Retrieve the set of output buffers. ...</div><div class='long'><p>Retrieve the set of output buffers.  Call this after start()\n returns and whenever dequeueOutputBuffer signals an output\n buffer change by returning <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" class=\"docClass\">INFO_OUTPUT_BUFFERS_CHANGED</a>. After calling this method, any\n ByteBuffers previously returned by an earlier call to this\n method MUST no longer be used.</p>\n        <div class='rounded-box deprecated-box deprecated-tag-box'>\n        <p>This method has been <strong>deprecated</strong> </p>\n        <p>Use the new <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffer\" rel=\"android.media.MediaCodec-method-getOutputBuffer\" class=\"docClass\">getOutputBuffer</a> method instead\n each time an output buffer is dequeued.  This method is not\n supported if codec is configured in asynchronous mode.</p>\n\n<p> <b>Note:</b> As of API 21, the position and limit of output\n buffers that are dequeued will be set to the valid data\n range.</p>\n\n<p> <em>Do not use this method if using an output surface.</em></p>\n\n        </div>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state,\n         or codec is configured in asynchronous mode.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-getOutputFormat' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getOutputFormat' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getOutputFormat' class='name expandable'>getOutputFormat</a>( <span class='pre'>index</span> ) : Object {android.media.MediaFormat}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the output format for a specific output buffer. ...</div><div class='long'><p>Returns the output format for a specific output buffer.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned input buffer previously\n              returned from a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a>.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {android.media.MediaFormat}</span><div class='sub-desc'><p>the format for the output buffer, or null if the index\n is not a dequeued output buffer.</p>\n</div></li></ul></div></div></div><div id='method-getOutputImage' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-getOutputImage' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-getOutputImage' class='name expandable'>getOutputImage</a>( <span class='pre'>index</span> ) : Object {android.media.Image}<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a read-only Image object for a dequeued output buffer\n index that contains the raw video frame. ...</div><div class='long'><p>Returns a read-only Image object for a dequeued output buffer\n index that contains the raw video frame.</p>\n\n<p> After calling this method, any ByteBuffer or Image object previously\n returned for the same output index MUST no longer be used.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned output buffer previously\n              returned from a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a>,\n              or received via an onOutputBufferAvailable callback.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {android.media.Image}</span><div class='sub-desc'><p>the output image, or null if the index is not a\n dequeued output buffer, not a raw video frame, or if the codec\n was configured with an output surface.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-queueInputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-queueInputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-queueInputBuffer' class='name expandable'>queueInputBuffer</a>( <span class='pre'>index, offset, size, presentationTimeUs, flags</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>After filling a range of the input buffer at the specified index\n submit it to the component. ...</div><div class='long'><p>After filling a range of the input buffer at the specified index\n submit it to the component. Once an input buffer is queued to\n the codec, it MUST NOT be used until it is later retrieved by\n <a href=\"#!/api/android.media.MediaCodec-method-getInputBuffer\" rel=\"android.media.MediaCodec-method-getInputBuffer\" class=\"docClass\">getInputBuffer</a> in response to a <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a>\n return value or a <a href=\"#!/api/android.media.MediaCodec.Callback-method-onInputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onInputBufferAvailable\" class=\"docClass\">android.media.MediaCodec.Callback.onInputBufferAvailable</a>\n callback.\n <p>\n Many decoders require the actual compressed data stream to be\n preceded by \"codec specific data\", i.e. setup data used to initialize\n the codec such as PPS/SPS in the case of AVC video or code tables\n in the case of vorbis audio.\n The class <a href=\"#!/api/android.media.MediaExtractor\" rel=\"android.media.MediaExtractor\" class=\"docClass\">android.media.MediaExtractor</a> provides codec\n specific data as part of\n the returned track format in entries named \"csd-0\", \"csd-1\" ...\n <p>\n These buffers can be submitted directly after <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a> or\n <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> by specifying the flag <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a>.  However, if you configure the\n codec with a <a href=\"#!/api/android.media.MediaFormat\" rel=\"android.media.MediaFormat\" class=\"docClass\">android.media.MediaFormat</a> containing these keys, they\n will be automatically submitted by MediaCodec directly after\n start.  Therefore, the use of <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a> flag is discouraged and is\n recommended only for advanced users.\n <p>\n To indicate that this is the final piece of input data (or rather that\n no more input data follows unless the decoder is subsequently flushed)\n specify the flag <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" class=\"docClass\">BUFFER_FLAG_END_OF_STREAM</a>.\n <p class=note>\n <strong>Note:</strong> Prior to android.os.Build.VERSION_CODES.M,\n {@code presentationTimeUs} was not propagated to the frame timestamp of (rendered)\n Surface output buffers, and the resulting frame timestamp was undefined.\n Use long) to ensure a specific frame timestamp is set.\n Similarly, since frame timestamps can be used by the destination surface for rendering\n synchronization, <strong>care must be taken to normalize presentationTimeUs so as to not be\n mistaken for a system time. (See {@linkplain <a href=\"#!/api/android.media.MediaCodec-method-releaseOutputBuffer\" rel=\"android.media.MediaCodec-method-releaseOutputBuffer\" class=\"docClass\">releaseOutputBuffer</a>(int, long)\n SurfaceView specifics}).</strong></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned input buffer previously returned\n              in a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a>.</p>\n</div></li><li><span class='pre'>offset</span> : Number<div class='sub-desc'><p>The byte offset into the input buffer at which the data starts.</p>\n</div></li><li><span class='pre'>size</span> : Number<div class='sub-desc'><p>The number of bytes of valid input data.</p>\n</div></li><li><span class='pre'>presentationTimeUs</span> : Number<div class='sub-desc'><p>The presentation timestamp in microseconds for this\n                           buffer. This is normally the media time at which this\n                           buffer should be presented (rendered). When using an output\n                           surface, this will be propagated as the timestamp for the frame (after\n                           conversion to nanoseconds).</p>\n</div></li><li><span class='pre'>flags</span> : Number<div class='sub-desc'><p>A bitmask of flags\n              <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a> and <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" class=\"docClass\">BUFFER_FLAG_END_OF_STREAM</a>.\n              While not prohibited, most codecs do not use the\n              <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" class=\"docClass\">BUFFER_FLAG_KEY_FRAME</a> flag for input buffers.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>CryptoException if a crypto object has been specified in\n         <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a></p>\n</div></li></ul></div></div></div><div id='method-queueSecureInputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-queueSecureInputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-queueSecureInputBuffer' class='name expandable'>queueSecureInputBuffer</a>( <span class='pre'>index, offset, info, presentationTimeUs, flags</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Similar to queueInputBuffer but submits a buffer that is\n potentially encrypted. ...</div><div class='long'><p>Similar to <a href=\"#!/api/android.media.MediaCodec-method-queueInputBuffer\" rel=\"android.media.MediaCodec-method-queueInputBuffer\" class=\"docClass\">queueInputBuffer</a> but submits a buffer that is\n potentially encrypted.\n <strong>Check out further notes at <a href=\"#!/api/android.media.MediaCodec-method-queueInputBuffer\" rel=\"android.media.MediaCodec-method-queueInputBuffer\" class=\"docClass\">queueInputBuffer</a>.</strong></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned input buffer previously returned\n              in a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueInputBuffer\" rel=\"android.media.MediaCodec-method-dequeueInputBuffer\" class=\"docClass\">dequeueInputBuffer</a>.</p>\n</div></li><li><span class='pre'>offset</span> : Number<div class='sub-desc'><p>The byte offset into the input buffer at which the data starts.</p>\n</div></li><li><span class='pre'>info</span> : Object {MediaCodec.CryptoInfo}<div class='sub-desc'><p>Metadata required to facilitate decryption, the object can be\n             reused immediately after this call returns.</p>\n</div></li><li><span class='pre'>presentationTimeUs</span> : Number<div class='sub-desc'><p>The presentation timestamp in microseconds for this\n                           buffer. This is normally the media time at which this\n                           buffer should be presented (rendered).</p>\n</div></li><li><span class='pre'>flags</span> : Number<div class='sub-desc'><p>A bitmask of flags\n              <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_CODEC_CONFIG\" class=\"docClass\">BUFFER_FLAG_CODEC_CONFIG</a> and <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" class=\"docClass\">BUFFER_FLAG_END_OF_STREAM</a>.\n              While not prohibited, most codecs do not use the\n              <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_KEY_FRAME\" class=\"docClass\">BUFFER_FLAG_KEY_FRAME</a> flag for input buffers.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>CryptoException if an error occurs while attempting to decrypt the buffer.\n              An error code associated with the exception helps identify the\n              reason for the failure.</p>\n</div></li></ul></div></div></div><div id='method-release' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-release' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-release' class='name expandable'>release</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Free up resources used by the codec instance. ...</div><div class='long'><p>Free up resources used by the codec instance.</p>\n\n<p> Make sure you call this when you're done to free up any opened\n component instance instead of relying on the garbage collector\n to do this for you at some point in the future.</p>\n</div></div></div><div id='method-releaseOutputBuffer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-releaseOutputBuffer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-releaseOutputBuffer' class='name expandable'>releaseOutputBuffer</a>( <span class='pre'>index, renderTimestampNs</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>If you are done with a buffer, use this call to update its surface timestamp\n and return it to the codec to render it...</div><div class='long'><p>If you are done with a buffer, use this call to update its surface timestamp\n and return it to the codec to render it on the output surface. If you\n have not specified an output surface when configuring this video codec,\n this call will simply return the buffer to the codec.<p></p>\n\n<p> The timestamp may have special meaning depending on the destination surface.</p>\n\n<p> <table>\n <tr><th>SurfaceView specifics</th></tr>\n <tr><td>\n If you render your buffer on a android.view.SurfaceView,\n you can use the timestamp to render the buffer at a specific time (at the\n VSYNC at or after the buffer timestamp).  For this to work, the timestamp\n needs to be <i>reasonably close</i> to the current System.nanoTime.\n Currently, this is set as within one (1) second. A few notes:</td></tr></table></p>\n\n<p> <ul>\n <li>the buffer will not be returned to the codec until the timestamp\n has passed and the buffer is no longer used by the android.view.Surface.\n <li>buffers are processed sequentially, so you may block subsequent buffers to\n be displayed on the android.view.Surface.  This is important if you\n want to react to user action, e.g. stop the video or seek.\n <li>if multiple buffers are sent to the android.view.Surface to be\n rendered at the same VSYNC, the last one will be shown, and the other ones\n will be dropped.\n <li>if the timestamp is <em>not</em> \"reasonably close\" to the current system\n time, the android.view.Surface will ignore the timestamp, and\n display the buffer at the earliest feasible time.  In this mode it will not\n drop frames.\n <li>for best performance and quality, call this method when you are about\n two VSYNCs' time before the desired render time.  For 60Hz displays, this is\n about 33 msec.\n </li></li></li></li></li></ul>\n \n </p>\n\n<p> Once an output buffer is released to the codec, it MUST NOT\n be used until it is later retrieved by <a href=\"#!/api/android.media.MediaCodec-method-getOutputBuffer\" rel=\"android.media.MediaCodec-method-getOutputBuffer\" class=\"docClass\">getOutputBuffer</a> in response\n to a <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a> return value or a\n <a href=\"#!/api/android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" rel=\"android.media.MediaCodec.Callback-method-onOutputBufferAvailable\" class=\"docClass\">android.media.MediaCodec.Callback.onOutputBufferAvailable</a> callback.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>The index of a client-owned output buffer previously returned\n              from a call to <a href=\"#!/api/android.media.MediaCodec-method-dequeueOutputBuffer\" rel=\"android.media.MediaCodec-method-dequeueOutputBuffer\" class=\"docClass\">dequeueOutputBuffer</a>.</p>\n</div></li><li><span class='pre'>renderTimestampNs</span> : Number<div class='sub-desc'><p>The timestamp to associate with this buffer when\n              it is sent to the Surface.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-reset' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-reset' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-reset' class='name expandable'>reset</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the codec to its initial (Uninitialized) state. ...</div><div class='long'><p>Returns the codec to its initial (Uninitialized) state.</p>\n\n<p> Call this if an <a href=\"#!/api/android.media.MediaCodec.CodecException-method-isRecoverable\" rel=\"android.media.MediaCodec.CodecException-method-isRecoverable\" class=\"docClass\">unrecoverable</a>\n error has occured to reset the codec to its initial state after creation.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>CodecException if an unrecoverable error has occured and the codec\n could not be reset.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div><div id='method-setAudioPresentation' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setAudioPresentation' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setAudioPresentation' class='name expandable'>setAudioPresentation</a>( <span class='pre'>presentation</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Sets the audio presentation. ...</div><div class='long'><p>Sets the audio presentation.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>presentation</span> : Object {AudioPresentation}<div class='sub-desc'><p>see AudioPresentation. In particular, id should be set.</p>\n</div></li></ul></div></div></div><div id='method-setCallback' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setCallback' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setCallback' class='name expandable'>setCallback</a>( <span class='pre'>cb</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Sets an asynchronous callback for actionable MediaCodec events on the default\n looper. ...</div><div class='long'><p>Sets an asynchronous callback for actionable MediaCodec events on the default\n looper.\n <p>\n Same as Handler) with handler set to null.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>cb</span> : Object {MediaCodec.Callback}<div class='sub-desc'><p>The callback that will run.  Use {@code null} to clear a previously\n           set callback (before <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a> is called and run\n           in synchronous mode).\n@see <a href=\"#!/api/android.media.MediaCodec-method-setCallback\" rel=\"android.media.MediaCodec-method-setCallback\" class=\"docClass\">setCallback</a>(Callback, Handler)</p>\n</div></li></ul></div></div></div><div id='method-setInputSurface' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setInputSurface' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setInputSurface' class='name expandable'>setInputSurface</a>( <span class='pre'>surface</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Configures the codec (e.g. ...</div><div class='long'><p>Configures the codec (e.g. encoder) to use a persistent input surface in place of input\n buffers.  This may only be called after <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a> and before <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a>, in\n lieu of <a href=\"#!/api/android.media.MediaCodec-method-createInputSurface\" rel=\"android.media.MediaCodec-method-createInputSurface\" class=\"docClass\">createInputSurface</a>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>surface</span> : Object {Surface}<div class='sub-desc'><p>a persistent input surface created by <a href=\"#!/api/android.media.MediaCodec-method-createPersistentInputSurface\" rel=\"android.media.MediaCodec-method-createPersistentInputSurface\" class=\"docClass\">createPersistentInputSurface</a></p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Configured state or does not require an input\n           surface.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the surface was not created by\n           <a href=\"#!/api/android.media.MediaCodec-method-createPersistentInputSurface\" rel=\"android.media.MediaCodec-method-createPersistentInputSurface\" class=\"docClass\">createPersistentInputSurface</a>.</p>\n</div></li></ul></div></div></div><div id='method-setOnFrameRenderedListener' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setOnFrameRenderedListener' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setOnFrameRenderedListener' class='name expandable'>setOnFrameRenderedListener</a>( <span class='pre'>listener, handler</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Registers a callback to be invoked when an output frame is rendered on the output surface. ...</div><div class='long'><p>Registers a callback to be invoked when an output frame is rendered on the output surface.\n <p>\n This method can be called in any codec state, but will only have an effect in the\n Executing state for codecs that render buffers to the output surface.\n <p>\n <strong>Note:</strong> This callback is for informational purposes only: to get precise\n render timing samples, and can be significantly delayed and batched. Some frames may have\n been rendered even if there was no callback generated.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>listener</span> : Object {MediaCodec.OnFrameRenderedListener}<div class='sub-desc'><p>the callback that will be run</p>\n</div></li><li><span class='pre'>handler</span> : Object {Handler}<div class='sub-desc'><p>the callback will be run on the handler's thread. If {@code null},\n           the callback will be run on the default thread, which is the looper\n           from which the codec was created, or a new thread if there was none.</p>\n</div></li></ul></div></div></div><div id='method-setOutputSurface' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setOutputSurface' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setOutputSurface' class='name expandable'>setOutputSurface</a>( <span class='pre'>surface</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Dynamically sets the output surface of a codec. ...</div><div class='long'><p>Dynamically sets the output surface of a codec.\n  <p>\n  This can only be used if the codec was configured with an output surface.  The\n  new output surface should have a compatible usage type to the original output surface.\n  E.g. codecs may not support switching from a SurfaceTexture (GPU readable) output\n  to ImageReader (software readable) output.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>surface</span> : Object {Surface}<div class='sub-desc'><p>the output surface to use. It must not be {@code null}.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if the codec does not support setting the output\n            surface in the current state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the new surface is not of a suitable type for the codec.</p>\n</div></li></ul></div></div></div><div id='method-setParameters' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setParameters' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setParameters' class='name expandable'>setParameters</a>( <span class='pre'>params</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Communicate additional parameter changes to the component instance. ...</div><div class='long'><p>Communicate additional parameter changes to the component instance.\n <b>Note:</b> Some of these parameter changes may silently fail to apply.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>params</span> : Object {Bundle}<div class='sub-desc'><p>The bundle of parameters to set.</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div><div id='method-setVideoScalingMode' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-setVideoScalingMode' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-setVideoScalingMode' class='name expandable'>setVideoScalingMode</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>If a surface has been specified in a previous call to configure\n specifies the scaling mode to use. ...</div><div class='long'><p>If a surface has been specified in a previous call to <a href=\"#!/api/android.media.MediaCodec-method-configure\" rel=\"android.media.MediaCodec-method-configure\" class=\"docClass\">configure</a>\n specifies the scaling mode to use. The default is \"scale to fit\".\n <p class=note>\n The scaling mode may be reset to the <strong>default</strong> each time an\n <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" class=\"docClass\">INFO_OUTPUT_BUFFERS_CHANGED</a> event is received from the codec; therefore, the client\n must call this method after every buffer change event (and before the first output buffer is\n released for rendering) to ensure consistent scaling mode.\n <p class=note>\n Since the <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_BUFFERS_CHANGED\" class=\"docClass\">INFO_OUTPUT_BUFFERS_CHANGED</a> event is deprecated, this can also be done\n after each <a href=\"#!/api/android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED\" rel=\"android.media.MediaCodec-property-INFO_OUTPUT_FORMAT_CHANGED\" class=\"docClass\">INFO_OUTPUT_FORMAT_CHANGED</a> event.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if mode is not recognized.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div><div id='method-signalEndOfInputStream' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-signalEndOfInputStream' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-signalEndOfInputStream' class='name expandable'>signalEndOfInputStream</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Signals end-of-stream on input. ...</div><div class='long'><p>Signals end-of-stream on input.  Equivalent to submitting an empty buffer with\n <a href=\"#!/api/android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" rel=\"android.media.MediaCodec-property-BUFFER_FLAG_END_OF_STREAM\" class=\"docClass\">BUFFER_FLAG_END_OF_STREAM</a> set.  This may only be used with\n encoders receiving input from a Surface created by <a href=\"#!/api/android.media.MediaCodec-method-createInputSurface\" rel=\"android.media.MediaCodec-method-createInputSurface\" class=\"docClass\">createInputSurface</a>.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Executing state.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error.</p>\n</div></li></ul></div></div></div><div id='method-start' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-start' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-start' class='name expandable'>start</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>After successfully configuring the component, call {@code start}. ...</div><div class='long'><p>After successfully configuring the component, call {@code start}.\n <p>\n Call {@code start} also if the codec is configured in asynchronous mode,\n and it has just been flushed, to resume requesting input buffers.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if not in the Configured state\n         or just after <a href=\"#!/api/android.media.MediaCodec-method-flush\" rel=\"android.media.MediaCodec-method-flush\" class=\"docClass\">flush</a> for a codec that is configured\n         in asynchronous mode.</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>MediaCodec.CodecException upon codec error. Note that some codec errors\n for start may be attributed to future method calls.</p>\n</div></li></ul></div></div></div><div id='method-stop' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='android.media.MediaCodec'>android.media.MediaCodec</span><br/><a href='source/MediaCodec.html#android-media-MediaCodec-method-stop' target='_blank' class='view-source'>view source</a></div><a href='#!/api/android.media.MediaCodec-method-stop' class='name expandable'>stop</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Finish the decode/encode session, note that the codec instance\n remains active and ready to be started again. ...</div><div class='long'><p>Finish the decode/encode session, note that the codec instance\n remains active and ready to be <a href=\"#!/api/android.media.MediaCodec-method-start\" rel=\"android.media.MediaCodec-method-start\" class=\"docClass\">start</a>ed again.\n To ensure that it is available to other client call <a href=\"#!/api/android.media.MediaCodec-method-release\" rel=\"android.media.MediaCodec-method-release\" class=\"docClass\">release</a>\n and don't just rely on garbage collection to eventually do this for you.</p>\n<h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if in the Released state.</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});