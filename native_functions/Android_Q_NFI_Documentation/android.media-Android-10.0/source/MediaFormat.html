<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-media-MediaFormat'>/**@class android.media.MediaFormat
</span>@extends java.lang.Object

 Encapsulates the information describing the format of media data, be it audio or video, as
 well as optional feature metadata.
 &lt;p&gt;
 The format of the media data is specified as key/value pairs. Keys are strings. Values can
 be integer, long, float, String or ByteBuffer.
 &lt;p&gt;
 The feature metadata is specificed as string/boolean pairs.
 &lt;p&gt;
 Keys common to all audio/video formats, &lt;b&gt;all keys not marked optional are mandatory&lt;/b&gt;:

 &lt;table&gt;
 &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Value Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_MIME}&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;The type of the format.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_MAX_INPUT_SIZE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;optional, maximum size of a buffer of input data&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_BIT_RATE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;, desired bitrate in bits/second&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;

 Video formats have the following keys:
 &lt;table&gt;
 &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Value Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_WIDTH}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_HEIGHT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_COLOR_FORMAT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;set by the user
         for encoders, readable in the output format of decoders&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_FRAME_RATE}&lt;/td&gt;&lt;td&gt;Integer or Float&lt;/td&gt;&lt;td&gt;required for &lt;b&gt;encoders&lt;/b&gt;,
         optional for &lt;b&gt;decoders&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_CAPTURE_RATE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_I_FRAME_INTERVAL}&lt;/td&gt;&lt;td&gt;Integer (or Float)&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;,
         time-interval between key frames.
         Float support added in {@link android.os.Build.VERSION_CODES#N_MR1}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_INTRA_REFRESH_PERIOD}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;, optional&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_LATENCY}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;, optional&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_MAX_WIDTH}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, max-resolution width&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_MAX_HEIGHT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, max-resolution height&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_REPEAT_PREVIOUS_FRAME_AFTER}&lt;/td&gt;&lt;td&gt;Long&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder in surface-mode
         only&lt;/b&gt;, optional&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_PUSH_BLANK_BUFFERS_ON_STOP}&lt;/td&gt;&lt;td&gt;Integer(1)&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder rendering
         to a surface only&lt;/b&gt;, optional&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_TEMPORAL_LAYERING}&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder only&lt;/b&gt;, optional,
         temporal-layering schema&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 Specify both {@link #KEY_MAX_WIDTH} and {@link #KEY_MAX_HEIGHT} to enable
 adaptive playback (seamless resolution change) for a video decoder that
 supports it ({@link android.media.MediaCodecInfo.CodecCapabilities#FEATURE_AdaptivePlayback}).
 The values are used as hints for the codec: they are the maximum expected
 resolution to prepare for.  Depending on codec support, preparing for larger
 maximum resolution may require more memory even if that resolution is never
 reached.  These fields have no effect for codecs that do not support adaptive
 playback.&lt;br /&gt;&lt;br /&gt;

 Audio formats have the following keys:
 &lt;table&gt;
 &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Value Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_CHANNEL_COUNT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_SAMPLE_RATE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_PCM_ENCODING}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;optional&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_IS_ADTS}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;optional, if &lt;em&gt;decoding&lt;/em&gt; AAC audio content, setting this key to 1 indicates that each audio frame is prefixed by the ADTS header.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_PROFILE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the desired profile.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_SBR_MODE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the desired SBR mode.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_DRC_TARGET_REFERENCE_LEVEL}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the target reference level.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_ENCODED_TARGET_LEVEL}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the target reference level used at encoder.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_DRC_BOOST_FACTOR}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the DRC boost factor.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_DRC_ATTENUATION_FACTOR}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the DRC attenuation factor.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_DRC_HEAVY_COMPRESSION}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies whether to use heavy compression.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the maximum number of channels the decoder outputs.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_AAC_DRC_EFFECT_TYPE}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;decoder-only&lt;/b&gt;, optional, if content is AAC audio, specifies the MPEG-D DRC effect type to use.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_CHANNEL_MASK}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;optional, a mask of audio channel assignments&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_FLAC_COMPRESSION_LEVEL}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;b&gt;encoder-only&lt;/b&gt;, optional, if content is FLAC audio, specifies the desired compression level.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;

 Subtitle formats have the following keys:
 &lt;table&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_MIME}&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;The type of the format.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_LANGUAGE}&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;The language of the content.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;

 Image formats have the following keys:
 &lt;table&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_MIME}&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;The type of the format.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_WIDTH}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_HEIGHT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_COLOR_FORMAT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;set by the user
         for encoders, readable in the output format of decoders&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_TILE_WIDTH}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;required if the image has grid&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_TILE_HEIGHT}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;required if the image has grid&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_GRID_ROWS}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;required if the image has grid&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #KEY_GRID_COLUMNS}&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;required if the image has grid&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
*/
var MediaFormat = {

<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_VP8'>/***/
</span>MIMETYPE_VIDEO_VP8 : &quot;video/x-vnd.on2.vp8&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_VP9'>/***/
</span>MIMETYPE_VIDEO_VP9 : &quot;video/x-vnd.on2.vp9&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_AV1'>/***/
</span>MIMETYPE_VIDEO_AV1 : &quot;video/av01&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_AVC'>/***/
</span>MIMETYPE_VIDEO_AVC : &quot;video/avc&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_HEVC'>/***/
</span>MIMETYPE_VIDEO_HEVC : &quot;video/hevc&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_MPEG4'>/***/
</span>MIMETYPE_VIDEO_MPEG4 : &quot;video/mp4v-es&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_H263'>/***/
</span>MIMETYPE_VIDEO_H263 : &quot;video/3gpp&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_MPEG2'>/***/
</span>MIMETYPE_VIDEO_MPEG2 : &quot;video/mpeg2&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_RAW'>/***/
</span>MIMETYPE_VIDEO_RAW : &quot;video/raw&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_DOLBY_VISION'>/***/
</span>MIMETYPE_VIDEO_DOLBY_VISION : &quot;video/dolby-vision&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_VIDEO_SCRAMBLED'>/***/
</span>MIMETYPE_VIDEO_SCRAMBLED : &quot;video/scrambled&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_AMR_NB'>/***/
</span>MIMETYPE_AUDIO_AMR_NB : &quot;audio/3gpp&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_AMR_WB'>/***/
</span>MIMETYPE_AUDIO_AMR_WB : &quot;audio/amr-wb&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_MPEG'>/***/
</span>MIMETYPE_AUDIO_MPEG : &quot;audio/mpeg&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_AAC'>/***/
</span>MIMETYPE_AUDIO_AAC : &quot;audio/mp4a-latm&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_QCELP'>/***/
</span>MIMETYPE_AUDIO_QCELP : &quot;audio/qcelp&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_VORBIS'>/***/
</span>MIMETYPE_AUDIO_VORBIS : &quot;audio/vorbis&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_OPUS'>/***/
</span>MIMETYPE_AUDIO_OPUS : &quot;audio/opus&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_G711_ALAW'>/***/
</span>MIMETYPE_AUDIO_G711_ALAW : &quot;audio/g711-alaw&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_G711_MLAW'>/***/
</span>MIMETYPE_AUDIO_G711_MLAW : &quot;audio/g711-mlaw&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_RAW'>/***/
</span>MIMETYPE_AUDIO_RAW : &quot;audio/raw&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_FLAC'>/***/
</span>MIMETYPE_AUDIO_FLAC : &quot;audio/flac&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_MSGSM'>/***/
</span>MIMETYPE_AUDIO_MSGSM : &quot;audio/gsm&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_AC3'>/***/
</span>MIMETYPE_AUDIO_AC3 : &quot;audio/ac3&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_EAC3'>/***/
</span>MIMETYPE_AUDIO_EAC3 : &quot;audio/eac3&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_EAC3_JOC'>/***/
</span>MIMETYPE_AUDIO_EAC3_JOC : &quot;audio/eac3-joc&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_AC4'>/***/
</span>MIMETYPE_AUDIO_AC4 : &quot;audio/ac4&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_AUDIO_SCRAMBLED'>/***/
</span>MIMETYPE_AUDIO_SCRAMBLED : &quot;audio/scrambled&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_IMAGE_ANDROID_HEIC'>/** MIME type for HEIF still image data encoded in HEVC.
</span>
 To decode such an image, {@link android.media.MediaCodec} decoder for
 {@link #MIMETYPE_VIDEO_HEVC} shall be used. The client needs to form
 the correct {@link #MediaFormat} based on additional information in
 the track format, and send it to {@link android.media.MediaCodec#configure}.

 The track's MediaFormat will come with {@link #KEY_WIDTH} and
 {@link #KEY_HEIGHT} keys, which describes the width and height
 of the image. If the image doesn't contain grid (i.e. none of
 {@link #KEY_TILE_WIDTH}, {@link #KEY_TILE_HEIGHT},
 {@link #KEY_GRID_ROWS}, {@link #KEY_GRID_COLUMNS} are present}), the
 track will contain a single sample of coded data for the entire image,
 and the image width and height should be used to set up the decoder.

 If the image does come with grid, each sample from the track will
 contain one tile in the grid, of which the size is described by
 {@link #KEY_TILE_WIDTH} and {@link #KEY_TILE_HEIGHT}. This size
 (instead of {@link #KEY_WIDTH} and {@link #KEY_HEIGHT}) should be
 used to set up the decoder. The track contains {@link #KEY_GRID_ROWS}
 by {@link #KEY_GRID_COLUMNS} samples in row-major, top-row first,
 left-to-right order. The output image should be reconstructed by
 first tiling the decoding results of the tiles in the correct order,
 then trimming (before rotation is applied) on the bottom and right
 side, if the tiled area is larger than the image width and height.
*/
MIMETYPE_IMAGE_ANDROID_HEIC : &quot;image/vnd.android.heic&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_TEXT_VTT'>/** MIME type for WebVTT subtitle data.
</span>*/
MIMETYPE_TEXT_VTT : &quot;text/vtt&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_TEXT_SUBRIP'>/** MIME type for SubRip (SRT) container.
</span>*/
MIMETYPE_TEXT_SUBRIP : &quot;application/x-subrip&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_TEXT_CEA_608'>/** MIME type for CEA-608 closed caption data.
</span>*/
MIMETYPE_TEXT_CEA_608 : &quot;text/cea-608&quot;,
<span id='android-media-MediaFormat-property-MIMETYPE_TEXT_CEA_708'>/** MIME type for CEA-708 closed caption data.
</span>*/
MIMETYPE_TEXT_CEA_708 : &quot;text/cea-708&quot;,
<span id='android-media-MediaFormat-property-KEY_MIME'>/** A key describing the mime type of the MediaFormat.
</span> The associated value is a string.
*/
KEY_MIME : &quot;mime&quot;,
<span id='android-media-MediaFormat-property-KEY_LANGUAGE'>/** A key describing the language of the content, using either ISO 639-1
</span> or 639-2/T codes.  The associated value is a string.
*/
KEY_LANGUAGE : &quot;language&quot;,
<span id='android-media-MediaFormat-property-KEY_SAMPLE_RATE'>/** A key describing the sample rate of an audio format.
</span> The associated value is an integer
*/
KEY_SAMPLE_RATE : &quot;sample-rate&quot;,
<span id='android-media-MediaFormat-property-KEY_CHANNEL_COUNT'>/** A key describing the number of channels in an audio format.
</span> The associated value is an integer
*/
KEY_CHANNEL_COUNT : &quot;channel-count&quot;,
<span id='android-media-MediaFormat-property-KEY_WIDTH'>/** A key describing the width of the content in a video format.
</span> The associated value is an integer
*/
KEY_WIDTH : &quot;width&quot;,
<span id='android-media-MediaFormat-property-KEY_HEIGHT'>/** A key describing the height of the content in a video format.
</span> The associated value is an integer
*/
KEY_HEIGHT : &quot;height&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_WIDTH'>/** A key describing the maximum expected width of the content in a video
</span> decoder format, in case there are resolution changes in the video content.
 The associated value is an integer
*/
KEY_MAX_WIDTH : &quot;max-width&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_HEIGHT'>/** A key describing the maximum expected height of the content in a video
</span> decoder format, in case there are resolution changes in the video content.
 The associated value is an integer
*/
KEY_MAX_HEIGHT : &quot;max-height&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_INPUT_SIZE'>/**A key describing the maximum size in bytes of a buffer of data
</span> described by this MediaFormat.
 The associated value is an integer
*/
KEY_MAX_INPUT_SIZE : &quot;max-input-size&quot;,
<span id='android-media-MediaFormat-property-KEY_BIT_RATE'>/** A key describing the average bitrate in bits/sec.
</span> The associated value is an integer
*/
KEY_BIT_RATE : &quot;bitrate&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_BIT_RATE'>/** A key describing the max bitrate in bits/sec.
</span> This is usually over a one-second sliding window (e.g. over any window of one second).
 The associated value is an integer
 @hide
*/
KEY_MAX_BIT_RATE : &quot;max-bitrate&quot;,
<span id='android-media-MediaFormat-property-KEY_COLOR_FORMAT'>/** A key describing the color format of the content in a video format.
</span> Constants are declared in {@link android.media.MediaCodecInfo.CodecCapabilities}.
*/
KEY_COLOR_FORMAT : &quot;color-format&quot;,
<span id='android-media-MediaFormat-property-KEY_FRAME_RATE'>/** A key describing the frame rate of a video format in frames/sec.
</span> The associated value is normally an integer when the value is used by the platform,
 but video codecs also accept float configuration values.
 Specifically, {@link android.media.MediaExtractor#getTrackFormat android.media.MediaExtractor} provides an integer
 value corresponding to the frame rate information of the track if specified and non-zero.
 Otherwise, this key is not present. {@link android.media.MediaCodec#configure android.media.MediaCodec} accepts both
 float and integer values. This represents the desired operating frame rate if the
 {@link #KEY_OPERATING_RATE} is not present and {@link #KEY_PRIORITY} is {@code 0}
 (realtime). For video encoders this value corresponds to the intended frame rate,
 although encoders are expected
 to support variable frame rate based on {@link android.media.MediaCodec.BufferInfo#presentationTimeUs
 buffer timestamp}. This key is not used in the {@code MediaCodec}
 {@link android.media.MediaCodec#getInputFormat input}/{@link android.media.MediaCodec#getOutputFormat output} formats,
 nor by {@link android.media.MediaMuxer#addTrack android.media.MediaMuxer}.
*/
KEY_FRAME_RATE : &quot;frame-rate&quot;,
<span id='android-media-MediaFormat-property-KEY_TILE_WIDTH'>/** A key describing the width (in pixels) of each tile of the content in a
</span> {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.

 Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.

 @see #KEY_TILE_HEIGHT
 @see #KEY_GRID_ROWS
 @see #KEY_GRID_COLUMNS
*/
KEY_TILE_WIDTH : &quot;tile-width&quot;,
<span id='android-media-MediaFormat-property-KEY_TILE_HEIGHT'>/** A key describing the height (in pixels) of each tile of the content in a
</span> {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.

 Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.

 @see #KEY_TILE_WIDTH
 @see #KEY_GRID_ROWS
 @see #KEY_GRID_COLUMNS
*/
KEY_TILE_HEIGHT : &quot;tile-height&quot;,
<span id='android-media-MediaFormat-property-KEY_GRID_ROWS'>/** A key describing the number of grid rows in the content in a
</span> {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.

 Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.

 @see #KEY_TILE_WIDTH
 @see #KEY_TILE_HEIGHT
 @see #KEY_GRID_COLUMNS
*/
KEY_GRID_ROWS : &quot;grid-rows&quot;,
<span id='android-media-MediaFormat-property-KEY_GRID_COLUMNS'>/** A key describing the number of grid columns in the content in a
</span> {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track. The associated value is an integer.

 Refer to {@link #MIMETYPE_IMAGE_ANDROID_HEIC} on decoding instructions of such tracks.

 @see #KEY_TILE_WIDTH
 @see #KEY_TILE_HEIGHT
 @see #KEY_GRID_ROWS
*/
KEY_GRID_COLUMNS : &quot;grid-cols&quot;,
<span id='android-media-MediaFormat-property-KEY_PCM_ENCODING'>/** A key describing the raw audio sample encoding/format.
</span>
 &lt;p&gt;The associated value is an integer, using one of the
 {@link android.media.AudioFormat}.ENCODING_PCM_ values.&lt;/p&gt;

 &lt;p&gt;This is an optional key for audio decoders and encoders specifying the
 desired raw audio sample format during {@link android.media.MediaCodec#configure
 android.media.MediaCodec.configure(&amp;hellip;)} call. Use {@link android.media.MediaCodec#getInputFormat
 android.media.MediaCodec.getInput}/{@link android.media.MediaCodec#getandroid.media.MediaMuxer.OutputFormat android.media.MediaMuxer.OutputFormat(&amp;hellip;)}
 to confirm the actual format. For the PCM decoder this key specifies both
 input and output sample encodings.&lt;/p&gt;

 &lt;p&gt;This key is also used by {@link android.media.MediaExtractor} to specify the sample
 format of audio data, if it is specified.&lt;/p&gt;

 &lt;p&gt;If this key is missing, the raw audio sample format is signed 16-bit short.&lt;/p&gt;
*/
KEY_PCM_ENCODING : &quot;pcm-encoding&quot;,
<span id='android-media-MediaFormat-property-KEY_CAPTURE_RATE'>/** A key describing the capture rate of a video format in frames/sec.
</span> &lt;p&gt;
 When capture rate is different than the frame rate, it means that the
 video is acquired at a different rate than the playback, which produces
 slow motion or timelapse effect during playback. Application can use the
 value of this key to tell the relative speed ratio between capture and
 playback rates when the video was recorded.
 &lt;/p&gt;
 &lt;p&gt;
 The associated value is an integer or a float.
 &lt;/p&gt;
*/
KEY_CAPTURE_RATE : &quot;capture-rate&quot;,
<span id='android-media-MediaFormat-property-KEY_I_FRAME_INTERVAL'>/** A key describing the frequency of key frames expressed in seconds between key frames.
</span> &lt;p&gt;
 This key is used by video encoders.
 A negative value means no key frames are requested after the first frame.
 A zero value means a stream containing all key frames is requested.
 &lt;p class=note&gt;
 Most video encoders will convert this value of the number of non-key-frames between
 key-frames, using the {@linkplain #KEY_FRAME_RATE frame rate} information; therefore,
 if the actual frame rate differs (e.g. input frames are dropped or the frame rate
 changes), the &lt;strong&gt;time interval&lt;/strong&gt; between key frames will not be the
 configured value.
 &lt;p&gt;
 The associated value is an integer (or float since
 {@link android.os.Build.VERSION_CODES#N_MR1}).
*/
KEY_I_FRAME_INTERVAL : &quot;i-frame-interval&quot;,
<span id='android-media-MediaFormat-property-KEY_INTRA_REFRESH_PERIOD'>/** An optional key describing the period of intra refresh in frames. This is an
</span> optional parameter that applies only to video encoders. If encoder supports it
 ({@link android.media.MediaCodecInfo.CodecCapabilities#FEATURE_IntraRefresh}), the whole
 frame is completely refreshed after the specified period. Also for each frame,
 a fix subset of macroblocks must be intra coded which leads to more constant bitrate
 than inserting a key frame. This key is recommended for video streaming applications
 as it provides low-delay and good error-resilience. This key is ignored if the
 video encoder does not support the intra refresh feature. Use the output format to
 verify that this feature was enabled.
 The associated value is an integer.
*/
KEY_INTRA_REFRESH_PERIOD : &quot;intra-refresh-period&quot;,
<span id='android-media-MediaFormat-property-KEY_PREPEND_HEADER_TO_SYNC_FRAMES'>/** An optional key describing whether encoders prepend headers to sync frames (e.g.
</span> SPS and PPS to IDR frames for H.264). This is an optional parameter that applies only
 to video encoders. A video encoder may not support this feature; the component will fail
 to configure in that case. For other components, this key is ignored.

 The value is an integer, with 1 indicating to prepend headers to every sync frames,
 or 0 otherwise. The default value is 0.
*/
KEY_PREPEND_HEADER_TO_SYNC_FRAMES : &quot;prepend-sps-pps-to-idr-frames&quot;,
<span id='android-media-MediaFormat-property-KEY_TEMPORAL_LAYERING'>/** A key describing the temporal layering schema.  This is an optional parameter
</span> that applies only to video encoders.  Use {@link android.media.MediaCodec#getOutputFormat}
 after {@link android.media.MediaCodec#configure configure} to query if the encoder supports
 the desired schema. Supported values are {@code webrtc.vp8.N-layer},
 {@code android.generic.N}, {@code android.generic.N+M} and {@code none}, where
 {@code N} denotes the total number of non-bidirectional layers (which must be at least 1)
 and {@code M} denotes the total number of bidirectional layers (which must be non-negative).
 &lt;p class=note&gt;{@code android.generic.*} schemas have been added in {@link android.os.Build.VERSION_CODES#N_MR1}.
 &lt;p&gt;
 The encoder may support fewer temporal layers, in which case the output format
 will contain the configured schema. If the encoder does not support temporal
 layering, the output format will not have an entry with this key.
 The associated value is a string.
*/
KEY_TEMPORAL_LAYERING : &quot;ts-schema&quot;,
<span id='android-media-MediaFormat-property-KEY_STRIDE'>/** A key describing the stride of the video bytebuffer layout.
</span> Stride (or row increment) is the difference between the index of a pixel
 and that of the pixel directly underneath. For YUV 420 formats, the
 stride corresponds to the Y plane; the stride of the U and V planes can
 be calculated based on the color format, though it is generally undefined
 and depends on the device and release.
 The associated value is an integer, representing number of bytes.
*/
KEY_STRIDE : &quot;stride&quot;,
<span id='android-media-MediaFormat-property-KEY_SLICE_HEIGHT'>/** A key describing the plane height of a multi-planar (YUV) video bytebuffer layout.
</span> Slice height (or plane height/vertical stride) is the number of rows that must be skipped
 to get from the top of the Y plane to the top of the U plane in the bytebuffer. In essence
 the offset of the U plane is sliceHeight * stride. The height of the U/V planes
 can be calculated based on the color format, though it is generally undefined
 and depends on the device and release.
 The associated value is an integer, representing number of rows.
*/
KEY_SLICE_HEIGHT : &quot;slice-height&quot;,
<span id='android-media-MediaFormat-property-KEY_REPEAT_PREVIOUS_FRAME_AFTER'>/** Applies only when configuring a video encoder in &quot;surface-input&quot; mode.
</span> The associated value is a long and gives the time in microseconds
 after which the frame previously submitted to the encoder will be
 repeated (once) if no new frame became available since.
*/
KEY_REPEAT_PREVIOUS_FRAME_AFTER : &quot;repeat-previous-frame-after&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_FPS_TO_ENCODER'>/** Instruct the video encoder in &quot;surface-input&quot; mode to drop excessive
</span> frames from the source, so that the input frame rate to the encoder
 does not exceed the specified fps.

 The associated value is a float, representing the max frame rate to
 feed the encoder at.

*/
KEY_MAX_FPS_TO_ENCODER : &quot;max-fps-to-encoder&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_PTS_GAP_TO_ENCODER'>/** Instruct the video encoder in &quot;surface-input&quot; mode to limit the gap of
</span> timestamp between any two adjacent frames fed to the encoder to the
 specified amount (in micro-second).

 The associated value is a long int. When positive, it represents the max
 timestamp gap between two adjacent frames fed to the encoder. When negative,
 the absolute value represents a fixed timestamp gap between any two adjacent
 frames fed to the encoder. Note that this will also apply even when the
 original timestamp goes backward in time. Under normal conditions, such frames
 would be dropped and not sent to the encoder.

 The output timestamp will be restored to the original timestamp and will
 not be affected.

 This is used in some special scenarios where input frames arrive sparingly
 but it's undesirable to allocate more bits to any single frame, or when it's
 important to ensure all frames are captured (rather than captured in the
 correct order).

*/
KEY_MAX_PTS_GAP_TO_ENCODER : &quot;max-pts-gap-to-encoder&quot;,
<span id='android-media-MediaFormat-property-KEY_CREATE_INPUT_SURFACE_SUSPENDED'>/** If specified when configuring a video encoder that's in &quot;surface-input&quot;
</span> mode, it will instruct the encoder to put the surface source in suspended
 state when it's connected. No video frames will be accepted until a resume
 operation (see {@link android.media.MediaCodec#PARAMETER_KEY_SUSPEND}), optionally with
 timestamp specified via {@link android.media.MediaCodec#PARAMETER_KEY_SUSPEND_TIME}, is
 received.

 The value is an integer, with 1 indicating to create with the surface
 source suspended, or 0 otherwise. The default value is 0.

 If this key is not set or set to 0, the surface source will accept buffers
 as soon as it's connected to the encoder (although they may not be encoded
 immediately). This key can be used when the client wants to prepare the
 encoder session in advance, but do not want to accept buffers immediately.
*/
KEY_CREATE_INPUT_SURFACE_SUSPENDED : &quot;create-input-buffers-suspended&quot;,
<span id='android-media-MediaFormat-property-KEY_PUSH_BLANK_BUFFERS_ON_STOP'>/** If specified when configuring a video decoder rendering to a surface,
</span> causes the decoder to output &quot;blank&quot;, i.e. black frames to the surface
 when stopped to clear out any previously displayed contents.
 The associated value is an integer of value 1.
*/
KEY_PUSH_BLANK_BUFFERS_ON_STOP : &quot;push-blank-buffers-on-shutdown&quot;,
<span id='android-media-MediaFormat-property-KEY_DURATION'>/** A key describing the duration (in microseconds) of the content.
</span> The associated value is a long.
*/
KEY_DURATION : &quot;durationUs&quot;,
<span id='android-media-MediaFormat-property-KEY_IS_ADTS'>/** A key mapping to a value of 1 if the content is AAC audio and
</span> audio frames are prefixed with an ADTS header.
 The associated value is an integer (0 or 1).
 This key is only supported when _decoding_ content, it cannot
 be used to configure an encoder to emit ADTS output.
*/
KEY_IS_ADTS : &quot;is-adts&quot;,
<span id='android-media-MediaFormat-property-KEY_CHANNEL_MASK'>/** A key describing the channel composition of audio content. This mask
</span> is composed of bits drawn from channel mask definitions in {@link android.media.AudioFormat}.
 The associated value is an integer.
*/
KEY_CHANNEL_MASK : &quot;channel-mask&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_PROFILE'>/** A key describing the AAC profile to be used (AAC audio formats only).
</span> Constants are declared in {@link android.media.MediaCodecInfo.CodecProfileLevel}.
*/
KEY_AAC_PROFILE : &quot;aac-profile&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_SBR_MODE'>/** A key describing the AAC SBR mode to be used (AAC audio formats only).
</span> The associated value is an integer and can be set to following values:
 &lt;ul&gt;
 &lt;li&gt;0 - no SBR should be applied&lt;/li&gt;
 &lt;li&gt;1 - single rate SBR&lt;/li&gt;
 &lt;li&gt;2 - double rate SBR&lt;/li&gt;
 &lt;/ul&gt;
 Note: If this key is not defined the default SRB mode for the desired AAC profile will
 be used.
 &lt;p&gt;This key is only used during encoding.
*/
KEY_AAC_SBR_MODE : &quot;aac-sbr-mode&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT'>/** A key describing the maximum number of channels that can be output by the AAC decoder.
</span> By default, the decoder will output the same number of channels as present in the encoded
 stream, if supported. Set this value to limit the number of output channels, and use
 the downmix information in the stream, if available.
 &lt;p&gt;Values larger than the number of channels in the content to decode are ignored.
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_MAX_OUTPUT_CHANNEL_COUNT : &quot;aac-max-output-channel_count&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_DRC_TARGET_REFERENCE_LEVEL'>/** A key describing a gain to be applied so that the output loudness matches the
</span> Target Reference Level. This is typically used to normalize loudness across program items.
 The gain is derived as the difference between the Target Reference Level and the
 Program Reference Level. The latter can be given in the bitstream and indicates the actual
 loudness value of the program item.
 &lt;p&gt;The Target Reference Level controls loudness normalization for both MPEG-4 DRC and
 MPEG-D DRC.
 &lt;p&gt;The value is given as an integer value between
 40 and 127, and is calculated as -4 * Target Reference Level in LKFS.
 Therefore, it represents the range of -10 to -31.75 LKFS.
 &lt;p&gt;The default value on mobile devices is 64 (-16 LKFS).
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_DRC_TARGET_REFERENCE_LEVEL : &quot;aac-target-ref-level&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_DRC_EFFECT_TYPE'>/** A key describing for selecting the DRC effect type for MPEG-D DRC.
</span> The supported values are defined in ISO/IEC 23003-4:2015 and are described as follows:
 &lt;table&gt;
 &lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Effect&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;-1&lt;/th&gt;&lt;th&gt;Off&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;0&lt;/th&gt;&lt;th&gt;None&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;Late night&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;2&lt;/th&gt;&lt;th&gt;Noisy environment&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;3&lt;/th&gt;&lt;th&gt;Limited playback range&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;4&lt;/th&gt;&lt;th&gt;Low playback level&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;5&lt;/th&gt;&lt;th&gt;Dialog enhancement&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;th&gt;6&lt;/th&gt;&lt;th&gt;General compression&lt;/th&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;The value -1 (Off) disables DRC processing, while loudness normalization may still be
 active and dependent on KEY_AAC_DRC_TARGET_REFERENCE_LEVEL.&lt;br&gt;
 The value 0 (None) automatically enables DRC processing if necessary to prevent signal
 clipping&lt;br&gt;
 The value 6 (General compression) can be used for enabling MPEG-D DRC without particular
 DRC effect type request.&lt;br&gt;
 The default DRC effect type is 3 (&quot;Limited playback range&quot;) on mobile devices.
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_DRC_EFFECT_TYPE : &quot;aac-drc-effect-type&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_ENCODED_TARGET_LEVEL'>/** A key describing the target reference level that was assumed at the encoder for
</span> calculation of attenuation gains for clipping prevention.
 &lt;p&gt;If it is known, this information can be provided as an integer value between
 0 and 127, which is calculated as -4 * Encoded Target Level in LKFS.
 If the Encoded Target Level is unknown, the value can be set to -1.
 &lt;p&gt;The default value is -1 (unknown).
 &lt;p&gt;The value is ignored when heavy compression is used (see
 {@link #KEY_AAC_DRC_HEAVY_COMPRESSION}).
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_ENCODED_TARGET_LEVEL : &quot;aac-encoded-target-level&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_DRC_BOOST_FACTOR'>/** A key describing the boost factor allowing to adapt the dynamics of the output to the
</span> actual listening requirements. This relies on DRC gain sequences that can be transmitted in
 the encoded bitstream to be able to reduce the dynamics of the output signal upon request.
 This factor enables the user to select how much of the gains are applied.
 &lt;p&gt;Positive gains (boost) and negative gains (attenuation, see
 {@link #KEY_AAC_DRC_ATTENUATION_FACTOR}) can be controlled separately for a better match
 to different use-cases.
 &lt;p&gt;Typically, attenuation gains are sent for loud signal segments, and boost gains are sent
 for soft signal segments. If the output is listened to in a noisy environment, for example,
 the boost factor is used to enable the positive gains, i.e. to amplify soft signal segments
 beyond the noise floor. But for listening late at night, the attenuation
 factor is used to enable the negative gains, to prevent loud signal from surprising
 the listener. In applications which generally need a low dynamic range, both the boost factor
 and the attenuation factor are used in order to enable all DRC gains.
 &lt;p&gt;In order to prevent clipping, it is also recommended to apply the attenuation gains
 in case of a downmix and/or loudness normalization to high target reference levels.
 &lt;p&gt;Both the boost and the attenuation factor parameters are given as integer values
 between 0 and 127, representing the range of the factor of 0 (i.e. don't apply)
 to 1 (i.e. fully apply boost/attenuation gains respectively).
 &lt;p&gt;The default value is 127 (fully apply boost DRC gains).
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_DRC_BOOST_FACTOR : &quot;aac-drc-boost-level&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_DRC_ATTENUATION_FACTOR'>/** A key describing the attenuation factor allowing to adapt the dynamics of the output to the
</span> actual listening requirements.
 See {@link #KEY_AAC_DRC_BOOST_FACTOR} for a description of the role of this attenuation
 factor and the value range.
 &lt;p&gt;The default value is 127 (fully apply attenuation DRC gains).
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_DRC_ATTENUATION_FACTOR : &quot;aac-drc-cut-level&quot;,
<span id='android-media-MediaFormat-property-KEY_AAC_DRC_HEAVY_COMPRESSION'>/** A key describing the selection of the heavy compression profile for DRC.
</span> Two separate DRC gain sequences can be transmitted in one bitstream: MPEG-4 DRC light
 compression, and DVB-specific heavy compression. When selecting the application of the heavy
 compression, one of the sequences is selected:
 &lt;ul&gt;
 &lt;li&gt;0 enables light compression,&lt;/li&gt;
 &lt;li&gt;1 enables heavy compression instead.
 &lt;/ul&gt;
 Note that only light compression offers the features of scaling of DRC gains
 (see {@link #KEY_AAC_DRC_BOOST_FACTOR} and {@link #KEY_AAC_DRC_ATTENUATION_FACTOR} for the
 boost and attenuation factors, and frequency-selective (multiband) DRC.
 Light compression usually contains clipping prevention for stereo downmixing while heavy
 compression, if additionally provided in the bitstream, is usually stronger, and contains
 clipping prevention for stereo and mono downmixing.
 &lt;p&gt;The default is 1 (heavy compression).
 &lt;p&gt;This key is only used during decoding.
*/
KEY_AAC_DRC_HEAVY_COMPRESSION : &quot;aac-drc-heavy-compression&quot;,
<span id='android-media-MediaFormat-property-KEY_FLAC_COMPRESSION_LEVEL'>/** A key describing the FLAC compression level to be used (FLAC audio format only).
</span> The associated value is an integer ranging from 0 (fastest, least compression)
 to 8 (slowest, most compression).
*/
KEY_FLAC_COMPRESSION_LEVEL : &quot;flac-compression-level&quot;,
<span id='android-media-MediaFormat-property-KEY_COMPLEXITY'>/** A key describing the encoding complexity.
</span> The associated value is an integer.  These values are device and codec specific,
 but lower values generally result in faster and/or less power-hungry encoding.

 @see MediaCodecInfo.EncoderCapabilities#getComplexityRange()
*/
KEY_COMPLEXITY : &quot;complexity&quot;,
<span id='android-media-MediaFormat-property-KEY_QUALITY'>/** A key describing the desired encoding quality.
</span> The associated value is an integer.  This key is only supported for encoders
 that are configured in constant-quality mode.  These values are device and
 codec specific, but lower values generally result in more efficient
 (smaller-sized) encoding.

 @see MediaCodecInfo.EncoderCapabilities#getQualityRange()
*/
KEY_QUALITY : &quot;quality&quot;,
<span id='android-media-MediaFormat-property-KEY_PRIORITY'>/** A key describing the desired codec priority.
</span> &lt;p&gt;
 The associated value is an integer. Higher value means lower priority.
 &lt;p&gt;
 Currently, only two levels are supported:&lt;br&gt;
 0: realtime priority - meaning that the codec shall support the given
    performance configuration (e.g. framerate) at realtime. This should
    only be used by media playback, capture, and possibly by realtime
    communication scenarios if best effort performance is not suitable.&lt;br&gt;
 1: non-realtime priority (best effort).
 &lt;p&gt;
 This is a hint used at codec configuration and resource planning - to understand
 the realtime requirements of the application; however, due to the nature of
 media components, performance is not guaranteed.

*/
KEY_PRIORITY : &quot;priority&quot;,
<span id='android-media-MediaFormat-property-KEY_OPERATING_RATE'>/** A key describing the desired operating frame rate for video or sample rate for audio
</span> that the codec will need to operate at.
 &lt;p&gt;
 The associated value is an integer or a float representing frames-per-second or
 samples-per-second
 &lt;p&gt;
 This is used for cases like high-speed/slow-motion video capture, where the video encoder
 format contains the target playback rate (e.g. 30fps), but the component must be able to
 handle the high operating capture rate (e.g. 240fps).
 &lt;p&gt;
 This rate will be used by codec for resource planning and setting the operating points.

*/
KEY_OPERATING_RATE : &quot;operating-rate&quot;,
<span id='android-media-MediaFormat-property-KEY_PROFILE'>/** A key describing the desired profile to be used by an encoder.
</span> The associated value is an integer.
 Constants are declared in {@link android.media.MediaCodecInfo.CodecProfileLevel}.
 This key is used as a hint, and is only supported for codecs
 that specify a profile. Note: Codecs are free to use all the available
 coding tools at the specified profile.

 @see MediaCodecInfo.CodecCapabilities#profileLevels
*/
KEY_PROFILE : &quot;profile&quot;,
<span id='android-media-MediaFormat-property-KEY_LEVEL'>/** A key describing the desired profile to be used by an encoder.
</span> The associated value is an integer.
 Constants are declared in {@link android.media.MediaCodecInfo.CodecProfileLevel}.
 This key is used as a further hint when specifying a desired profile,
 and is only supported for codecs that specify a level.
 &lt;p&gt;
 This key is ignored if the {@link #KEY_PROFILE profile} is not specified.

 @see MediaCodecInfo.CodecCapabilities#profileLevels
*/
KEY_LEVEL : &quot;level&quot;,
<span id='android-media-MediaFormat-property-KEY_LATENCY'>/** An optional key describing the desired encoder latency in frames. This is an optional
</span> parameter that applies only to video encoders. If encoder supports it, it should ouput
 at least one output frame after being queued the specified number of frames. This key
 is ignored if the video encoder does not support the latency feature. Use the output
 format to verify that this feature was enabled and the actual value used by the encoder.
 &lt;p&gt;
 If the key is not specified, the default latency will be implenmentation specific.
 The associated value is an integer.
*/
KEY_LATENCY : &quot;latency&quot;,
<span id='android-media-MediaFormat-property-KEY_OUTPUT_REORDER_DEPTH'>/** An optional key describing the maximum number of non-display-order coded frames.
</span> This is an optional parameter that applies only to video encoders. Application should
 check the value for this key in the output format to see if codec will produce
 non-display-order coded frames. If encoder supports it, the output frames' order will be
 different from the display order and each frame's display order could be retrived from
 {@link android.media.MediaCodec.BufferInfo#presentationTimeUs}. Before API level 27, application may
 receive non-display-order coded frames even though the application did not request it.
 Note: Application should not rearrange the frames to display order before feeding them
 to {@link android.media.MediaMuxer#writeSampleData}.
 &lt;p&gt;
 The default value is 0.
*/
KEY_OUTPUT_REORDER_DEPTH : &quot;output-reorder-depth&quot;,
<span id='android-media-MediaFormat-property-KEY_ROTATION'>/** A key describing the desired clockwise rotation on an output surface.
</span> This key is only used when the codec is configured using an output surface.
 The associated value is an integer, representing degrees. Supported values
 are 0, 90, 180 or 270. This is an optional field; if not specified, rotation
 defaults to 0.

 @see MediaCodecInfo.CodecCapabilities#profileLevels
*/
KEY_ROTATION : &quot;rotation-degrees&quot;,
<span id='android-media-MediaFormat-property-KEY_BITRATE_MODE'>/** A key describing the desired bitrate mode to be used by an encoder.
</span> Constants are declared in {@link android.media.MediaCodecInfo.CodecCapabilities}.

 @see MediaCodecInfo.EncoderCapabilities#isBitrateModeSupported(int)
*/
KEY_BITRATE_MODE : &quot;bitrate-mode&quot;,
<span id='android-media-MediaFormat-property-KEY_AUDIO_SESSION_ID'>/** A key describing the audio session ID of the AudioTrack associated
</span> to a tunneled video codec.
 The associated value is an integer.

 @see MediaCodecInfo.CodecCapabilities#FEATURE_TunneledPlayback
*/
KEY_AUDIO_SESSION_ID : &quot;audio-session-id&quot;,
<span id='android-media-MediaFormat-property-KEY_IS_AUTOSELECT'>/** A key for boolean AUTOSELECT behavior for the track. Tracks with AUTOSELECT=true
</span> are considered when automatically selecting a track without specific user
 choice, based on the current locale.
 This is currently only used for subtitle tracks, when the user selected
 'Default' for the captioning locale.
 The associated value is an integer, where non-0 means TRUE.  This is an optional
 field; if not specified, AUTOSELECT defaults to TRUE.
*/
KEY_IS_AUTOSELECT : &quot;is-autoselect&quot;,
<span id='android-media-MediaFormat-property-KEY_IS_DEFAULT'>/** A key for boolean DEFAULT behavior for the track. The track with DEFAULT=true is
</span> selected in the absence of a specific user choice.
 This is currently used in two scenarios:
 1) for subtitle tracks, when the user selected 'Default' for the captioning locale.
 2) for a {@link #MIMETYPE_IMAGE_ANDROID_HEIC} track, indicating the image is the
 primary item in the file.

 The associated value is an integer, where non-0 means TRUE.  This is an optional
 field; if not specified, DEFAULT is considered to be FALSE.
*/
KEY_IS_DEFAULT : &quot;is-default&quot;,
<span id='android-media-MediaFormat-property-KEY_IS_FORCED_SUBTITLE'>/** A key for the FORCED field for subtitle tracks. True if it is a
</span> forced subtitle track.  Forced subtitle tracks are essential for the
 content and are shown even when the user turns off Captions.  They
 are used for example to translate foreign/alien dialogs or signs.
 The associated value is an integer, where non-0 means TRUE.  This is an
 optional field; if not specified, FORCED defaults to FALSE.
*/
KEY_IS_FORCED_SUBTITLE : &quot;is-forced-subtitle&quot;,
<span id='android-media-MediaFormat-property-KEY_HAPTIC_CHANNEL_COUNT'>/** A key describing the number of haptic channels in an audio format.
</span> The associated value is an integer.
*/
KEY_HAPTIC_CHANNEL_COUNT : &quot;haptic-channel-count&quot;,
<span id='android-media-MediaFormat-property-KEY_IS_TIMED_TEXT'>/**@hide */
</span>KEY_IS_TIMED_TEXT : &quot;is-timed-text&quot;,
<span id='android-media-MediaFormat-property-KEY_COLOR_STANDARD'>/** An optional key describing the color primaries, white point and
</span> luminance factors for video content.

 The associated value is an integer: 0 if unspecified, or one of the
 COLOR_STANDARD_ values.
*/
KEY_COLOR_STANDARD : &quot;color-standard&quot;,
<span id='android-media-MediaFormat-property-COLOR_STANDARD_BT709'>/**BT.709 color chromacity coordinates with KR = 0.2126, KB = 0.0722. */
</span>COLOR_STANDARD_BT709 : &quot;1&quot;,
<span id='android-media-MediaFormat-property-COLOR_STANDARD_BT601_PAL'>/**BT.601 625 color chromacity coordinates with KR = 0.299, KB = 0.114. */
</span>COLOR_STANDARD_BT601_PAL : &quot;2&quot;,
<span id='android-media-MediaFormat-property-COLOR_STANDARD_BT601_NTSC'>/**BT.601 525 color chromacity coordinates with KR = 0.299, KB = 0.114. */
</span>COLOR_STANDARD_BT601_NTSC : &quot;4&quot;,
<span id='android-media-MediaFormat-property-COLOR_STANDARD_BT2020'>/**BT.2020 color chromacity coordinates with KR = 0.2627, KB = 0.0593. */
</span>COLOR_STANDARD_BT2020 : &quot;6&quot;,
<span id='android-media-MediaFormat-property-KEY_COLOR_TRANSFER'>/** An optional key describing the opto-electronic transfer function used
</span> for the video content.

 The associated value is an integer: 0 if unspecified, or one of the
 COLOR_TRANSFER_ values.
*/
KEY_COLOR_TRANSFER : &quot;color-transfer&quot;,
<span id='android-media-MediaFormat-property-COLOR_TRANSFER_LINEAR'>/**Linear transfer characteristic curve. */
</span>COLOR_TRANSFER_LINEAR : &quot;1&quot;,
<span id='android-media-MediaFormat-property-COLOR_TRANSFER_SDR_VIDEO'>/**SMPTE 170M transfer characteristic curve used by BT.601/BT.709/BT.2020. This is the curve
</span>  used by most non-HDR video content. */
COLOR_TRANSFER_SDR_VIDEO : &quot;3&quot;,
<span id='android-media-MediaFormat-property-COLOR_TRANSFER_ST2084'>/**SMPTE ST 2084 transfer function. This is used by some HDR video content. */
</span>COLOR_TRANSFER_ST2084 : &quot;6&quot;,
<span id='android-media-MediaFormat-property-COLOR_TRANSFER_HLG'>/**ARIB STD-B67 hybrid-log-gamma transfer function. This is used by some HDR video content. */
</span>COLOR_TRANSFER_HLG : &quot;7&quot;,
<span id='android-media-MediaFormat-property-KEY_COLOR_RANGE'>/** An optional key describing the range of the component values of the video content.
</span>
 The associated value is an integer: 0 if unspecified, or one of the
 COLOR_RANGE_ values.
*/
KEY_COLOR_RANGE : &quot;color-range&quot;,
<span id='android-media-MediaFormat-property-COLOR_RANGE_LIMITED'>/**Limited range. Y component values range from 16 to 235 for 8-bit content.
</span>  Cr, Cy values range from 16 to 240 for 8-bit content.
  This is the default for video content. */
COLOR_RANGE_LIMITED : &quot;2&quot;,
<span id='android-media-MediaFormat-property-COLOR_RANGE_FULL'>/**Full range. Y, Cr and Cb component values range from 0 to 255 for 8-bit content. */
</span>COLOR_RANGE_FULL : &quot;1&quot;,
<span id='android-media-MediaFormat-property-KEY_HDR_STATIC_INFO'>/** An optional key describing the static metadata of HDR (high-dynamic-range) video content.
</span>
 The associated value is a ByteBuffer. This buffer contains the raw contents of the
 Static Metadata Descriptor (including the descriptor ID) of an HDMI Dynamic Range and
 Mastering InfoFrame as defined by CTA-861.3. This key must be provided to video decoders
 for HDR video content unless this information is contained in the bitstream and the video
 decoder supports an HDR-capable profile. This key must be provided to video encoders for
 HDR video content.
*/
KEY_HDR_STATIC_INFO : &quot;hdr-static-info&quot;,
<span id='android-media-MediaFormat-property-KEY_HDR10_PLUS_INFO'>/** An optional key describing the HDR10+ metadata of the video content.
</span>
 The associated value is a ByteBuffer containing HDR10+ metadata conforming to the
 user_data_registered_itu_t_t35() syntax of SEI message for ST 2094-40. This key will
 be present on:
&lt;p&gt;
 - The formats of output buffers of a decoder configured for HDR10+ profiles (such as
   {@link android.media.MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus}, {@link android.media.MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus} or {@link android.media.MediaCodecInfo.CodecProfileLevel#HEVCProfileMain10HDR10Plus}), or
&lt;p&gt;
 - The formats of output buffers of an encoder configured for an HDR10+ profiles that
   uses out-of-band metadata (such as {@link android.media.MediaCodecInfo.CodecProfileLevel#VP9Profile2HDR10Plus} or {@link android.media.MediaCodecInfo.CodecProfileLevel#VP9Profile3HDR10Plus}).

 @see MediaCodec#PARAMETER_KEY_HDR10_PLUS_INFO
*/
KEY_HDR10_PLUS_INFO : &quot;hdr10-plus-info&quot;,
<span id='android-media-MediaFormat-property-KEY_TRACK_ID'>/** A key describing a unique ID for the content of a media track.
</span>
 &lt;p&gt;This key is used by {@link android.media.MediaExtractor}. Some extractors provide multiple encodings
 of the same track (e.g. float audio tracks for FLAC and WAV may be expressed as two
 tracks via MediaExtractor: a normal PCM track for backward compatibility, and a float PCM
 track for added fidelity. Similarly, Dolby Vision extractor may provide a baseline SDR
 version of a DV track.) This key can be used to identify which MediaExtractor tracks refer
 to the same underlying content.
 &lt;/p&gt;

 The associated value is an integer.
*/
KEY_TRACK_ID : &quot;track-id&quot;,
<span id='android-media-MediaFormat-property-KEY_CA_SYSTEM_ID'>/** A key describing the system id of the conditional access system used to scramble
</span> a media track.
 &lt;p&gt;
 This key is set by {@link android.media.MediaExtractor} if the track is scrambled with a conditional
 access system, regardless of the presence of a valid {@link android.media.MediaCas} object.
 &lt;p&gt;
 The associated value is an integer.
 @hide
*/
KEY_CA_SYSTEM_ID : &quot;ca-system-id&quot;,
<span id='android-media-MediaFormat-property-KEY_CA_SESSION_ID'>/** A key describing the {@link android.media.MediaCas.Session} object associated with a media track.
</span> &lt;p&gt;
 This key is set by {@link android.media.MediaExtractor} if the track is scrambled with a conditional
 access system, after it receives a valid {@link android.media.MediaCas} object.
 &lt;p&gt;
 The associated value is a ByteBuffer.
 @hide
*/
KEY_CA_SESSION_ID : &quot;ca-session-id&quot;,
<span id='android-media-MediaFormat-property-KEY_CA_PRIVATE_DATA'>/** A key describing the private data in the CA_descriptor associated with a media track.
</span> &lt;p&gt;
 This key is set by {@link android.media.MediaExtractor} if the track is scrambled with a conditional
 access system, before it receives a valid {@link android.media.MediaCas} object.
 &lt;p&gt;
 The associated value is a ByteBuffer.
 @hide
*/
KEY_CA_PRIVATE_DATA : &quot;ca-private-data&quot;,
<span id='android-media-MediaFormat-property-KEY_MAX_B_FRAMES'>/** A key describing the maximum number of B frames between I or P frames,
</span> to be used by a video encoder.
 The associated value is an integer. The default value is 0, which means
 that no B frames are allowed. Note that non-zero value does not guarantee
 B frames; it's up to the encoder to decide.
*/
KEY_MAX_B_FRAMES : &quot;max-bframes&quot;,
<span id='android-media-MediaFormat-property-TYPE_NULL'>/***/
</span>TYPE_NULL : &quot;0&quot;,
<span id='android-media-MediaFormat-property-TYPE_INTEGER'>/***/
</span>TYPE_INTEGER : &quot;1&quot;,
<span id='android-media-MediaFormat-property-TYPE_LONG'>/***/
</span>TYPE_LONG : &quot;2&quot;,
<span id='android-media-MediaFormat-property-TYPE_FLOAT'>/***/
</span>TYPE_FLOAT : &quot;3&quot;,
<span id='android-media-MediaFormat-property-TYPE_STRING'>/***/
</span>TYPE_STRING : &quot;4&quot;,
<span id='android-media-MediaFormat-property-TYPE_BYTE_BUFFER'>/***/
</span>TYPE_BYTE_BUFFER : &quot;5&quot;,
<span id='android-media-MediaFormat-property-KEY_FEATURE_'>/** A key prefix used together with a {@link android.media.MediaCodecInfo.CodecCapabilities}
</span> feature name describing a required or optional feature for a codec capabilities
 query.
 The associated value is an integer, where non-0 value means the feature is
 requested to be present, while 0 value means the feature is requested to be not
 present.
 @see MediaCodecList#findDecoderForFormat
 @see MediaCodecList#findEncoderForFormat
 @see MediaCodecInfo.CodecCapabilities#isFormatSupported

 @hide
*/
KEY_FEATURE_ : &quot;feature-&quot;,
<span id='android-media-MediaFormat-method-containsKey'>/**Returns true iff a key of the given name exists in the format.
</span>*/
containsKey : function(  ) {},

<span id='android-media-MediaFormat-method-containsFeature'>/**Returns true iff a feature of the given name exists in the format.
</span>*/
containsFeature : function(  ) {},

<span id='android-media-MediaFormat-method-getValueTypeForKey'>/**Returns the value type for a key. If the key does not exist, it returns TYPE_NULL.
</span>*/
getValueTypeForKey : function(  ) {},

<span id='android-media-MediaFormat-method-getNumber'>/**Returns the value of a numeric key. This is provided as a convenience method for keys
</span> that may take multiple numeric types, such as {@link #KEY_FRAME_RATE}, or {@link #KEY_I_FRAME_INTERVAL}.
@return {Object {java.lang.Number}} null if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is ByteBuffer or String
*/
getNumber : function(  ) {},

<span id='android-media-MediaFormat-method-getNumber'>/**Returns the value of a numeric key, or the default value if the key is missing.
</span>@return {Object {java.lang.Number}} defaultValue if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is ByteBuffer or String
*/
getNumber : function(  ) {},

<span id='android-media-MediaFormat-method-getInteger'>/**Returns the value of an integer key.
</span>@throws NullPointerException if the key does not exist or the stored value for the key is
         null
@throws ClassCastException if the stored value for the key is long, float, ByteBuffer or
         String
*/
getInteger : function(  ) {},

<span id='android-media-MediaFormat-method-getInteger'>/**Returns the value of an integer key, or the default value if the key is missing.
</span>@return {Number} defaultValue if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is long, float, ByteBuffer or
         String
*/
getInteger : function(  ) {},

<span id='android-media-MediaFormat-method-getLong'>/**Returns the value of a long key.
</span>@throws NullPointerException if the key does not exist or the stored value for the key is
         null
@throws ClassCastException if the stored value for the key is int, float, ByteBuffer or
         String
*/
getLong : function(  ) {},

<span id='android-media-MediaFormat-method-getLong'>/**Returns the value of an long key, or the default value if the key is missing.
</span>@return {Number} defaultValue if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is int, float, ByteBuffer or
         String
*/
getLong : function(  ) {},

<span id='android-media-MediaFormat-method-getFloat'>/**Returns the value of a float key.
</span>@throws NullPointerException if the key does not exist or the stored value for the key is
         null
@throws ClassCastException if the stored value for the key is int, long, ByteBuffer or
         String
*/
getFloat : function(  ) {},

<span id='android-media-MediaFormat-method-getFloat'>/**Returns the value of an float key, or the default value if the key is missing.
</span>@return {Number} defaultValue if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is int, long, ByteBuffer or
         String
*/
getFloat : function(  ) {},

<span id='android-media-MediaFormat-method-getString'>/**Returns the value of a string key.
</span>@return {String} null if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is int, long, float or ByteBuffer
*/
getString : function(  ) {},

<span id='android-media-MediaFormat-method-getString'>/**Returns the value of an string key, or the default value if the key is missing.
</span>@return {String} defaultValue if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is int, long, float or ByteBuffer
*/
getString : function(  ) {},

<span id='android-media-MediaFormat-method-getByteBuffer'>/**Returns the value of a ByteBuffer key.
</span>@return {Object {java.nio.ByteBuffer}} null if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is int, long, float or String
*/
getByteBuffer : function(  ) {},

<span id='android-media-MediaFormat-method-getByteBuffer'>/**Returns the value of a ByteBuffer key, or the default value if the key is missing.
</span>@return {Object {java.nio.ByteBuffer}} defaultValue if the key does not exist or the stored value for the key is null
@throws ClassCastException if the stored value for the key is int, long, float or String
*/
getByteBuffer : function(  ) {},

<span id='android-media-MediaFormat-method-getFeatureEnabled'>/**Returns whether a feature is to be enabled ({@code true}) or disabled
</span> ({@code false}).
@param {String} feature the name of a {@link MediaCodecInfo.CodecCapabilities} feature.
@throws IllegalArgumentException if the feature was neither set to be enabled
         nor to be disabled.
*/
getFeatureEnabled : function(  ) {},

<span id='android-media-MediaFormat-method-setInteger'>/**Sets the value of an integer key.
</span>*/
setInteger : function(  ) {},

<span id='android-media-MediaFormat-method-setLong'>/**Sets the value of a long key.
</span>*/
setLong : function(  ) {},

<span id='android-media-MediaFormat-method-setFloat'>/**Sets the value of a float key.
</span>*/
setFloat : function(  ) {},

<span id='android-media-MediaFormat-method-setString'>/**Sets the value of a string key.
</span> &lt;p&gt;
 If value is {@code null}, it sets a null value that behaves similarly to a missing key.
 This could be used prior to API level {@link android os.Build.VERSION_CODES#Q} to effectively
 remove a key.
*/
setString : function(  ) {},

<span id='android-media-MediaFormat-method-setByteBuffer'>/**Sets the value of a ByteBuffer key.
</span> &lt;p&gt;
 If value is {@code null}, it sets a null value that behaves similarly to a missing key.
 This could be used prior to API level {@link android os.Build.VERSION_CODES#Q} to effectively
 remove a key.
*/
setByteBuffer : function(  ) {},

<span id='android-media-MediaFormat-method-removeKey'>/**Removes a value of a given key if present. Has no effect if the key is not present.
</span>*/
removeKey : function(  ) {},

<span id='android-media-MediaFormat-method-removeFeature'>/**Removes a given feature setting if present. Has no effect if the feature setting is not
</span> present.
*/
removeFeature : function(  ) {},

<span id='android-media-MediaFormat-method-getKeys'>/**Returns a {@link java.util.Set Set} view of the keys contained in this MediaFormat.
</span>
 The set is backed by the MediaFormat object, so changes to the format are reflected in the
 set, and vice-versa. If the format is modified while an iteration over the set is in progress
 (except through the iterator's own remove operation), the results of the iteration are
 undefined. The set supports element removal, which removes the corresponding mapping from the
 format, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.
 It does not support the add or addAll operations.
*/
getKeys : function(  ) {},

<span id='android-media-MediaFormat-method-getFeatures'>/**Returns a {@link java.util.Set Set} view of the features contained in this MediaFormat.
</span>
 The set is backed by the MediaFormat object, so changes to the format are reflected in the
 set, and vice-versa. If the format is modified while an iteration over the set is in progress
 (except through the iterator's own remove operation), the results of the iteration are
 undefined. The set supports element removal, which removes the corresponding mapping from the
 format, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.
 It does not support the add or addAll operations.
*/
getFeatures : function(  ) {},

<span id='android-media-MediaFormat-method-setFeatureEnabled'>/**Sets whether a feature is to be enabled ({@code true}) or disabled
</span> ({@code false}).

 If {@code enabled} is {@code true}, the feature is requested to be present.
 Otherwise, the feature is requested to be not present.
@param {String} feature the name of a {@link MediaCodecInfo.CodecCapabilities} feature.
@see MediaCodecList#findDecoderForFormat
@see MediaCodecList#findEncoderForFormat
@see MediaCodecInfo.CodecCapabilities#isFormatSupported
*/
setFeatureEnabled : function(  ) {},

<span id='android-media-MediaFormat-method-createAudioFormat'>/**Creates a minimal audio format.
</span>@param {String} mime The mime type of the content.
@param {Number} sampleRate The sampling rate of the content.
@param {Number} channelCount The number of audio channels in the content.
*/
createAudioFormat : function(  ) {},

<span id='android-media-MediaFormat-method-createSubtitleFormat'>/**Creates a minimal subtitle format.
</span>@param {String} mime The mime type of the content.
@param {String} language The language of the content, using either ISO 639-1 or 639-2/T
        codes.  Specify null or &quot;und&quot; if language information is only included
        in the content.  (This will also work if there are multiple language
        tracks in the content.)
*/
createSubtitleFormat : function(  ) {},

<span id='android-media-MediaFormat-method-createVideoFormat'>/**Creates a minimal video format.
</span>@param {String} mime The mime type of the content.
@param {Number} width The width of the content (in pixels)
@param {Number} height The height of the content (in pixels)
*/
createVideoFormat : function(  ) {},

<span id='android-media-MediaFormat-method-toString'>/**
</span>*/
toString : function(  ) {},


};</pre>
</body>
</html>
