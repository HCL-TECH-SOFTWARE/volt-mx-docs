<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-media-AsyncPlayer'>/**@class android.media.AsyncPlayer
</span>@extends java.lang.Object

 Plays a series of audio URIs, but does all the hard work on another thread
 so that any slowness with preparing or loading doesn't block the calling thread.
*/
var AsyncPlayer = {

<span id='android-media-AsyncPlayer-method-play'>/**Start playing the sound.  It will actually start playing at some
</span> point in the future.  There are no guarantees about latency here.
 Calling this before another audio file is done playing will stop
 that one and start the new one.
@param {Object {Context}} context Your application's context.
@param {Object {Uri}} uri The URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})
@param {Boolean} looping Whether the audio should loop forever.  
          (see {@link MediaPlayer#setLooping(boolean)})
@param {Number} stream the AudioStream to use.
          (see {@link MediaPlayer#setAudioStreamType(int)})
@deprecated use {@link #play(Context, Uri, boolean, AudioAttributes)} instead
*/
play : function(  ) {},

<span id='android-media-AsyncPlayer-method-play'>/**Start playing the sound.  It will actually start playing at some
</span> point in the future.  There are no guarantees about latency here.
 Calling this before another audio file is done playing will stop
 that one and start the new one.
@param {Object {Context}} context the non-null application's context.
@param {Object {Uri}} uri the non-null URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})
@param {Boolean} looping whether the audio should loop forever.
          (see {@link MediaPlayer#setLooping(boolean)})
@param {Object {AudioAttributes}} attributes the non-null {@link AudioAttributes} to use.
          (see {@link MediaPlayer#setAudioAttributes(AudioAttributes)})
@throws IllegalArgumentException
*/
play : function(  ) {},

<span id='android-media-AsyncPlayer-method-stop'>/**Stop a previously played sound.  It can't be played again or unpaused
</span> at this point.  Calling this multiple times has no ill effects.
*/
stop : function(  ) {},

<span id='android-media-AsyncPlayer-method-setUsesWakeLock'>/**We want to hold a wake lock while we do the prepare and play.  The stop probably is
</span> optional, but it won't hurt to have it too.  The problem is that if you start a sound
 while you're holding a wake lock (e.g. an alarm starting a notification), you want the
 sound to play, but if the CPU turns off before mThread gets to work, it won't.  The
 simplest way to deal with this is to make it so there is a wake lock held while the
 thread is starting or running.  You're going to need the WAKE_LOCK permission if you're
 going to call this.

 This must be called before the first time play is called.
@hide 
*/
setUsesWakeLock : function(  ) {},


};</pre>
</body>
</html>
