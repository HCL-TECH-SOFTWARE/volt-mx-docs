Ext.data.JsonP.java_time_format_DateTimeFormatterBuilder({"tagname":"class","name":"java.time.format.DateTimeFormatterBuilder","autodetected":{},"files":[{"filename":"DateTimeFormatterBuilder.js","href":"DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder"}],"extends":"java.lang.Object","since":"1.8","members":[{"name":"append","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-append","meta":{}},{"name":"appendChronologyId","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendChronologyId","meta":{}},{"name":"appendChronologyText","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendChronologyText","meta":{}},{"name":"appendFraction","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendFraction","meta":{}},{"name":"appendInstant","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendInstant","meta":{}},{"name":"appendLiteral","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendLiteral","meta":{}},{"name":"appendLocalized","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendLocalized","meta":{}},{"name":"appendLocalizedOffset","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendLocalizedOffset","meta":{}},{"name":"appendOffset","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendOffset","meta":{}},{"name":"appendOffsetId","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendOffsetId","meta":{}},{"name":"appendOptional","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendOptional","meta":{}},{"name":"appendPattern","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendPattern","meta":{}},{"name":"appendText","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendText","meta":{}},{"name":"appendValue","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendValue","meta":{}},{"name":"appendValueReduced","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendValueReduced","meta":{}},{"name":"appendZoneId","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendZoneId","meta":{}},{"name":"appendZoneOrOffsetId","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendZoneOrOffsetId","meta":{}},{"name":"appendZoneRegionId","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendZoneRegionId","meta":{}},{"name":"appendZoneText","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-appendZoneText","meta":{}},{"name":"getLocalizedDateTimePattern","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-getLocalizedDateTimePattern","meta":{}},{"name":"optionalEnd","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-optionalEnd","meta":{}},{"name":"optionalStart","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-optionalStart","meta":{}},{"name":"padNext","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-padNext","meta":{}},{"name":"parseCaseInsensitive","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-parseCaseInsensitive","meta":{}},{"name":"parseCaseSensitive","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-parseCaseSensitive","meta":{}},{"name":"parseDefaulting","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-parseDefaulting","meta":{}},{"name":"parseLenient","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-parseLenient","meta":{}},{"name":"parseStrict","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-parseStrict","meta":{}},{"name":"toFormatter","tagname":"method","owner":"java.time.format.DateTimeFormatterBuilder","id":"method-toFormatter","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.time.format.DateTimeFormatterBuilder","short_doc":"Builder to create date-time formatters. ...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>java.time.format.DateTimeFormatterBuilder</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder' target='_blank'>DateTimeFormatterBuilder.js</a></div></pre><div class='doc-contents'><p>Builder to create date-time formatters.\n <p>\n This allows a {@code DateTimeFormatter} to be created.\n All date-time formatters are created ultimately using this builder.\n <p>\n The basic elements of date-time can all be added:\n <ul>\n <li>Value - a numeric value</li>\n <li>Fraction - a fractional value including the decimal place. Always use this when\n outputting fractions to ensure that the fraction is parsed correctly</li>\n <li>Text - the textual equivalent for the value</li>\n <li>OffsetId/Offset - the {@linkplain ZoneOffset zone offset}</li>\n <li>ZoneId - the {@linkplain ZoneId time-zone} id</li>\n <li>ZoneText - the name of the time-zone</li>\n <li>ChronologyId - the {@linkplain Chronology chronology} id</li>\n <li>ChronologyText - the name of the chronology</li>\n <li>Literal - a text literal</li>\n <li>Nested and Optional - formats can be nested or made optional</li>\n </ul>\n In addition, any of the elements may be decorated by padding, either with spaces or any other character.\n <p>\n Finally, a shorthand pattern, mostly compatible with {@code java.text.SimpleDateFormat SimpleDateFormat}\n can be used, see <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-appendPattern\" rel=\"java.time.format.DateTimeFormatterBuilder-method-appendPattern\" class=\"docClass\">appendPattern</a>(String).\n In practice, this simply parses the pattern and calls other methods on the builder.</p>\n\n<p> @implSpec\n This class is a mutable builder intended for use from a single thread.</p>\n        <p>Available since: <b>1.8</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-append' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-append' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-append' class='name expandable'>append</a>( <span class='pre'>formatter</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends all the elements of a formatter to the builder. ...</div><div class='long'><p>Appends all the elements of a formatter to the builder.\n <p>\n This method has the same effect as appending each of the constituent\n parts of the formatter directly to this builder.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>formatter</span> : Object {DateTimeFormatter}<div class='sub-desc'><p>the formatter to add, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendChronologyId' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendChronologyId' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendChronologyId' class='name expandable'>appendChronologyId</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter. ...</div><div class='long'><p>Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.\n <p>\n This appends an instruction to format/parse the chronology ID to the builder.\n <p>\n During formatting, the chronology is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.chronology().\n It will be printed using the result of Chronology.getId().\n If the chronology cannot be obtained then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n During parsing, the chronology is parsed and must match one of the chronologies\n in Chronology.getAvailableChronologies().\n If the chronology cannot be parsed then an exception is thrown unless the\n section of the formatter is optional.\n The parser uses the {@linkplain <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a>() case sensitive} setting.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendChronologyText' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendChronologyText' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendChronologyText' class='name expandable'>appendChronologyText</a>( <span class='pre'>textStyle</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the chronology name to the formatter. ...</div><div class='long'><p>Appends the chronology name to the formatter.\n <p>\n The calendar system name will be output during a format.\n If the chronology cannot be obtained then an exception will be thrown.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>textStyle</span> : Object {TextStyle}<div class='sub-desc'><p>the text style to use, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendFraction' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendFraction' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendFraction' class='name expandable'>appendFraction</a>( <span class='pre'>field, minWidth, maxWidth, decimalPoint</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the fractional value of a date-time field to the formatter. ...</div><div class='long'><p>Appends the fractional value of a date-time field to the formatter.\n <p>\n The fractional value of the field will be output including the\n preceding decimal point. The preceding value is not output.\n For example, the second-of-minute value of 15 would be output as {@code .25}.\n <p>\n The width of the printed fraction can be controlled. Setting the\n minimum width to zero will cause no output to be generated.\n The printed fraction will have the minimum width necessary between\n the minimum and maximum widths - trailing zeroes are omitted.\n No rounding occurs due to the maximum width - digits are simply dropped.\n <p>\n When parsing in strict mode, the number of parsed digits must be between\n the minimum and maximum width. When parsing in lenient mode, the minimum\n width is considered to be zero and the maximum is nine.\n <p>\n If the value cannot be obtained then an exception will be thrown.\n If the value is negative an exception will be thrown.\n If the field does not have a fixed set of valid values then an\n exception will be thrown.\n If the field value in the date-time to be printed is invalid it\n cannot be printed and an exception will be thrown.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>field</span> : Object {TemporalField}<div class='sub-desc'><p>the field to append, not null</p>\n</div></li><li><span class='pre'>minWidth</span> : Number<div class='sub-desc'><p>the minimum width of the field excluding the decimal point, from 0 to 9</p>\n</div></li><li><span class='pre'>maxWidth</span> : Number<div class='sub-desc'><p>the maximum width of the field excluding the decimal point, from 1 to 9</p>\n</div></li><li><span class='pre'>decimalPoint</span> : Boolean<div class='sub-desc'><p>whether to output the localized decimal point symbol</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the field has a variable set of valid values or\n  either width is invalid</p>\n</div></li></ul></div></div></div><div id='method-appendInstant' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendInstant' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendInstant' class='name expandable'>appendInstant</a>( <span class='pre'>fractionalDigits</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends an instant using ISO-8601 to the formatter with control over\n the number of fractional digits. ...</div><div class='long'><p>Appends an instant using ISO-8601 to the formatter with control over\n the number of fractional digits.\n <p>\n Instants have a fixed output format, although this method provides some\n control over the fractional digits. They are converted to a date-time\n with a zone-offset of UTC and printed using the standard ISO-8601 format.\n The localized decimal style is not used.\n <p>\n The {@code fractionalDigits} parameter allows the output of the fractional\n second to be controlled. Specifying zero will cause no fractional digits\n to be output. From 1 to 9 will output an increasing number of digits, using\n zero right-padding if necessary. The special value -1 is used to output as\n many digits as necessary to avoid any trailing zeroes.\n <p>\n When parsing in strict mode, the number of parsed digits must match the\n fractional digits. When parsing in lenient mode, any number of fractional\n digits from zero to nine are accepted.\n <p>\n The instant is obtained using INSTANT_SECONDS\n and optionally (@code NANO_OF_SECOND). The value of {@code INSTANT_SECONDS}\n may be outside the maximum range of {@code LocalDateTime}.\n <p>\n The {@linkplain <a href=\"#!/api/java.time.format.ResolverStyle\" rel=\"java.time.format.ResolverStyle\" class=\"docClass\">java.time.format.ResolverStyle</a> resolver style} has no effect on instant parsing.\n The end-of-day time of '24:00' is handled as midnight at the start of the following day.\n The leap-second time of '23:59:60' is handled to some degree, see\n java.time.format.DateTimeFormatter.parsedLeapSecond() for full details.\n <p>\n An alternative to this method is to format/parse the instant as a single\n epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fractionalDigits</span> : Number<div class='sub-desc'><p>the number of fractional second digits to format with,\n  from 0 to 9, or -1 to use as many digits as necessary</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendLiteral' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendLiteral' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendLiteral' class='name expandable'>appendLiteral</a>( <span class='pre'>literal</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends a string literal to the formatter. ...</div><div class='long'><p>Appends a string literal to the formatter.\n <p>\n This string will be output during a format.\n <p>\n If the literal is empty, nothing is added to the formatter.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>literal</span> : String<div class='sub-desc'><p>the literal to append, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendLocalized' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendLocalized' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendLocalized' class='name expandable'>appendLocalized</a>( <span class='pre'>dateStyle, timeStyle</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends a localized date-time pattern to the formatter. ...</div><div class='long'><p>Appends a localized date-time pattern to the formatter.\n <p>\n This appends a localized section to the builder, suitable for outputting\n a date, time or date-time combination. The format of the localized\n section is lazily looked up based on four items:\n <ul>\n <li>the {@code dateStyle} specified to this method\n <li>the {@code timeStyle} specified to this method\n <li>the {@code Locale} of the {@code DateTimeFormatter}\n <li>the {@code Chronology}, selecting the best available\n </li></li></li></li></ul>\n During formatting, the chronology is obtained from the temporal object\n being formatted, which may have been overridden by\n java.time.format.DateTimeFormatter.withChronology(Chronology).\n <p>\n During parsing, if a chronology has already been parsed, then it is used.\n Otherwise the default from {@code DateTimeFormatter.withChronology(Chronology)}\n is used, with {@code IsoChronology} as the fallback.\n <p>\n Note that this method provides similar functionality to methods on\n {@code DateFormat} such as int).</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>dateStyle</span> : Object {FormatStyle}<div class='sub-desc'><p>the date style to use, null means no date required</p>\n</div></li><li><span class='pre'>timeStyle</span> : Object {FormatStyle}<div class='sub-desc'><p>the time style to use, null means no time required</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if both the date and time styles are null</p>\n</div></li></ul></div></div></div><div id='method-appendLocalizedOffset' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendLocalizedOffset' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendLocalizedOffset' class='name expandable'>appendLocalizedOffset</a>( <span class='pre'>style</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the localized zone offset, such as 'GMT+01:00', to the formatter. ...</div><div class='long'><p>Appends the localized zone offset, such as 'GMT+01:00', to the formatter.\n <p>\n This appends a localized zone offset to the builder, the format of the\n localized offset is controlled by the specified <a href=\"#!/api/java.time.format.FormatStyle\" rel=\"java.time.format.FormatStyle\" class=\"docClass\">style</a>\n to this method:\n <ul>\n <li><a href=\"#!/api/java.time.format.TextStyle-property-FULL\" rel=\"java.time.format.TextStyle-property-FULL\" class=\"docClass\">full</a> - formats with localized offset text, such\n as 'GMT, 2-digit hour and minute field, optional second field if non-zero,\n and colon.\n <li><a href=\"#!/api/java.time.format.TextStyle-property-SHORT\" rel=\"java.time.format.TextStyle-property-SHORT\" class=\"docClass\">short</a> - formats with localized offset text,\n such as 'GMT, hour without leading zero, optional 2-digit minute and\n second if non-zero, and colon.\n </li></li></ul>\n <p>\n During formatting, the offset is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.offset().\n If the offset cannot be obtained then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n During parsing, the offset is parsed using the format defined above.\n If the offset cannot be parsed then an exception is thrown unless the\n section of the formatter is optional.\n <p></p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>style</span> : Object {TextStyle}<div class='sub-desc'><p>the format style to use, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if style is neither full nor short</p>\n</div></li></ul></div></div></div><div id='method-appendOffset' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendOffset' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendOffset' class='name expandable'>appendOffset</a>( <span class='pre'>pattern, noOffsetText</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the zone offset, such as '+01:00', to the formatter. ...</div><div class='long'><p>Appends the zone offset, such as '+01:00', to the formatter.\n <p>\n This appends an instruction to format/parse the offset ID to the builder.\n <p>\n During formatting, the offset is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.offset().\n It will be printed using the format defined below.\n If the offset cannot be obtained then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n During parsing, the offset is parsed using the format defined below.\n If the offset cannot be parsed then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n The format of the offset is controlled by a pattern which must be one\n of the following:\n <ul>\n <li>{@code +HH} - hour only, ignoring minute and second\n <li>{@code +HHmm} - hour, with minute if non-zero, ignoring second, no colon\n <li>{@code +HH:mm} - hour, with minute if non-zero, ignoring second, with colon\n <li>{@code +HHMM} - hour and minute, ignoring second, no colon\n <li>{@code +HH:MM} - hour and minute, ignoring second, with colon\n <li>{@code +HHMMss} - hour and minute, with second if non-zero, no colon\n <li>{@code +HH:MM:ss} - hour and minute, with second if non-zero, with colon\n <li>{@code +HHMMSS} - hour, minute and second, no colon\n <li>{@code +HH:MM:SS} - hour, minute and second, with colon\n </li></li></li></li></li></li></li></li></li></ul>\n The \"no offset\" text controls what text is printed when the total amount of\n the offset fields to be output is zero.\n Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.\n Three formats are accepted for parsing UTC - the \"no offset\" text, and the\n plus and minus versions of zero defined by the pattern.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>pattern</span> : String<div class='sub-desc'><p>the pattern to use, not null</p>\n</div></li><li><span class='pre'>noOffsetText</span> : String<div class='sub-desc'><p>the text to use when the offset is zero, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendOffsetId' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendOffsetId' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendOffsetId' class='name expandable'>appendOffsetId</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the zone offset, such as '+01:00', to the formatter. ...</div><div class='long'><p>Appends the zone offset, such as '+01:00', to the formatter.\n <p>\n This appends an instruction to format/parse the offset ID to the builder.\n This is equivalent to calling {@code appendOffset(\"+HH:MM:ss\", \"Z\")}.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendOptional' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendOptional' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendOptional' class='name expandable'>appendOptional</a>( <span class='pre'>formatter</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends a formatter to the builder which will optionally format/parse. ...</div><div class='long'><p>Appends a formatter to the builder which will optionally format/parse.\n <p>\n This method has the same effect as appending each of the constituent\n parts directly to this builder surrounded by an <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalStart\" rel=\"java.time.format.DateTimeFormatterBuilder-method-optionalStart\" class=\"docClass\">optionalStart</a>() and\n <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalEnd\" rel=\"java.time.format.DateTimeFormatterBuilder-method-optionalEnd\" class=\"docClass\">optionalEnd</a>().\n <p>\n The formatter will format if data is available for all the fields contained within it.\n The formatter will parse if the string matches, otherwise no error is returned.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>formatter</span> : Object {DateTimeFormatter}<div class='sub-desc'><p>the formatter to add, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendPattern' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendPattern' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendPattern' class='name expandable'>appendPattern</a>( <span class='pre'>pattern</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the elements defined by the specified pattern to the builder. ...</div><div class='long'><p>Appends the elements defined by the specified pattern to the builder.\n <p>\n All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n The characters '#', '{' and '}' are reserved for future use.\n The characters '[' and ']' indicate optional patterns.\n The following pattern letters are defined:</p>\n\n<pre>  Symbol  Meaning                     Presentation      Examples\n  ------  -------                     ------------      -------\n   G       era                         text              AD; Anno Domini; A\n   u       year                        year              2004; 04\n   y       year-of-era                 year              2004; 04\n   D       day-of-year                 number            189\n   M/L     month-of-year               number/text       7; 07; Jul; July; J\n   d       day-of-month                number            10\n\n   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter\n   Y       week-based-year             year              1996; 96\n   w       week-of-week-based-year     number            27\n   W       week-of-month               number            4\n   E       day-of-week                 text              Tue; Tuesday; T\n   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T\n   F       week-of-month               number            3\n\n   a       am-pm-of-day                text              PM\n   h       clock-hour-of-am-pm (1-12)  number            12\n   K       hour-of-am-pm (0-11)        number            0\n   k       clock-hour-of-am-pm (1-24)  number            0\n\n   H       hour-of-day (0-23)          number            0\n   m       minute-of-hour              number            30\n   s       second-of-minute            number            55\n   S       fraction-of-second          fraction          978\n   A       milli-of-day                number            1234\n   n       nano-of-second              number            987654321\n   N       nano-of-day                 number            1234000000\n\n   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30\n   z       time-zone name              zone-name         Pacific Standard Time; PST\n   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;\n   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;\n   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;\n   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;\n\n   p       pad next                    pad modifier      1\n\n   '       escape for text             delimiter\n   ''      single quote                literal           '\n   [       optional section start\n   ]       optional section end\n   #       reserved for future use\n   {       reserved for future use\n   }       reserved for future use\n </pre>\n\n\n<p> <p>\n The count of pattern letters determine the format.\n See <a href=\"DateTimeFormatter.html#patterns\">DateTimeFormatter</a> for a user-focused description of the patterns.\n The following tables define how the pattern letters map to the builder.\n <p>\n <b>Date fields</b>: Pattern letters to output a date.</p>\n\n<pre>  Pattern  Count  Equivalent builder methods\n  -------  -----  --------------------------\n    G       1      appendText(ChronoField.ERA, TextStyle.SHORT)\n    GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)\n    GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)\n    GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)\n    GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)\n\n    u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL);\n    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000);\n    uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL);\n    u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD);\n    y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL);\n    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000);\n    yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL);\n    y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD);\n    Y       1      append special localized WeekFields element for numeric week-based-year\n    YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits;\n    YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL);\n    Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD);\n\n    Q       1      appendValue(IsoFields.QUARTER_OF_YEAR);\n    QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);\n    QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)\n    QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)\n    QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)\n    q       1      appendValue(IsoFields.QUARTER_OF_YEAR);\n    qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);\n    qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)\n    qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)\n    qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)\n\n    M       1      appendValue(ChronoField.MONTH_OF_YEAR);\n    MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);\n    MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)\n    MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)\n    MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)\n    L       1      appendValue(ChronoField.MONTH_OF_YEAR);\n    LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);\n    LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)\n    LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)\n    LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)\n\n    w       1      append special localized WeekFields element for numeric week-of-year\n    ww      2      append special localized WeekFields element for numeric week-of-year, zero-padded\n    W       1      append special localized WeekFields element for numeric week-of-month\n    d       1      appendValue(ChronoField.DAY_OF_MONTH)\n    dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)\n    D       1      appendValue(ChronoField.DAY_OF_YEAR)\n    DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2)\n    DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)\n    F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)\n    E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)\n    EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)\n    EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)\n    EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)\n    EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)\n    e       1      append special localized WeekFields element for numeric day-of-week\n    ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded\n    eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)\n    eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)\n    eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)\n    c       1      append special localized WeekFields element for numeric day-of-week\n    ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)\n    cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)\n    ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE)\n </pre>\n\n\n<p> <p>\n <b>Time fields</b>: Pattern letters to output a time.</p>\n\n<pre>  Pattern  Count  Equivalent builder methods\n  -------  -----  --------------------------\n    a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)\n    h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)\n    hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)\n    H       1      appendValue(ChronoField.HOUR_OF_DAY)\n    HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)\n    k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)\n    kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)\n    K       1      appendValue(ChronoField.HOUR_OF_AMPM)\n    KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)\n    m       1      appendValue(ChronoField.MINUTE_OF_HOUR)\n    mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)\n    s       1      appendValue(ChronoField.SECOND_OF_MINUTE)\n    ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)\n\n    S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)\n    A       1      appendValue(ChronoField.MILLI_OF_DAY)\n    A..A    2..n   appendValue(ChronoField.MILLI_OF_DAY, n)\n    n       1      appendValue(ChronoField.NANO_OF_SECOND)\n    n..n    2..n   appendValue(ChronoField.NANO_OF_SECOND, n)\n    N       1      appendValue(ChronoField.NANO_OF_DAY)\n    N..N    2..n   appendValue(ChronoField.NANO_OF_DAY, n)\n </pre>\n\n\n<p> <p>\n <b>Zone ID</b>: Pattern letters to output {@code ZoneId}.</p>\n\n<pre>  Pattern  Count  Equivalent builder methods\n  -------  -----  --------------------------\n    VV      2      appendZoneId()\n    z       1      appendZoneText(TextStyle.SHORT)\n    zz      2      appendZoneText(TextStyle.SHORT)\n    zzz     3      appendZoneText(TextStyle.SHORT)\n    zzzz    4      appendZoneText(TextStyle.FULL)\n </pre>\n\n\n<p> <p>\n <b>Zone offset</b>: Pattern letters to output {@code ZoneOffset}.</p>\n\n<pre>  Pattern  Count  Equivalent builder methods\n  -------  -----  --------------------------\n    O       1      appendLocalizedOffsetPrefixed(TextStyle.SHORT);\n    OOOO    4      appendLocalizedOffsetPrefixed(TextStyle.FULL);\n    X       1      appendOffset(\"+HHmm\",\"Z\")\n    XX      2      appendOffset(\"+HHMM\",\"Z\")\n    XXX     3      appendOffset(\"+HH:MM\",\"Z\")\n    XXXX    4      appendOffset(\"+HHMMss\",\"Z\")\n    XXXXX   5      appendOffset(\"+HH:MM:ss\",\"Z\")\n    x       1      appendOffset(\"+HHmm\",\"+00\")\n    xx      2      appendOffset(\"+HHMM\",\"+0000\")\n    xxx     3      appendOffset(\"+HH:MM\",\"+00:00\")\n    xxxx    4      appendOffset(\"+HHMMss\",\"+0000\")\n    xxxxx   5      appendOffset(\"+HH:MM:ss\",\"+00:00\")\n    Z       1      appendOffset(\"+HHMM\",\"+0000\")\n    ZZ      2      appendOffset(\"+HHMM\",\"+0000\")\n    ZZZ     3      appendOffset(\"+HHMM\",\"+0000\")\n    ZZZZ    4      appendLocalizedOffset(TextStyle.FULL);\n    ZZZZZ   5      appendOffset(\"+HH:MM:ss\",\"Z\")\n </pre>\n\n\n<p> <p>\n <b>Modifiers</b>: Pattern letters that modify the rest of the pattern:</p>\n\n<pre>  Pattern  Count  Equivalent builder methods\n  -------  -----  --------------------------\n    [       1      optionalStart()\n    ]       1      optionalEnd()\n    p..p    1..n   padNext(n)\n </pre>\n\n\n<p> <p>\n Any sequence of letters not specified above, unrecognized letter or\n reserved character will throw an exception.\n Future versions may add to the set of patterns.\n It is recommended to use single quotes around all characters that you want\n to output directly to ensure that future changes do not break your application.\n <p>\n Note that the pattern string is similar, but not identical, to\n SimpleDateFormat.\n The pattern string is also similar, but not identical, to that defined by the\n Unicode Common Locale Data Repository (CLDR/LDML).\n Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML.\n By contrast, {@code SimpleDateFormat} uses 'u' for the numeric day of week.\n Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently.\n Pattern letters 'n', 'A', 'N', and 'p' are added.\n Number types will reject large numbers.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>pattern</span> : String<div class='sub-desc'><p>the pattern to add, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the pattern is invalid</p>\n</div></li></ul></div></div></div><div id='method-appendText' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendText' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendText' class='name expandable'>appendText</a>( <span class='pre'>field, textLookup</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the text of a date-time field to the formatter using the specified\n map to supply the text. ...</div><div class='long'><p>Appends the text of a date-time field to the formatter using the specified\n map to supply the text.\n <p>\n The standard text outputting methods use the localized text in the JDK.\n This method allows that text to be specified directly.\n The supplied map is not validated by the builder to ensure that formatting or\n parsing is possible, thus an invalid map may throw an error during later use.\n <p>\n Supplying the map of text provides considerable flexibility in formatting and parsing.\n For example, a legacy application might require or supply the months of the\n year as \"JNY\", \"FBY\", \"MCH\" etc. These do not match the standard set of text\n for localized month names. Using this method, a map can be created which\n defines the connection between each value and the text:</p>\n\n<pre> Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();\n map.put(1L, \"JNY\");\n map.put(2L, \"FBY\");\n map.put(3L, \"MCH\");\n ...\n builder.appendText(MONTH_OF_YEAR, map);\n </pre>\n\n\n<p> <p>\n Other uses might be to output the value with a suffix, such as \"1st\", \"2nd\", \"3rd\",\n or as Roman numerals \"I\", \"II\", \"III\", \"IV\".\n <p>\n During formatting, the value is obtained and checked that it is in the valid range.\n If text is not available for the value then it is output as a number.\n During parsing, the parser will match against the map of text and numeric values.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>field</span> : Object {TemporalField}<div class='sub-desc'><p>the field to append, not null</p>\n</div></li><li><span class='pre'>textLookup</span> : Object {java.util.Map}<div class='sub-desc'><p>the map from the value to the text</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-appendValue' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendValue' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendValue' class='name expandable'>appendValue</a>( <span class='pre'>field, minWidth, maxWidth, signStyle</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the value of a date-time field to the formatter providing full\n control over formatting. ...</div><div class='long'><p>Appends the value of a date-time field to the formatter providing full\n control over formatting.\n <p>\n The value of the field will be output during a format.\n If the value cannot be obtained then an exception will be thrown.\n <p>\n This method provides full control of the numeric formatting, including\n zero-padding and the positive/negative sign.\n <p>\n The parser for a variable width value such as this normally behaves greedily,\n accepting as many digits as possible.\n This behavior can be affected by 'adjacent value parsing'.\n See int) for full details.\n <p>\n In strict parsing mode, the minimum number of parsed digits is {@code minWidth}\n and the maximum is {@code maxWidth}.\n In lenient parsing mode, the minimum number of parsed digits is one\n and the maximum is 19 (except as limited by adjacent value parsing).\n <p>\n If this method is invoked with equal minimum and maximum widths and a sign style of\n {@code NOT_NEGATIVE} then it delegates to {@code appendValue(TemporalField,int)}.\n In this scenario, the formatting and parsing behavior described there occur.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>field</span> : Object {TemporalField}<div class='sub-desc'><p>the field to append, not null</p>\n</div></li><li><span class='pre'>minWidth</span> : Number<div class='sub-desc'><p>the minimum field width of the printed field, from 1 to 19</p>\n</div></li><li><span class='pre'>maxWidth</span> : Number<div class='sub-desc'><p>the maximum field width of the printed field, from 1 to 19</p>\n</div></li><li><span class='pre'>signStyle</span> : Object {SignStyle}<div class='sub-desc'><p>the positive/negative output style, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the widths are invalid</p>\n</div></li></ul></div></div></div><div id='method-appendValueReduced' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendValueReduced' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendValueReduced' class='name expandable'>appendValueReduced</a>( <span class='pre'>field, width, maxWidth, baseDate</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the reduced value of a date-time field to the formatter. ...</div><div class='long'><p>Appends the reduced value of a date-time field to the formatter.\n <p>\n This is typically used for formatting and parsing a two digit year.\n <p>\n The base date is used to calculate the full value during parsing.\n For example, if the base date is 1950-01-01 then parsed values for\n a two digit year parse will be in the range 1950-01-01 to 2049-12-31.\n Only the year would be extracted from the date, thus a base date of\n 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.\n This behavior is necessary to support fields such as week-based-year\n or other calendar systems where the parsed value does not align with\n standard ISO years.\n <p>\n The exact behavior is as follows. Parse the full set of fields and\n determine the effective chronology using the last chronology if\n it appears more than once. Then convert the base date to the\n effective chronology. Then extract the specified field from the\n chronology-specific base date and use it to determine the\n {@code baseValue} used below.\n <p>\n For formatting, the {@code width} and {@code maxWidth} are used to\n determine the number of characters to format.\n If they are equal then the format is fixed width.\n If the value of the field is within the range of the {@code baseValue} using\n {@code width} characters then the reduced value is formatted otherwise the value is\n truncated to fit {@code maxWidth}.\n The rightmost characters are output to match the width, left padding with zero.\n <p>\n For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.\n For lenient parsing, the number of characters must be at least 1 and less than 10.\n If the number of digits parsed is equal to {@code width} and the value is positive,\n the value of the field is computed to be the first number greater than\n or equal to the {@code baseValue} with the same least significant characters,\n otherwise the value parsed is the field value.\n This allows a reduced value to be entered for values in range of the baseValue\n and width and absolute values can be entered for values outside the range.\n <p>\n For example, a base value of {@code 1980} and a width of {@code 2} will have\n valid values from {@code 1980} to {@code 2079}.\n During parsing, the text {@code \"12\"} will result in the value {@code 2012} as that\n is the value within the range where the last two characters are \"12\".\n By contrast, parsing the text {@code \"1915\"} will result in the value {@code 1915}.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>field</span> : Object {TemporalField}<div class='sub-desc'><p>the field to append, not null</p>\n</div></li><li><span class='pre'>width</span> : Number<div class='sub-desc'><p>the field width of the printed and parsed field, from 1 to 10</p>\n</div></li><li><span class='pre'>maxWidth</span> : Number<div class='sub-desc'><p>the maximum field width of the printed field, from 1 to 10</p>\n</div></li><li><span class='pre'>baseDate</span> : Object {ChronoLocalDate}<div class='sub-desc'><p>the base date used to calculate the base value for the range\n  of valid values in the parsed chronology, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if the width or base value is invalid</p>\n</div></li></ul></div></div></div><div id='method-appendZoneId' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendZoneId' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneId' class='name expandable'>appendZoneId</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter. ...</div><div class='long'><p>Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.\n <p>\n This appends an instruction to format/parse the zone ID to the builder.\n The zone ID is obtained in a strict manner suitable for {@code ZonedDateTime}.\n By contrast, {@code OffsetDateTime} does not have a zone ID suitable\n for use with this method, see <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneOrOffsetId\" rel=\"java.time.format.DateTimeFormatterBuilder-method-appendZoneOrOffsetId\" class=\"docClass\">appendZoneOrOffsetId</a>().\n <p>\n During formatting, the zone is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.zoneId().\n It will be printed using the result of ZoneId.getId().\n If the zone cannot be obtained then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n During parsing, the text must match a known zone or offset.\n There are two types of zone ID, offset-based, such as '+01:30' and\n region-based, such as 'Europe/London'. These are parsed differently.\n If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n expects an offset-based zone and will not match region-based zones.\n The offset ID, such as '+02:30', may be at the start of the parse,\n or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n equivalent to using String) using the\n arguments 'HH:MM:ss' and the no offset string '0'.\n If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n match a following offset ID, then ZoneOffset.UTC is selected.\n In all other cases, the list of known region-based zones is used to\n find the longest available match. If no match is found, and the parse\n starts with 'Z', then {@code ZoneOffset.UTC} is selected.\n The parser uses the {@linkplain <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a>() case sensitive} setting.\n <p>\n For example, the following will parse:</p>\n\n<pre>   \"Europe/London\"           -- ZoneId.of(\"Europe/London\")\n   \"Z\"                       -- ZoneOffset.UTC\n   \"UT\"                      -- ZoneId.of(\"UT\")\n   \"UTC\"                     -- ZoneId.of(\"UTC\")\n   \"GMT\"                     -- ZoneId.of(\"GMT\")\n   \"+01:30\"                  -- ZoneOffset.of(\"+01:30\")\n   \"UT+01:30\"                -- ZoneOffset.of(\"+01:30\")\n   \"UTC+01:30\"               -- ZoneOffset.of(\"+01:30\")\n   \"GMT+01:30\"               -- ZoneOffset.of(\"+01:30\")\n </pre>\n\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null\n@see <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneRegionId\" rel=\"java.time.format.DateTimeFormatterBuilder-method-appendZoneRegionId\" class=\"docClass\">appendZoneRegionId</a>()</p>\n</div></li></ul></div></div></div><div id='method-appendZoneOrOffsetId' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendZoneOrOffsetId' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneOrOffsetId' class='name expandable'>appendZoneOrOffsetId</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to\n the formatter, using the best available zone ID. ...</div><div class='long'><p>Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to\n the formatter, using the best available zone ID.\n <p>\n This appends an instruction to format/parse the best available\n zone or offset ID to the builder.\n The zone ID is obtained in a lenient manner that first attempts to\n find a true zone ID, such as that on {@code ZonedDateTime}, and\n then attempts to find an offset, such as that on {@code OffsetDateTime}.\n <p>\n During formatting, the zone is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.zone().\n It will be printed using the result of ZoneId.getId().\n If the zone cannot be obtained then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n During parsing, the text must match a known zone or offset.\n There are two types of zone ID, offset-based, such as '+01:30' and\n region-based, such as 'Europe/London'. These are parsed differently.\n If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n expects an offset-based zone and will not match region-based zones.\n The offset ID, such as '+02:30', may be at the start of the parse,\n or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n equivalent to using String) using the\n arguments 'HH:MM:ss' and the no offset string '0'.\n If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n match a following offset ID, then ZoneOffset.UTC is selected.\n In all other cases, the list of known region-based zones is used to\n find the longest available match. If no match is found, and the parse\n starts with 'Z', then {@code ZoneOffset.UTC} is selected.\n The parser uses the {@linkplain <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a>() case sensitive} setting.\n <p>\n For example, the following will parse:</p>\n\n<pre>   \"Europe/London\"           -- ZoneId.of(\"Europe/London\")\n   \"Z\"                       -- ZoneOffset.UTC\n   \"UT\"                      -- ZoneId.of(\"UT\")\n   \"UTC\"                     -- ZoneId.of(\"UTC\")\n   \"GMT\"                     -- ZoneId.of(\"GMT\")\n   \"+01:30\"                  -- ZoneOffset.of(\"+01:30\")\n   \"UT+01:30\"                -- ZoneOffset.of(\"UT+01:30\")\n   \"UTC+01:30\"               -- ZoneOffset.of(\"UTC+01:30\")\n   \"GMT+01:30\"               -- ZoneOffset.of(\"GMT+01:30\")\n </pre>\n\n\n<p> <p>\n Note that this method is identical to {@code appendZoneId()} except\n in the mechanism used to obtain the zone.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null\n@see <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneId\" rel=\"java.time.format.DateTimeFormatterBuilder-method-appendZoneId\" class=\"docClass\">appendZoneId</a>()</p>\n</div></li></ul></div></div></div><div id='method-appendZoneRegionId' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendZoneRegionId' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneRegionId' class='name expandable'>appendZoneRegionId</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the time-zone region ID, such as 'Europe/Paris', to the formatter,\n rejecting the zone ID if it is a {@code Z...</div><div class='long'><p>Appends the time-zone region ID, such as 'Europe/Paris', to the formatter,\n rejecting the zone ID if it is a {@code ZoneOffset}.\n <p>\n This appends an instruction to format/parse the zone ID to the builder\n only if it is a region-based ID.\n <p>\n During formatting, the zone is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.zoneId().\n If the zone is a {@code ZoneOffset} or it cannot be obtained then\n an exception is thrown unless the section of the formatter is optional.\n If the zone is not an offset, then the zone will be printed using\n the zone ID from ZoneId.getId().\n <p>\n During parsing, the text must match a known zone or offset.\n There are two types of zone ID, offset-based, such as '+01:30' and\n region-based, such as 'Europe/London'. These are parsed differently.\n If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n expects an offset-based zone and will not match region-based zones.\n The offset ID, such as '+02:30', may be at the start of the parse,\n or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n equivalent to using String) using the\n arguments 'HH:MM:ss' and the no offset string '0'.\n If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n match a following offset ID, then ZoneOffset.UTC is selected.\n In all other cases, the list of known region-based zones is used to\n find the longest available match. If no match is found, and the parse\n starts with 'Z', then {@code ZoneOffset.UTC} is selected.\n The parser uses the {@linkplain <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a>() case sensitive} setting.\n <p>\n For example, the following will parse:</p>\n\n<pre>   \"Europe/London\"           -- ZoneId.of(\"Europe/London\")\n   \"Z\"                       -- ZoneOffset.UTC\n   \"UT\"                      -- ZoneId.of(\"UT\")\n   \"UTC\"                     -- ZoneId.of(\"UTC\")\n   \"GMT\"                     -- ZoneId.of(\"GMT\")\n   \"+01:30\"                  -- ZoneOffset.of(\"+01:30\")\n   \"UT+01:30\"                -- ZoneOffset.of(\"+01:30\")\n   \"UTC+01:30\"               -- ZoneOffset.of(\"+01:30\")\n   \"GMT+01:30\"               -- ZoneOffset.of(\"+01:30\")\n </pre>\n\n\n<p> <p>\n Note that this method is identical to {@code appendZoneId()} except\n in the mechanism used to obtain the zone.\n Note also that parsing accepts offsets, whereas formatting will never\n produce one.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null\n@see <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneId\" rel=\"java.time.format.DateTimeFormatterBuilder-method-appendZoneId\" class=\"docClass\">appendZoneId</a>()</p>\n</div></li></ul></div></div></div><div id='method-appendZoneText' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-appendZoneText' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-appendZoneText' class='name expandable'>appendZoneText</a>( <span class='pre'>textStyle, preferredZones</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends the time-zone name, such as 'British Summer Time', to the formatter. ...</div><div class='long'><p>Appends the time-zone name, such as 'British Summer Time', to the formatter.\n <p>\n This appends an instruction to format/parse the textual name of the zone to\n the builder.\n <p>\n During formatting, the zone is obtained using a mechanism equivalent\n to querying the temporal with TemporalQueries.zoneId().\n If the zone is a {@code ZoneOffset} it will be printed using the\n result of ZoneOffset.getId().\n If the zone is not an offset, the textual name will be looked up\n for the locale set in the <a href=\"#!/api/java.time.format.DateTimeFormatter\" rel=\"java.time.format.DateTimeFormatter\" class=\"docClass\">java.time.format.DateTimeFormatter</a>.\n If the temporal object being printed represents an instant, then the text\n will be the summer or winter time text as appropriate.\n If the lookup for text does not find any suitable result, then the\n ID will be printed instead.\n If the zone cannot be obtained then an exception is thrown unless the\n section of the formatter is optional.\n <p>\n During parsing, either the textual zone name, the zone ID or the offset\n is accepted. Many textual zone names are not unique, such as CST can be\n for both \"Central Standard Time\" and \"China Standard Time\". In this\n situation, the zone id will be determined by the region information from\n formatter's  locale and the standard\n zone id for that area, for example, America/New_York for the America Eastern\n zone. This method also allows a set of preferred ZoneId to be\n specified for parsing. The matched preferred zone id will be used if the\n textural zone name being parsed is not unique.\n <p>\n If the zone cannot be parsed then an exception is thrown unless the\n section of the formatter is optional.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>textStyle</span> : Object {TextStyle}<div class='sub-desc'><p>the text style to use, not null</p>\n</div></li><li><span class='pre'>preferredZones</span> : Object {java.util.Set}<div class='sub-desc'><p>the set of preferred zone ids, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-getLocalizedDateTimePattern' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-getLocalizedDateTimePattern' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-getLocalizedDateTimePattern' class='name expandable'>getLocalizedDateTimePattern</a>( <span class='pre'>dateStyle, timeStyle, chrono, locale</span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Gets the formatting pattern for date and time styles for a locale and chronology. ...</div><div class='long'><p>Gets the formatting pattern for date and time styles for a locale and chronology.\n The locale and chronology are used to lookup the locale specific format\n for the requested dateStyle and/or timeStyle.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>dateStyle</span> : Object {FormatStyle}<div class='sub-desc'><p>the FormatStyle for the date, null for time-only pattern</p>\n</div></li><li><span class='pre'>timeStyle</span> : Object {FormatStyle}<div class='sub-desc'><p>the FormatStyle for the time, null for date-only pattern</p>\n</div></li><li><span class='pre'>chrono</span> : Object {Chronology}<div class='sub-desc'><p>the Chronology, non-null</p>\n</div></li><li><span class='pre'>locale</span> : Object {Locale}<div class='sub-desc'><p>the locale, non-null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>the locale and Chronology specific formatting pattern</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if both dateStyle and timeStyle are null</p>\n</div></li></ul></div></div></div><div id='method-optionalEnd' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-optionalEnd' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalEnd' class='name expandable'>optionalEnd</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Ends an optional section. ...</div><div class='long'><p>Ends an optional section.\n <p>\n The output of formatting can include optional sections, which may be nested.\n An optional section is started by calling <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalStart\" rel=\"java.time.format.DateTimeFormatterBuilder-method-optionalStart\" class=\"docClass\">optionalStart</a>() and ended\n using this method (or at the end of the builder).\n <p>\n Calling this method without having previously called {@code optionalStart}\n will throw an exception.\n Calling this method immediately after calling {@code optionalStart} has no effect\n on the formatter other than ending the (empty) optional section.\n <p>\n All elements in the optional section are treated as optional.\n During formatting, the section is only output if data is available in the\n {@code TemporalAccessor} for all the elements in the section.\n During parsing, the whole section may be missing from the parsed string.\n <p>\n For example, consider a builder setup as\n {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()}.\n During formatting, the minute will only be output if its value can be obtained from the date-time.\n During parsing, the input will be successfully parsed whether the minute is present or not.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalStateException if there was no previous call to {@code optionalStart}</p>\n</div></li></ul></div></div></div><div id='method-optionalStart' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-optionalStart' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalStart' class='name expandable'>optionalStart</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Mark the start of an optional section. ...</div><div class='long'><p>Mark the start of an optional section.\n <p>\n The output of formatting can include optional sections, which may be nested.\n An optional section is started by calling this method and ended by calling\n <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalEnd\" rel=\"java.time.format.DateTimeFormatterBuilder-method-optionalEnd\" class=\"docClass\">optionalEnd</a>() or by ending the build process.\n <p>\n All elements in the optional section are treated as optional.\n During formatting, the section is only output if data is available in the\n {@code TemporalAccessor} for all the elements in the section.\n During parsing, the whole section may be missing from the parsed string.\n <p>\n For example, consider a builder setup as\n {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)}.\n The optional section ends automatically at the end of the builder.\n During formatting, the minute will only be output if its value can be obtained from the date-time.\n During parsing, the input will be successfully parsed whether the minute is present or not.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-padNext' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-padNext' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-padNext' class='name expandable'>padNext</a>( <span class='pre'>padWidth, padChar</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Causes the next added printer/parser to pad to a fixed width. ...</div><div class='long'><p>Causes the next added printer/parser to pad to a fixed width.\n <p>\n This padding is intended for padding other than zero-padding.\n Zero-padding should be achieved using the appendValue methods.\n <p>\n During formatting, the decorated element will be output and then padded\n to the specified width. An exception will be thrown during formatting if\n the pad width is exceeded.\n <p>\n During parsing, the padding and decorated element are parsed.\n If parsing is lenient, then the pad width is treated as a maximum.\n If parsing is case insensitive, then the pad character is matched ignoring case.\n The padding is parsed greedily. Thus, if the decorated element starts with\n the pad character, it will not be parsed.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>padWidth</span> : Number<div class='sub-desc'><p>the pad width, 1 or greater</p>\n</div></li><li><span class='pre'>padChar</span> : String<div class='sub-desc'><p>the pad character</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if pad width is too small</p>\n</div></li></ul></div></div></div><div id='method-parseCaseInsensitive' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-parseCaseInsensitive' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive' class='name expandable'>parseCaseInsensitive</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Changes the parse style to be case insensitive for the remainder of the formatter. ...</div><div class='long'><p>Changes the parse style to be case insensitive for the remainder of the formatter.\n <p>\n Parsing can be case sensitive or insensitive - by default it is case sensitive.\n This method allows the case sensitivity setting of parsing to be changed.\n <p>\n Calling this method changes the state of the builder such that all\n subsequent builder method calls will parse text in case insensitive mode.\n See <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseSensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseSensitive\" class=\"docClass\">parseCaseSensitive</a>() for the opposite setting.\n The parse case sensitive/insensitive methods may be called at any point\n in the builder, thus the parser can swap between case parsing modes\n multiple times during the parse.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-parseCaseSensitive' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-parseCaseSensitive' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseSensitive' class='name expandable'>parseCaseSensitive</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Changes the parse style to be case sensitive for the remainder of the formatter. ...</div><div class='long'><p>Changes the parse style to be case sensitive for the remainder of the formatter.\n <p>\n Parsing can be case sensitive or insensitive - by default it is case sensitive.\n This method allows the case sensitivity setting of parsing to be changed.\n <p>\n Calling this method changes the state of the builder such that all\n subsequent builder method calls will parse text in case sensitive mode.\n See <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a> for the opposite setting.\n The parse case sensitive/insensitive methods may be called at any point\n in the builder, thus the parser can swap between case parsing modes\n multiple times during the parse.\n <p>\n Since the default is case sensitive, this method should only be used after\n a previous call to {@code <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a>}.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-parseDefaulting' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-parseDefaulting' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-parseDefaulting' class='name expandable'>parseDefaulting</a>( <span class='pre'>field, value</span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Appends a default value for a field to the formatter for use in parsing. ...</div><div class='long'><p>Appends a default value for a field to the formatter for use in parsing.\n <p>\n This appends an instruction to the builder to inject a default value\n into the parsed result. This is especially useful in conjunction with\n optional parts of the formatter.\n <p>\n For example, consider a formatter that parses the year, followed by\n an optional month, with a further optional day-of-month. Using such a\n formatter would require the calling code to check whether a full date,\n year-month or just a year had been parsed. This method can be used to\n default the month and day-of-month to a sensible value, such as the\n first of the month, allowing the calling code to always get a date.\n <p>\n During formatting, this method has no effect.\n <p>\n During parsing, the current state of the parse is inspected.\n If the specified field has no associated value, because it has not been\n parsed successfully at that point, then the specified value is injected\n into the parse result. Injection is immediate, thus the field-value pair\n will be visible to any subsequent elements in the formatter.\n As such, this method is normally called at the end of the builder.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>field</span> : Object {TemporalField}<div class='sub-desc'><p>the field to default the value of, not null</p>\n</div></li><li><span class='pre'>value</span> : Number<div class='sub-desc'><p>the value to default the field to</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-parseLenient' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-parseLenient' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-parseLenient' class='name expandable'>parseLenient</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Changes the parse style to be lenient for the remainder of the formatter. ...</div><div class='long'><p>Changes the parse style to be lenient for the remainder of the formatter.\n Note that case sensitivity is set separately to this method.\n <p>\n Parsing can be strict or lenient - by default its strict.\n This controls the degree of flexibility in matching the text and sign styles.\n Applications calling this method should typically also call <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseCaseInsensitive\" class=\"docClass\">parseCaseInsensitive</a>().\n <p>\n When used, this method changes the parsing to be lenient from this point onwards.\n The change will remain in force until the end of the formatter that is eventually\n constructed or until {@code parseStrict} is called.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-parseStrict' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-parseStrict' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-parseStrict' class='name expandable'>parseStrict</a>( <span class='pre'></span> ) : Object {java.time.format.DateTimeFormatterBuilder}<span class=\"signature\"></span></div><div class='description'><div class='short'>Changes the parse style to be strict for the remainder of the formatter. ...</div><div class='long'><p>Changes the parse style to be strict for the remainder of the formatter.\n <p>\n Parsing can be strict or lenient - by default its strict.\n This controls the degree of flexibility in matching the text and sign styles.\n <p>\n When used, this method changes the parsing to be strict from this point onwards.\n As strict is the default, this is normally only needed after calling <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-parseLenient\" rel=\"java.time.format.DateTimeFormatterBuilder-method-parseLenient\" class=\"docClass\">parseLenient</a>().\n The change will remain in force until the end of the formatter that is eventually\n constructed or until {@code parseLenient} is called.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatterBuilder}</span><div class='sub-desc'><p>this, for chaining, not null</p>\n</div></li></ul></div></div></div><div id='method-toFormatter' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.time.format.DateTimeFormatterBuilder'>java.time.format.DateTimeFormatterBuilder</span><br/><a href='source/DateTimeFormatterBuilder.html#java-time-format-DateTimeFormatterBuilder-method-toFormatter' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.time.format.DateTimeFormatterBuilder-method-toFormatter' class='name expandable'>toFormatter</a>( <span class='pre'>locale</span> ) : Object {java.time.format.DateTimeFormatter}<span class=\"signature\"></span></div><div class='description'><div class='short'>Completes this builder by creating the {@code DateTimeFormatter}\n using the specified locale. ...</div><div class='long'><p>Completes this builder by creating the {@code DateTimeFormatter}\n using the specified locale.\n <p>\n This will create a formatter with the specified locale.\n Numbers will be printed and parsed using the standard DecimalStyle.\n The resolver style will be <a href=\"#!/api/java.time.format.ResolverStyle-property-SMART\" rel=\"java.time.format.ResolverStyle-property-SMART\" class=\"docClass\">SMART</a>.\n <p>\n Calling this method will end any open optional sections by repeatedly\n calling <a href=\"#!/api/java.time.format.DateTimeFormatterBuilder-method-optionalEnd\" rel=\"java.time.format.DateTimeFormatterBuilder-method-optionalEnd\" class=\"docClass\">optionalEnd</a>() before creating the formatter.\n <p>\n This builder can still be used after creating the formatter if desired,\n although the state may have been changed by calls to {@code optionalEnd}.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>locale</span> : Object {Locale}<div class='sub-desc'><p>the locale to use for formatting, not null</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object {java.time.format.DateTimeFormatter}</span><div class='sub-desc'><p>the created formatter, not null</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});