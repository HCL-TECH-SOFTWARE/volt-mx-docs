Ext.data.JsonP.java_util_concurrent_Semaphore({"tagname":"class","name":"java.util.concurrent.Semaphore","autodetected":{},"files":[{"filename":"Semaphore.js","href":"Semaphore.html#java-util-concurrent-Semaphore"}],"extends":"java.lang.Object","since":"1.5","author":[{"tagname":"author","name":"Doug Lea","email":null}],"members":[{"name":"acquire","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-acquire","meta":{}},{"name":"acquireUninterruptibly","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-acquireUninterruptibly","meta":{}},{"name":"availablePermits","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-availablePermits","meta":{}},{"name":"drainPermits","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-drainPermits","meta":{}},{"name":"getQueueLength","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-getQueueLength","meta":{}},{"name":"hasQueuedThreads","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-hasQueuedThreads","meta":{}},{"name":"isFair","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-isFair","meta":{}},{"name":"release","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-release","meta":{}},{"name":"toString","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-toString","meta":{}},{"name":"tryAcquire","tagname":"method","owner":"java.util.concurrent.Semaphore","id":"method-tryAcquire","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.util.concurrent.Semaphore","short_doc":"implements java.io.Serializable\n\nA counting semaphore. ...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>java.util.concurrent.Semaphore</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/Semaphore.html#java-util-concurrent-Semaphore' target='_blank'>Semaphore.js</a></div></pre><div class='doc-contents'><p>implements java.io.Serializable</p>\n\n<p>A counting semaphore.  Conceptually, a semaphore maintains a set of\n permits.  Each <a href=\"#!/api/java.util.concurrent.Semaphore-method-acquire\" rel=\"java.util.concurrent.Semaphore-method-acquire\" class=\"docClass\">acquire</a> blocks if necessary until a permit is\n available, and then takes it.  Each <a href=\"#!/api/java.util.concurrent.Semaphore-method-release\" rel=\"java.util.concurrent.Semaphore-method-release\" class=\"docClass\">release</a> adds a permit,\n potentially releasing a blocking acquirer.\n However, no actual permit objects are used; the {@code Semaphore} just\n keeps a count of the number available and acts accordingly.</p>\n\n<p> <p>Semaphores are often used to restrict the number of threads than can\n access some (physical or logical) resource. For example, here is\n a class that uses a semaphore to control access to a pool of items:\n <pre> {@code\n class Pool {\n   private static final int MAX_AVAILABLE = 100;\n   private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);</pre></p>\n\n<p>   public Object getItem() throws InterruptedException {\n     available.acquire();\n     return getNextAvailableItem();\n   }</p>\n\n<p>   public void putItem(Object x) {\n     if (markAsUnused(x))\n       available.release();\n   }</p>\n\n<p>   // Not a particularly efficient data structure; just for demo</p>\n\n<p>   protected Object[] items = ... whatever kinds of items being managed\n   protected boolean[] used = new boolean[MAX_AVAILABLE];</p>\n\n<p>   protected synchronized Object getNextAvailableItem() {\n     for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {\n       if (!used[i]) {\n          used[i] = true;\n          return items[i];\n       }\n     }\n     return null; // not reached\n   }</p>\n\n<p>   protected synchronized boolean markAsUnused(Object item) {\n     for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {\n       if (item == items[i]) {\n          if (used[i]) {\n            used[i] = false;\n            return true;\n          } else\n            return false;\n       }\n     }\n     return false;\n   }\n }}</p>\n\n<p> <p>Before obtaining an item each thread must acquire a permit from\n the semaphore, guaranteeing that an item is available for use. When\n the thread has finished with the item it is returned back to the\n pool and a permit is returned to the semaphore, allowing another\n thread to acquire that item.  Note that no synchronization lock is\n held when <a href=\"#!/api/java.util.concurrent.Semaphore-method-acquire\" rel=\"java.util.concurrent.Semaphore-method-acquire\" class=\"docClass\">acquire</a> is called as that would prevent an item\n from being returned to the pool.  The semaphore encapsulates the\n synchronization needed to restrict access to the pool, separately\n from any synchronization needed to maintain the consistency of the\n pool itself.</p>\n\n<p> <p>A semaphore initialized to one, and which is used such that it\n only has at most one permit available, can serve as a mutual\n exclusion lock.  This is more commonly known as a <em>binary\n semaphore</em>, because it only has two states: one permit\n available, or zero permits available.  When used in this way, the\n binary semaphore has the property (unlike many java.util.concurrent.locks.Lock\n implementations), that the &quot;lock&quot; can be released by a\n thread other than the owner (as semaphores have no notion of\n ownership).  This can be useful in some specialized contexts, such\n as deadlock recovery.</p>\n\n<p> <p>The constructor for this class optionally accepts a\n <em>fairness</em> parameter. When set false, this class makes no\n guarantees about the order in which threads acquire permits. In\n particular, <em>barging</em> is permitted, that is, a thread\n invoking <a href=\"#!/api/java.util.concurrent.Semaphore-method-acquire\" rel=\"java.util.concurrent.Semaphore-method-acquire\" class=\"docClass\">acquire</a> can be allocated a permit ahead of a\n thread that has been waiting - logically the new thread places itself at\n the head of the queue of waiting threads. When fairness is set true, the\n semaphore guarantees that threads invoking any of the acquire methods are selected to obtain permits in the order in\n which their invocation of those methods was processed\n (first-in-first-out; FIFO). Note that FIFO ordering necessarily\n applies to specific internal points of execution within these\n methods.  So, it is possible for one thread to invoke\n {@code acquire} before another, but reach the ordering point after\n the other, and similarly upon return from the method.\n Also note that the untimed tryAcquire methods do not\n honor the fairness setting, but will take any permits that are\n available.</p>\n\n<p> <p>Generally, semaphores used to control resource access should be\n initialized as fair, to ensure that no thread is starved out from\n accessing a resource. When using semaphores for other kinds of\n synchronization control, the throughput advantages of non-fair\n ordering often outweigh fairness considerations.</p>\n\n<p> <p>This class also provides convenience methods to acquire and release multiple\n permits at a time. These methods are generally more efficient and\n effective than loops. However, they do not establish any preference\n order. For example, if thread A invokes {@code s.acquire(3}) and\n thread B invokes {@code s.acquire(2)}, and two permits become\n available, then there is no guarantee that thread B will obtain\n them unless its acquire came first and Semaphore {@code s} is in\n fair mode.</p>\n\n<p> <p>Memory consistency effects: Actions in a thread prior to calling\n a \"release\" method such as {@code release()}\n <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n actions following a successful \"acquire\" method such as {@code acquire()}\n in another thread.</p>\n        <p>Available since: <b>1.5</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-acquire' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-acquire' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-acquire' class='name expandable'>acquire</a>( <span class='pre'>permits</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Acquires the given number of permits from this semaphore,\n blocking until all are available,\n or the thread is {@link...</div><div class='long'><p>Acquires the given number of permits from this semaphore,\n blocking until all are available,\n or the thread is {@linkplain Thread#interrupt interrupted}.</p>\n\n<p> <p>Acquires the given number of permits, if they are available,\n and returns immediately, reducing the number of available permits\n by the given amount. This method has the same effect as the\n loop {@code for (int i = 0; i &lt; permits; ++i) acquire();} except\n that it atomically acquires the permits all at once:</p>\n\n<p> <p>If insufficient permits are available then the current thread becomes\n disabled for thread scheduling purposes and lies dormant until\n one of two things happens:\n <ul>\n <li>Some other thread invokes one of the release\n methods for this semaphore and the current thread is next to be assigned\n permits and the number of available permits satisfies this request; or\n <li>Some other thread {@linkplain Thread#interrupt interrupts}\n the current thread.\n </li></li></ul></p>\n\n<p> <p>If the current thread:\n <ul>\n <li>has its interrupted status set on entry to this method; or\n <li>is {@linkplain Thread#interrupt interrupted} while waiting\n for a permit,\n </li></li></ul>\n then InterruptedException is thrown and the current thread's\n interrupted status is cleared.\n Any permits that were to be assigned to this thread are instead\n assigned to other threads trying to acquire permits, as if\n permits had been made available by a call to <a href=\"#!/api/java.util.concurrent.Semaphore-method-release\" rel=\"java.util.concurrent.Semaphore-method-release\" class=\"docClass\">release</a>().</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>permits</span> : Number<div class='sub-desc'><p>the number of permits to acquire</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>InterruptedException if the current thread is interrupted</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code permits} is negative</p>\n</div></li></ul></div></div></div><div id='method-acquireUninterruptibly' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-acquireUninterruptibly' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-acquireUninterruptibly' class='name expandable'>acquireUninterruptibly</a>( <span class='pre'>permits</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Acquires the given number of permits from this semaphore,\n blocking until all are available. ...</div><div class='long'><p>Acquires the given number of permits from this semaphore,\n blocking until all are available.</p>\n\n<p> <p>Acquires the given number of permits, if they are available,\n and returns immediately, reducing the number of available permits\n by the given amount. This method has the same effect as the\n loop {@code for (int i = 0; i &lt; permits; ++i) acquireUninterruptibly();}\n except that it atomically acquires the permits all at once:</p>\n\n<p> <p>If insufficient permits are available then the current thread becomes\n disabled for thread scheduling purposes and lies dormant until\n some other thread invokes one of the release\n methods for this semaphore and the current thread is next to be assigned\n permits and the number of available permits satisfies this request.</p>\n\n<p> <p>If the current thread is {@linkplain Thread#interrupt interrupted}\n while waiting for permits then it will continue to wait and its\n position in the queue is not affected.  When the thread does return\n from this method its interrupt status will be set.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>permits</span> : Number<div class='sub-desc'><p>the number of permits to acquire</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code permits} is negative</p>\n</div></li></ul></div></div></div><div id='method-availablePermits' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-availablePermits' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-availablePermits' class='name expandable'>availablePermits</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the current number of permits available in this semaphore. ...</div><div class='long'><p>Returns the current number of permits available in this semaphore.</p>\n\n<p> <p>This method is typically used for debugging and testing purposes.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the number of permits available in this semaphore</p>\n</div></li></ul></div></div></div><div id='method-drainPermits' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-drainPermits' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-drainPermits' class='name expandable'>drainPermits</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Acquires and returns all permits that are immediately available. ...</div><div class='long'><p>Acquires and returns all permits that are immediately available.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the number of permits acquired</p>\n</div></li></ul></div></div></div><div id='method-getQueueLength' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-getQueueLength' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-getQueueLength' class='name expandable'>getQueueLength</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns an estimate of the number of threads waiting to acquire. ...</div><div class='long'><p>Returns an estimate of the number of threads waiting to acquire.\n The value is only an estimate because the number of threads may\n change dynamically while this method traverses internal data\n structures.  This method is designed for use in monitoring\n system state, not for synchronization control.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the estimated number of threads waiting for this lock</p>\n</div></li></ul></div></div></div><div id='method-hasQueuedThreads' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-hasQueuedThreads' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-hasQueuedThreads' class='name expandable'>hasQueuedThreads</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Queries whether any threads are waiting to acquire. ...</div><div class='long'><p>Queries whether any threads are waiting to acquire. Note that\n because cancellations may occur at any time, a {@code true}\n return does not guarantee that any other thread will ever\n acquire.  This method is designed primarily for use in\n monitoring of the system state.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if there may be other threads waiting to\n         acquire the lock</p>\n</div></li></ul></div></div></div><div id='method-isFair' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-isFair' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-isFair' class='name expandable'>isFair</a>( <span class='pre'></span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns {@code true} if this semaphore has fairness set true. ...</div><div class='long'><p>Returns {@code true} if this semaphore has fairness set true.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if this semaphore has fairness set true</p>\n</div></li></ul></div></div></div><div id='method-release' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-release' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-release' class='name expandable'>release</a>( <span class='pre'>permits</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Releases the given number of permits, returning them to the semaphore. ...</div><div class='long'><p>Releases the given number of permits, returning them to the semaphore.</p>\n\n<p> <p>Releases the given number of permits, increasing the number of\n available permits by that amount.\n If any threads are trying to acquire permits, then one thread\n is selected and given the permits that were just released.\n If the number of available permits satisfies that thread's request\n then that thread is (re)enabled for thread scheduling purposes;\n otherwise the thread will wait until sufficient permits are available.\n If there are still permits available\n after this thread's request has been satisfied, then those permits\n are assigned in turn to other threads trying to acquire permits.</p>\n\n<p> <p>There is no requirement that a thread that releases a permit must\n have acquired that permit by calling <a href=\"#!/api/java.util.concurrent.Semaphore-method-acquire\" rel=\"java.util.concurrent.Semaphore-method-acquire\" class=\"docClass\">acquire</a>.\n Correct usage of a semaphore is established by programming convention\n in the application.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>permits</span> : Number<div class='sub-desc'><p>the number of permits to release</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code permits} is negative</p>\n</div></li></ul></div></div></div><div id='method-toString' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-toString' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-toString' class='name expandable'>toString</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a string identifying this semaphore, as well as its state. ...</div><div class='long'><p>Returns a string identifying this semaphore, as well as its state.\n The state, in brackets, includes the String {@code \"Permits =\"}\n followed by the number of permits.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>a string identifying this semaphore, as well as its state</p>\n</div></li></ul></div></div></div><div id='method-tryAcquire' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Semaphore'>java.util.concurrent.Semaphore</span><br/><a href='source/Semaphore.html#java-util-concurrent-Semaphore-method-tryAcquire' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Semaphore-method-tryAcquire' class='name expandable'>tryAcquire</a>( <span class='pre'>permits, timeout, unit</span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Acquires the given number of permits from this semaphore, if all\n become available within the given waiting time and ...</div><div class='long'><p>Acquires the given number of permits from this semaphore, if all\n become available within the given waiting time and the current\n thread has not been {@linkplain Thread#interrupt interrupted}.</p>\n\n<p> <p>Acquires the given number of permits, if they are available and\n returns immediately, with the value {@code true},\n reducing the number of available permits by the given amount.</p>\n\n<p> <p>If insufficient permits are available then\n the current thread becomes disabled for thread scheduling\n purposes and lies dormant until one of three things happens:\n <ul>\n <li>Some other thread invokes one of the release\n methods for this semaphore and the current thread is next to be assigned\n permits and the number of available permits satisfies this request; or\n <li>Some other thread {@linkplain Thread#interrupt interrupts}\n the current thread; or\n <li>The specified waiting time elapses.\n </li></li></li></ul></p>\n\n<p> <p>If the permits are acquired then the value {@code true} is returned.</p>\n\n<p> <p>If the current thread:\n <ul>\n <li>has its interrupted status set on entry to this method; or\n <li>is {@linkplain Thread#interrupt interrupted} while waiting\n to acquire the permits,\n </li></li></ul>\n then InterruptedException is thrown and the current thread's\n interrupted status is cleared.\n Any permits that were to be assigned to this thread, are instead\n assigned to other threads trying to acquire permits, as if\n the permits had been made available by a call to <a href=\"#!/api/java.util.concurrent.Semaphore-method-release\" rel=\"java.util.concurrent.Semaphore-method-release\" class=\"docClass\">release</a>().</p>\n\n<p> <p>If the specified waiting time elapses then the value {@code false}\n is returned.  If the time is less than or equal to zero, the method\n will not wait at all.  Any permits that were to be assigned to this\n thread, are instead assigned to other threads trying to acquire\n permits, as if the permits had been made available by a call to\n <a href=\"#!/api/java.util.concurrent.Semaphore-method-release\" rel=\"java.util.concurrent.Semaphore-method-release\" class=\"docClass\">release</a>().</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>permits</span> : Number<div class='sub-desc'><p>the number of permits to acquire</p>\n</div></li><li><span class='pre'>timeout</span> : Number<div class='sub-desc'><p>the maximum time to wait for the permits</p>\n</div></li><li><span class='pre'>unit</span> : Object {TimeUnit}<div class='sub-desc'><p>the time unit of the {@code timeout} argument</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if all permits were acquired and {@code false}\n         if the waiting time elapsed before all permits were acquired</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>InterruptedException if the current thread is interrupted</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>IllegalArgumentException if {@code permits} is negative</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});