Ext.data.JsonP.java_util_concurrent_CountDownLatch({"tagname":"class","name":"java.util.concurrent.CountDownLatch","autodetected":{},"files":[{"filename":"CountDownLatch.js","href":"CountDownLatch.html#java-util-concurrent-CountDownLatch"}],"extends":"java.lang.Object","since":"1.5","author":[{"tagname":"author","name":"Doug Lea","email":null}],"members":[{"name":"await","tagname":"method","owner":"java.util.concurrent.CountDownLatch","id":"method-await","meta":{}},{"name":"countDown","tagname":"method","owner":"java.util.concurrent.CountDownLatch","id":"method-countDown","meta":{}},{"name":"getCount","tagname":"method","owner":"java.util.concurrent.CountDownLatch","id":"method-getCount","meta":{}},{"name":"toString","tagname":"method","owner":"java.util.concurrent.CountDownLatch","id":"method-toString","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.util.concurrent.CountDownLatch","short_doc":"A synchronization aid that allows one or more threads to wait until\n a set of operations being performed in other thr...","classIcon":"icon-class","superclasses":["java.lang.Object"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>java.lang.Object<div class='subclass '><strong>java.util.concurrent.CountDownLatch</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/CountDownLatch.html#java-util-concurrent-CountDownLatch' target='_blank'>CountDownLatch.js</a></div></pre><div class='doc-contents'><p>A synchronization aid that allows one or more threads to wait until\n a set of operations being performed in other threads completes.</p>\n\n<p> <p>A {@code CountDownLatch} is initialized with a given <em>count</em>.\n The <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-await\" rel=\"java.util.concurrent.CountDownLatch-method-await\" class=\"docClass\">await</a> methods block until the current count reaches\n zero due to invocations of the <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-countDown\" rel=\"java.util.concurrent.CountDownLatch-method-countDown\" class=\"docClass\">countDown</a> method, after which\n all waiting threads are released and any subsequent invocations of\n <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-await\" rel=\"java.util.concurrent.CountDownLatch-method-await\" class=\"docClass\">await</a> return immediately.  This is a one-shot phenomenon\n -- the count cannot be reset.  If you need a version that resets the\n count, consider using a <a href=\"#!/api/java.util.concurrent.CyclicBarrier\" rel=\"java.util.concurrent.CyclicBarrier\" class=\"docClass\">java.util.concurrent.CyclicBarrier</a>.</p>\n\n<p> <p>A {@code CountDownLatch} is a versatile synchronization tool\n and can be used for a number of purposes.  A\n {@code CountDownLatch} initialized with a count of one serves as a\n simple on/off latch, or gate: all threads invoking <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-await\" rel=\"java.util.concurrent.CountDownLatch-method-await\" class=\"docClass\">await</a>\n wait at the gate until it is opened by a thread invoking <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-countDown\" rel=\"java.util.concurrent.CountDownLatch-method-countDown\" class=\"docClass\">countDown</a>.  A {@code CountDownLatch} initialized to <em>N</em>\n can be used to make one thread wait until <em>N</em> threads have\n completed some action, or some action has been completed N times.</p>\n\n<p> <p>A useful property of a {@code CountDownLatch} is that it\n doesn't require that threads calling {@code countDown} wait for\n the count to reach zero before proceeding, it simply prevents any\n thread from proceeding past an <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-await\" rel=\"java.util.concurrent.CountDownLatch-method-await\" class=\"docClass\">await</a> until all\n threads could pass.</p>\n\n<p> <p><b>Sample usage:</b> Here is a pair of classes in which a group\n of worker threads use two countdown latches:\n <ul>\n <li>The first is a start signal that prevents any worker from proceeding\n until the driver is ready for them to proceed;\n <li>The second is a completion signal that allows the driver to wait\n until all workers have completed.\n </li></li></ul></p>\n\n<p> <pre> {@code\n class Driver { // ...\n   void main() throws InterruptedException {\n     CountDownLatch startSignal = new CountDownLatch(1);\n     CountDownLatch doneSignal = new CountDownLatch(N);</pre></p>\n\n<pre><code> for (int i = 0; i &lt; N; ++i) // create and start threads\n   new Thread(new Worker(startSignal, doneSignal)).start();\n\n doSomethingElse();            // don't let run yet\n startSignal.countDown();      // let all threads proceed\n doSomethingElse();\n doneSignal.await();           // wait for all to finish\n</code></pre>\n\n<p>   }\n }</p>\n\n<p> class Worker implements Runnable {\n   private final CountDownLatch startSignal;\n   private final CountDownLatch doneSignal;\n   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n     this.startSignal = startSignal;\n     this.doneSignal = doneSignal;\n   }\n   public void run() {\n     try {\n       startSignal.await();\n       doWork();\n       doneSignal.countDown();\n     } catch (InterruptedException ex) {} // return;\n   }</p>\n\n<p>   void doWork() { ... }\n }}</p>\n\n<p> <p>Another typical usage would be to divide a problem into N parts,\n describe each part with a Runnable that executes that portion and\n counts down on the latch, and queue all the Runnables to an\n Executor.  When all sub-parts are complete, the coordinating thread\n will be able to pass through await. (When threads must repeatedly\n count down in this way, instead use a <a href=\"#!/api/java.util.concurrent.CyclicBarrier\" rel=\"java.util.concurrent.CyclicBarrier\" class=\"docClass\">java.util.concurrent.CyclicBarrier</a>.)</p>\n\n<p> <pre> {@code\n class Driver2 { // ...\n   void main() throws InterruptedException {\n     CountDownLatch doneSignal = new CountDownLatch(N);\n     Executor e = ...</pre></p>\n\n<pre><code> for (int i = 0; i &lt; N; ++i) // create and start threads\n   e.execute(new WorkerRunnable(doneSignal, i));\n\n doneSignal.await();           // wait for all to finish\n</code></pre>\n\n<p>   }\n }</p>\n\n<p> class WorkerRunnable implements Runnable {\n   private final CountDownLatch doneSignal;\n   private final int i;\n   WorkerRunnable(CountDownLatch doneSignal, int i) {\n     this.doneSignal = doneSignal;\n     this.i = i;\n   }\n   public void run() {\n     try {\n       doWork(i);\n       doneSignal.countDown();\n     } catch (InterruptedException ex) {} // return;\n   }</p>\n\n<p>   void doWork() { ... }\n }}</p>\n\n<p> <p>Memory consistency effects: Until the count reaches\n zero, actions in a thread prior to calling\n {@code countDown()}\n <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n actions following a successful return from a corresponding\n {@code await()} in another thread.</p>\n        <p>Available since: <b>1.5</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-await' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.CountDownLatch'>java.util.concurrent.CountDownLatch</span><br/><a href='source/CountDownLatch.html#java-util-concurrent-CountDownLatch-method-await' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.CountDownLatch-method-await' class='name expandable'>await</a>( <span class='pre'>timeout, unit</span> ) : Boolean<span class=\"signature\"></span></div><div class='description'><div class='short'>Causes the current thread to wait until the latch has counted down to\n zero, unless the thread is {@linkplain Thread#...</div><div class='long'><p>Causes the current thread to wait until the latch has counted down to\n zero, unless the thread is {@linkplain Thread#interrupt interrupted},\n or the specified waiting time elapses.</p>\n\n<p> <p>If the current count is zero then this method returns immediately\n with the value {@code true}.</p>\n\n<p> <p>If the current count is greater than zero then the current\n thread becomes disabled for thread scheduling purposes and lies\n dormant until one of three things happen:\n <ul>\n <li>The count reaches zero due to invocations of the\n <a href=\"#!/api/java.util.concurrent.CountDownLatch-method-countDown\" rel=\"java.util.concurrent.CountDownLatch-method-countDown\" class=\"docClass\">countDown</a> method; or\n <li>Some other thread {@linkplain Thread#interrupt interrupts}\n the current thread; or\n <li>The specified waiting time elapses.\n </li></li></li></ul></p>\n\n<p> <p>If the count reaches zero then the method returns with the\n value {@code true}.</p>\n\n<p> <p>If the current thread:\n <ul>\n <li>has its interrupted status set on entry to this method; or\n <li>is {@linkplain Thread#interrupt interrupted} while waiting,\n </li></li></ul>\n then InterruptedException is thrown and the current thread's\n interrupted status is cleared.</p>\n\n<p> <p>If the specified waiting time elapses then the value {@code false}\n is returned.  If the time is less than or equal to zero, the method\n will not wait at all.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>timeout</span> : Number<div class='sub-desc'><p>the maximum time to wait</p>\n</div></li><li><span class='pre'>unit</span> : Object {TimeUnit}<div class='sub-desc'><p>the time unit of the {@code timeout} argument</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>{@code true} if the count reached zero and {@code false}\n         if the waiting time elapsed before the count reached zero</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>InterruptedException if the current thread is interrupted\n         while waiting</p>\n</div></li></ul></div></div></div><div id='method-countDown' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.CountDownLatch'>java.util.concurrent.CountDownLatch</span><br/><a href='source/CountDownLatch.html#java-util-concurrent-CountDownLatch-method-countDown' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.CountDownLatch-method-countDown' class='name expandable'>countDown</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Decrements the count of the latch, releasing all waiting threads if\n the count reaches zero. ...</div><div class='long'><p>Decrements the count of the latch, releasing all waiting threads if\n the count reaches zero.</p>\n\n<p> <p>If the current count is greater than zero then it is decremented.\n If the new count is zero then all waiting threads are re-enabled for\n thread scheduling purposes.</p>\n\n<p> <p>If the current count equals zero then nothing happens.</p>\n</div></div></div><div id='method-getCount' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.CountDownLatch'>java.util.concurrent.CountDownLatch</span><br/><a href='source/CountDownLatch.html#java-util-concurrent-CountDownLatch-method-getCount' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.CountDownLatch-method-getCount' class='name expandable'>getCount</a>( <span class='pre'></span> ) : Number<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns the current count. ...</div><div class='long'><p>Returns the current count.</p>\n\n<p> <p>This method is typically used for debugging and testing purposes.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Number</span><div class='sub-desc'><p>the current count</p>\n</div></li></ul></div></div></div><div id='method-toString' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.CountDownLatch'>java.util.concurrent.CountDownLatch</span><br/><a href='source/CountDownLatch.html#java-util-concurrent-CountDownLatch-method-toString' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.CountDownLatch-method-toString' class='name expandable'>toString</a>( <span class='pre'></span> ) : String<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a string identifying this latch, as well as its state. ...</div><div class='long'><p>Returns a string identifying this latch, as well as its state.\n The state, in brackets, includes the String {@code \"Count =\"}\n followed by the current count.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>String</span><div class='sub-desc'><p>a string identifying this latch, as well as its state</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});