Ext.data.JsonP.java_util_concurrent_Executor({"tagname":"class","name":"java.util.concurrent.Executor","autodetected":{},"files":[{"filename":"Executor.js","href":"Executor.html#java-util-concurrent-Executor"}],"since":"1.5","author":[{"tagname":"author","name":"Doug Lea","email":null}],"members":[{"name":"execute","tagname":"method","owner":"java.util.concurrent.Executor","id":"method-execute","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-java.util.concurrent.Executor","short_doc":"An object that executes submitted Runnable tasks. ...","classIcon":"icon-class","superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/Executor.html#java-util-concurrent-Executor' target='_blank'>Executor.js</a></div></pre><div class='doc-contents'><p>An object that executes submitted Runnable tasks. This\n interface provides a way of decoupling task submission from the\n mechanics of how each task will be run, including details of thread\n use, scheduling, etc.  An {@code Executor} is normally used\n instead of explicitly creating threads. For example, rather than\n invoking {@code new Thread(new RunnableTask()).start()} for each\n of a set of tasks, you might use:</p>\n\n<p> <pre> {@code\n Executor executor = anExecutor();\n executor.execute(new RunnableTask1());\n executor.execute(new RunnableTask2());\n ...}</pre></p>\n\n<p> However, the {@code Executor} interface does not strictly require\n that execution be asynchronous. In the simplest case, an executor\n can run the submitted task immediately in the caller's thread:</p>\n\n<p> <pre> {@code\n class DirectExecutor implements Executor {\n   public void execute(Runnable r) {\n     r.run();\n   }\n }}</pre></p>\n\n<p> More typically, tasks are executed in some thread other than the\n caller's thread.  The executor below spawns a new thread for each\n task.</p>\n\n<p> <pre> {@code\n class ThreadPerTaskExecutor implements Executor {\n   public void execute(Runnable r) {\n     new Thread(r).start();\n   }\n }}</pre></p>\n\n<p> Many {@code Executor} implementations impose some sort of\n limitation on how and when tasks are scheduled.  The executor below\n serializes the submission of tasks to a second executor,\n illustrating a composite executor.</p>\n\n<p> <pre> {@code\n class SerialExecutor implements Executor {\n   final Queue<Runnable> tasks = new ArrayDeque&lt;>();\n   final Executor executor;\n   Runnable active;</Runnable></pre></p>\n\n<p>   SerialExecutor(Executor executor) {\n     this.executor = executor;\n   }</p>\n\n<p>   public synchronized void execute(final Runnable r) {\n     tasks.add(new Runnable() {\n       public void run() {\n         try {\n           r.run();\n         } finally {\n           scheduleNext();\n         }\n       }\n     });\n     if (active == null) {\n       scheduleNext();\n     }\n   }</p>\n\n<p>   protected synchronized void scheduleNext() {\n     if ((active = tasks.poll()) != null) {\n       executor.execute(active);\n     }\n   }\n }}</p>\n\n<p> The {@code Executor} implementations provided in this package\n implement <a href=\"#!/api/java.util.concurrent.ExecutorService\" rel=\"java.util.concurrent.ExecutorService\" class=\"docClass\">java.util.concurrent.ExecutorService</a>, which is a more extensive\n interface.  The <a href=\"#!/api/java.util.concurrent.ThreadPoolExecutor\" rel=\"java.util.concurrent.ThreadPoolExecutor\" class=\"docClass\">java.util.concurrent.ThreadPoolExecutor</a> class provides an\n extensible thread pool implementation. The <a href=\"#!/api/java.util.concurrent.Executors\" rel=\"java.util.concurrent.Executors\" class=\"docClass\">java.util.concurrent.Executors</a> class\n provides convenient factory methods for these Executors.</p>\n\n<p> <p>Memory consistency effects: Actions in a thread prior to\n submitting a {@code Runnable} object to an {@code Executor}\n <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n its execution begins, perhaps in another thread.</p>\n        <p>Available since: <b>1.5</b></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-execute' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='java.util.concurrent.Executor'>java.util.concurrent.Executor</span><br/><a href='source/Executor.html#java-util-concurrent-Executor-method-execute' target='_blank' class='view-source'>view source</a></div><a href='#!/api/java.util.concurrent.Executor-method-execute' class='name expandable'>execute</a>( <span class='pre'>command</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Executes the given command at some time in the future. ...</div><div class='long'><p>Executes the given command at some time in the future.  The command\n may execute in a new thread, in a pooled thread, or in the calling\n thread, at the discretion of the {@code Executor} implementation.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>command</span> : Object {Runnable}<div class='sub-desc'><p>the runnable task</p>\n</div></li></ul><h3 class='pa'>Throws</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>RejectedExecutionException if this task cannot be\n accepted for execution</p>\n</div></li><li><span class='pre'>Object</span><div class='sub-desc'><p>NullPointerException if command is null</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});