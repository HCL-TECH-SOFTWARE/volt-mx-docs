<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-concurrent-Executors'>/**@class java.util.concurrent.Executors
</span>@extends java.lang.Object

 Factory and utility methods for {@link java.util.concurrent.Executor}, {@link java.util.concurrent.ExecutorService}, {@link java.util.concurrent.ScheduledExecutorService}, {@link java.util.concurrent.ThreadFactory}, and {@link java.util.concurrent.Callable} classes defined in this
 package. This class supports the following kinds of methods:

 &lt;ul&gt;
   &lt;li&gt;Methods that create and return an {@link java.util.concurrent.ExecutorService}
       set up with commonly useful configuration settings.
   &lt;li&gt;Methods that create and return a {@link java.util.concurrent.ScheduledExecutorService}
       set up with commonly useful configuration settings.
   &lt;li&gt;Methods that create and return a &quot;wrapped&quot; ExecutorService, that
       disables reconfiguration by making implementation-specific methods
       inaccessible.
   &lt;li&gt;Methods that create and return a {@link java.util.concurrent.ThreadFactory}
       that sets newly created threads to a known state.
   &lt;li&gt;Methods that create and return a {@link java.util.concurrent.Callable}
       out of other closure-like forms, so they can be used
       in execution methods requiring {@code Callable}.
 &lt;/ul&gt;

 @since 1.5
 @author Doug Lea
*/
var Executors = {

<span id='java-util-concurrent-Executors-method-newFixedThreadPool'>/**Creates a thread pool that reuses a fixed number of threads
</span> operating off a shared unbounded queue.  At any point, at most
 {@code nThreads} threads will be active processing tasks.
 If additional tasks are submitted when all threads are active,
 they will wait in the queue until a thread is available.
 If any thread terminates due to a failure during execution
 prior to shutdown, a new one will take its place if needed to
 execute subsequent tasks.  The threads in the pool will exist
 until it is explicitly {@link java.util.concurrent.ExecutorService#shutdown shutdown}.
@param {Number} nThreads the number of threads in the pool
@return {Object {java.util.concurrent.ExecutorService}} the newly created thread pool
@throws IllegalArgumentException if {@code nThreads &lt;= 0}
*/
newFixedThreadPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newWorkStealingPool'>/**Creates a thread pool that maintains enough threads to support
</span> the given parallelism level, and may use multiple queues to
 reduce contention. The parallelism level corresponds to the
 maximum number of threads actively engaged in, or available to
 engage in, task processing. The actual number of threads may
 grow and shrink dynamically. A work-stealing pool makes no
 guarantees about the order in which submitted tasks are
 executed.
@param {Number} parallelism the targeted parallelism level
@return {Object {java.util.concurrent.ExecutorService}} the newly created thread pool
@throws IllegalArgumentException if {@code parallelism &lt;= 0}
@since 1.8
*/
newWorkStealingPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newWorkStealingPool'>/**Creates a work-stealing thread pool using the number of
</span> {@linkplain Runtime#availableProcessors available processors}
 as its target parallelism level.
@return {Object {java.util.concurrent.ExecutorService}} the newly created thread pool
@see #newWorkStealingPool(int)
@since 1.8
*/
newWorkStealingPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newFixedThreadPool'>/**Creates a thread pool that reuses a fixed number of threads
</span> operating off a shared unbounded queue, using the provided
 ThreadFactory to create new threads when needed.  At any point,
 at most {@code nThreads} threads will be active processing
 tasks.  If additional tasks are submitted when all threads are
 active, they will wait in the queue until a thread is
 available.  If any thread terminates due to a failure during
 execution prior to shutdown, a new one will take its place if
 needed to execute subsequent tasks.  The threads in the pool will
 exist until it is explicitly {@link java.util.concurrent.ExecutorService#shutdown
 shutdown}.
@param {Number} nThreads the number of threads in the pool
@param {Object {ThreadFactory}} threadFactory the factory to use when creating new threads
@return {Object {java.util.concurrent.ExecutorService}} the newly created thread pool
@throws NullPointerException if threadFactory is null
@throws IllegalArgumentException if {@code nThreads &lt;= 0}
*/
newFixedThreadPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newSingleThreadExecutor'>/**Creates an Executor that uses a single worker thread operating
</span> off an unbounded queue. (Note however that if this single
 thread terminates due to a failure during execution prior to
 shutdown, a new one will take its place if needed to execute
 subsequent tasks.)  Tasks are guaranteed to execute
 sequentially, and no more than one task will be active at any
 given time. Unlike the otherwise equivalent
 {@code newFixedThreadPool(1)} the returned executor is
 guaranteed not to be reconfigurable to use additional threads.
@return {Object {java.util.concurrent.ExecutorService}} the newly created single-threaded Executor
*/
newSingleThreadExecutor : function(  ) {},

<span id='java-util-concurrent-Executors-method-newSingleThreadExecutor'>/**Creates an Executor that uses a single worker thread operating
</span> off an unbounded queue, and uses the provided ThreadFactory to
 create a new thread when needed. Unlike the otherwise
 equivalent {@code newFixedThreadPool(1, threadFactory)} the
 returned executor is guaranteed not to be reconfigurable to use
 additional threads.
@param {Object {ThreadFactory}} threadFactory the factory to use when creating new
 threads
@return {Object {java.util.concurrent.ExecutorService}} the newly created single-threaded Executor
@throws NullPointerException if threadFactory is null
*/
newSingleThreadExecutor : function(  ) {},

<span id='java-util-concurrent-Executors-method-newCachedThreadPool'>/**Creates a thread pool that creates new threads as needed, but
</span> will reuse previously constructed threads when they are
 available.  These pools will typically improve the performance
 of programs that execute many short-lived asynchronous tasks.
 Calls to {@code execute} will reuse previously constructed
 threads if available. If no existing thread is available, a new
 thread will be created and added to the pool. Threads that have
 not been used for sixty seconds are terminated and removed from
 the cache. Thus, a pool that remains idle for long enough will
 not consume any resources. Note that pools with similar
 properties but different details (for example, timeout parameters)
 may be created using {@link java.util.concurrent.ThreadPoolExecutor} constructors.
@return {Object {java.util.concurrent.ExecutorService}} the newly created thread pool
*/
newCachedThreadPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newCachedThreadPool'>/**Creates a thread pool that creates new threads as needed, but
</span> will reuse previously constructed threads when they are
 available, and uses the provided
 ThreadFactory to create new threads when needed.
@param {Object {ThreadFactory}} threadFactory the factory to use when creating new threads
@return {Object {java.util.concurrent.ExecutorService}} the newly created thread pool
@throws NullPointerException if threadFactory is null
*/
newCachedThreadPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newSingleThreadScheduledExecutor'>/**Creates a single-threaded executor that can schedule commands
</span> to run after a given delay, or to execute periodically.
 (Note however that if this single
 thread terminates due to a failure during execution prior to
 shutdown, a new one will take its place if needed to execute
 subsequent tasks.)  Tasks are guaranteed to execute
 sequentially, and no more than one task will be active at any
 given time. Unlike the otherwise equivalent
 {@code newScheduledThreadPool(1)} the returned executor is
 guaranteed not to be reconfigurable to use additional threads.
@return {Object {java.util.concurrent.ScheduledExecutorService}} the newly created scheduled executor
*/
newSingleThreadScheduledExecutor : function(  ) {},

<span id='java-util-concurrent-Executors-method-newSingleThreadScheduledExecutor'>/**Creates a single-threaded executor that can schedule commands
</span> to run after a given delay, or to execute periodically.  (Note
 however that if this single thread terminates due to a failure
 during execution prior to shutdown, a new one will take its
 place if needed to execute subsequent tasks.)  Tasks are
 guaranteed to execute sequentially, and no more than one task
 will be active at any given time. Unlike the otherwise
 equivalent {@code newScheduledThreadPool(1, threadFactory)}
 the returned executor is guaranteed not to be reconfigurable to
 use additional threads.
@param {Object {ThreadFactory}} threadFactory the factory to use when creating new
 threads
@return {Object {java.util.concurrent.ScheduledExecutorService}} a newly created scheduled executor
@throws NullPointerException if threadFactory is null
*/
newSingleThreadScheduledExecutor : function(  ) {},

<span id='java-util-concurrent-Executors-method-newScheduledThreadPool'>/**Creates a thread pool that can schedule commands to run after a
</span> given delay, or to execute periodically.
@param {Number} corePoolSize the number of threads to keep in the pool,
 even if they are idle
@return {Object {java.util.concurrent.ScheduledExecutorService}} a newly created scheduled thread pool
@throws IllegalArgumentException if {@code corePoolSize &lt; 0}
*/
newScheduledThreadPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-newScheduledThreadPool'>/**Creates a thread pool that can schedule commands to run after a
</span> given delay, or to execute periodically.
@param {Number} corePoolSize the number of threads to keep in the pool,
 even if they are idle
@param {Object {ThreadFactory}} threadFactory the factory to use when the executor
 creates a new thread
@return {Object {java.util.concurrent.ScheduledExecutorService}} a newly created scheduled thread pool
@throws IllegalArgumentException if {@code corePoolSize &lt; 0}
@throws NullPointerException if threadFactory is null
*/
newScheduledThreadPool : function(  ) {},

<span id='java-util-concurrent-Executors-method-unconfigurableExecutorService'>/**Returns an object that delegates all defined {@link java.util.concurrent.ExecutorService} methods to the given executor, but not any
</span> other methods that might otherwise be accessible using
 casts. This provides a way to safely &quot;freeze&quot; configuration and
 disallow tuning of a given concrete implementation.
@param {Object {ExecutorService}} executor the underlying implementation
@return {Object {java.util.concurrent.ExecutorService}} an {@code ExecutorService} instance
@throws NullPointerException if executor null
*/
unconfigurableExecutorService : function(  ) {},

<span id='java-util-concurrent-Executors-method-unconfigurableScheduledExecutorService'>/**Returns an object that delegates all defined {@link java.util.concurrent.ScheduledExecutorService} methods to the given executor, but
</span> not any other methods that might otherwise be accessible using
 casts. This provides a way to safely &quot;freeze&quot; configuration and
 disallow tuning of a given concrete implementation.
@param {Object {ScheduledExecutorService}} executor the underlying implementation
@return {Object {java.util.concurrent.ScheduledExecutorService}} a {@code ScheduledExecutorService} instance
@throws NullPointerException if executor null
*/
unconfigurableScheduledExecutorService : function(  ) {},

<span id='java-util-concurrent-Executors-method-defaultThreadFactory'>/**Returns a default thread factory used to create new threads.
</span> This factory creates all new threads used by an Executor in the
 same {@link ThreadGroup}. Each new
 thread is created as a non-daemon thread with priority set to
 the smaller of {@code Thread.NORM_PRIORITY} and the maximum
 priority permitted in the thread group.  New threads have names
 accessible via {@link Thread#getName} of
 &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence
 number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number
 of the thread created by this factory.
@return {Object {java.util.concurrent.ThreadFactory}} a thread factory
*/
defaultThreadFactory : function(  ) {},

<span id='java-util-concurrent-Executors-method-privilegedThreadFactory'>/**Legacy security code; do not use.
</span>*/
privilegedThreadFactory : function(  ) {},

<span id='java-util-concurrent-Executors-method-callable'>/**Returns a {@link java.util.concurrent.Callable} object that, when
</span> called, runs the given task and returns the given result.  This
 can be useful when applying methods requiring a
 {@code Callable} to an otherwise resultless action.
@param {Object {Runnable}} task the task to run
@param {Object {Object}} result the result to return
@param &lt;T&gt; the type of the result
@return {Object {java.util.concurrent.Callable}} a callable object
@throws NullPointerException if task null
*/
callable : function(  ) {},

<span id='java-util-concurrent-Executors-method-callable'>/**Returns a {@link java.util.concurrent.Callable} object that, when
</span> called, runs the given task and returns {@code null}.
@param {Object {Runnable}} task the task to run
@return {Object {java.util.concurrent.Callable}} a callable object
@throws NullPointerException if task null
*/
callable : function(  ) {},

<span id='java-util-concurrent-Executors-method-callable'>/**Returns a {@link java.util.concurrent.Callable} object that, when
</span> called, runs the given privileged action and returns its result.
@param {Object {java.security.PrivilegedAction}} action the privileged action to run
@return {Object {java.util.concurrent.Callable}} a callable object
@throws NullPointerException if action null
*/
callable : function(  ) {},

<span id='java-util-concurrent-Executors-method-callable'>/**Returns a {@link java.util.concurrent.Callable} object that, when
</span> called, runs the given privileged exception action and returns
 its result.
@param {Object {java.security.PrivilegedExceptionAction}} action the privileged exception action to run
@return {Object {java.util.concurrent.Callable}} a callable object
@throws NullPointerException if action null
*/
callable : function(  ) {},

<span id='java-util-concurrent-Executors-method-privilegedCallable'>/**Legacy security code; do not use.
</span>*/
privilegedCallable : function(  ) {},

<span id='java-util-concurrent-Executors-method-privilegedCallableUsingCurrentClassLoader'>/**Legacy security code; do not use.
</span>*/
privilegedCallableUsingCurrentClassLoader : function(  ) {},


};</pre>
</body>
</html>
