<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-concurrent-LinkedBlockingDeque'>/**@class java.util.concurrent.LinkedBlockingDeque
</span> implements java.util.concurrent.BlockingDeque

 implements java.io.Serializable

@extends java.util.AbstractQueue

 An optionally-bounded {@linkplain java.util.concurrent.BlockingDeque blocking deque} based on
 linked nodes.

 &lt;p&gt;The optional capacity bound constructor argument serves as a
 way to prevent excessive expansion. The capacity, if unspecified,
 is equal to {@link Integer#MAX_VALUE}.  Linked nodes are
 dynamically created upon each insertion unless this would bring the
 deque above capacity.

 &lt;p&gt;Most operations run in constant time (ignoring time spent
 blocking).  Exceptions include {@link #remove(Object) remove},
 {@link #removeFirstOccurrence removeFirstOccurrence}, {@link #removeLastOccurrence removeLastOccurrence}, {@link #contains
 contains}, {@link #iterator iterator.remove()}, and the bulk
 operations, all of which run in linear time.

 &lt;p&gt;This class and its iterator implement all of the
 &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link Iterator} interfaces.

 @since 1.6
 @author  Doug Lea
 @param &lt;E&gt; the type of elements held in this deque
*/
var LinkedBlockingDeque = {

<span id='java-util-concurrent-LinkedBlockingDeque-method-addFirst'>/**
</span>@throws IllegalStateException if this deque is full
@throws NullPointerException {@inheritDoc}
*/
addFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-addLast'>/**
</span>@throws IllegalStateException if this deque is full
@throws NullPointerException  {@inheritDoc}
*/
addLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-offerFirst'>/**
</span>@throws NullPointerException {@inheritDoc}
*/
offerFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-offerLast'>/**
</span>@throws NullPointerException {@inheritDoc}
*/
offerLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-putFirst'>/**
</span>@throws NullPointerException {@inheritDoc}
@throws InterruptedException {@inheritDoc}
*/
putFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-putLast'>/**
</span>@throws NullPointerException {@inheritDoc}
@throws InterruptedException {@inheritDoc}
*/
putLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-offerFirst'>/**
</span>@throws NullPointerException {@inheritDoc}
@throws InterruptedException {@inheritDoc}
*/
offerFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-offerLast'>/**
</span>@throws NullPointerException {@inheritDoc}
@throws InterruptedException {@inheritDoc}
*/
offerLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-removeFirst'>/**
</span>@throws NoSuchElementException {@inheritDoc}
*/
removeFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-removeLast'>/**
</span>@throws NoSuchElementException {@inheritDoc}
*/
removeLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-pollFirst'>/**
</span>*/
pollFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-pollLast'>/**
</span>*/
pollLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-takeFirst'>/**
</span>*/
takeFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-takeLast'>/**
</span>*/
takeLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-pollFirst'>/**
</span>*/
pollFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-pollLast'>/**
</span>*/
pollLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-getFirst'>/**
</span>@throws NoSuchElementException {@inheritDoc}
*/
getFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-getLast'>/**
</span>@throws NoSuchElementException {@inheritDoc}
*/
getLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-peekFirst'>/**
</span>*/
peekFirst : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-peekLast'>/**
</span>*/
peekLast : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-removeFirstOccurrence'>/**
</span>*/
removeFirstOccurrence : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-removeLastOccurrence'>/**
</span>*/
removeLastOccurrence : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-add'>/**Inserts the specified element at the end of this deque unless it would
</span> violate capacity restrictions.  When using a capacity-restricted deque,
 it is generally preferable to use method {@link #offer(Object) offer}.

 &lt;p&gt;This method is equivalent to {@link #addLast}.
@throws IllegalStateException if this deque is full
@throws NullPointerException if the specified element is null
*/
add : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-offer'>/**
</span>@throws NullPointerException if the specified element is null
*/
offer : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-put'>/**
</span>@throws NullPointerException {@inheritDoc}
@throws InterruptedException {@inheritDoc}
*/
put : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-offer'>/**
</span>@throws NullPointerException {@inheritDoc}
@throws InterruptedException {@inheritDoc}
*/
offer : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-remove'>/**Retrieves and removes the head of the queue represented by this deque.
</span> This method differs from {@link #poll poll} only in that it throws an
 exception if this deque is empty.

 &lt;p&gt;This method is equivalent to {@link #removeFirst() removeFirst}.
@return {Object {java.lang.Object}} the head of the queue represented by this deque
@throws NoSuchElementException if this deque is empty
*/
remove : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-poll'>/**
</span>*/
poll : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-take'>/**
</span>*/
take : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-poll'>/**
</span>*/
poll : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-element'>/**Retrieves, but does not remove, the head of the queue represented by
</span> this deque.  This method differs from {@link #peek peek} only in that
 it throws an exception if this deque is empty.

 &lt;p&gt;This method is equivalent to {@link #getFirst() getFirst}.
@return {Object {java.lang.Object}} the head of the queue represented by this deque
@throws NoSuchElementException if this deque is empty
*/
element : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-peek'>/**
</span>*/
peek : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-remainingCapacity'>/**Returns the number of additional elements that this deque can ideally
</span> (in the absence of memory or resource constraints) accept without
 blocking. This is always equal to the initial capacity of this deque
 less the current {@code size} of this deque.

 &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert
 an element will succeed by inspecting {@code remainingCapacity}
 because it may be the case that another thread is about to
 insert or remove an element.
*/
remainingCapacity : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-drainTo'>/**
</span>@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException            {@inheritDoc}
@throws NullPointerException          {@inheritDoc}
@throws IllegalArgumentException      {@inheritDoc}
*/
drainTo : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-drainTo'>/**
</span>@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException            {@inheritDoc}
@throws NullPointerException          {@inheritDoc}
@throws IllegalArgumentException      {@inheritDoc}
*/
drainTo : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-push'>/**
</span>@throws IllegalStateException if this deque is full
@throws NullPointerException {@inheritDoc}
*/
push : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-pop'>/**
</span>@throws NoSuchElementException {@inheritDoc}
*/
pop : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-remove'>/**Removes the first occurrence of the specified element from this deque.
</span> If the deque does not contain the element, it is unchanged.
 More formally, removes the first element {@code e} such that
 {@code o.equals(e)} (if such an element exists).
 Returns {@code true} if this deque contained the specified element
 (or equivalently, if this deque changed as a result of the call).

 &lt;p&gt;This method is equivalent to
 {@link #removeFirstOccurrence(Object) removeFirstOccurrence}.
@param {Object {Object}} o element to be removed from this deque, if present
@return {Boolean} {@code true} if this deque changed as a result of the call
*/
remove : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-size'>/**Returns the number of elements in this deque.
</span>@return {Number} the number of elements in this deque
*/
size : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-contains'>/**Returns {@code true} if this deque contains the specified element.
</span> More formally, returns {@code true} if and only if this deque contains
 at least one element {@code e} such that {@code o.equals(e)}.
@param {Object {Object}} o object to be checked for containment in this deque
@return {Boolean} {@code true} if this deque contains the specified element
*/
contains : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-toArray'>/**Returns an array containing all of the elements in this deque, in
</span> proper sequence (from first to last element).

 &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 maintained by this deque.  (In other words, this method must allocate
 a new array).  The caller is thus free to modify the returned array.

 &lt;p&gt;This method acts as bridge between array-based and collection-based
 APIs.
@return {Object {java.lang.Object}} an array containing all of the elements in this deque
*/
toArray : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-toArray'>/**Returns an array containing all of the elements in this deque, in
</span> proper sequence; the runtime type of the returned array is that of
 the specified array.  If the deque fits in the specified array, it
 is returned therein.  Otherwise, a new array is allocated with the
 runtime type of the specified array and the size of this deque.

 &lt;p&gt;If this deque fits in the specified array with room to spare
 (i.e., the array has more elements than this deque), the element in
 the array immediately following the end of the deque is set to
 {@code null}.

 &lt;p&gt;Like the {@link #toArray}() method, this method acts as bridge between
 array-based and collection-based APIs.  Further, this method allows
 precise control over the runtime type of the output array, and may,
 under certain circumstances, be used to save allocation costs.

 &lt;p&gt;Suppose {@code x} is a deque known to contain only strings.
 The following code can be used to dump the deque into a newly
 allocated array of {@code String}:

 &lt;pre&gt; {@code String[] y = x.toArray(new String[0]);}&lt;/pre&gt;

 Note that {@code toArray(new Object[0])} is identical in function to
 {@code toArray()}.
@param {Object {java.lang.Object[]}} a the array into which the elements of the deque are to
          be stored, if it is big enough; otherwise, a new array of the
          same runtime type is allocated for this purpose
@return {Object {java.lang.Object}} an array containing all of the elements in this deque
@throws ArrayStoreException if the runtime type of the specified array
         is not a supertype of the runtime type of every element in
         this deque
@throws NullPointerException if the specified array is null
*/
toArray : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-toString'>/**
</span>*/
toString : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-clear'>/**Atomically removes all of the elements from this deque.
</span> The deque will be empty after this call returns.
*/
clear : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-iterator'>/**Returns an iterator over the elements in this deque in proper sequence.
</span> The elements will be returned in order from first (head) to last (tail).

 &lt;p&gt;The returned iterator is
 &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
@return {Object {java.util.Iterator}} an iterator over the elements in this deque in proper sequence
*/
iterator : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-descendingIterator'>/**Returns an iterator over the elements in this deque in reverse
</span> sequential order.  The elements will be returned in order from
 last (tail) to first (head).

 &lt;p&gt;The returned iterator is
 &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
@return {Object {java.util.Iterator}} an iterator over the elements in this deque in reverse order
*/
descendingIterator : function(  ) {},

<span id='java-util-concurrent-LinkedBlockingDeque-method-spliterator'>/**Returns a {@link Spliterator} over the elements in this deque.
</span>
 &lt;p&gt;The returned spliterator is
 &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.

 &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#CONCURRENT},
 {@link Spliterator#ORDERED}, and {@link Spliterator#NONNULL}.
@implNote The {@code Spliterator} implements {@code trySplit} to permit limited
 parallelism.
@return {Object {java.util.Spliterator}} a {@code Spliterator} over the elements in this deque
@since 1.8
*/
spliterator : function(  ) {},


};</pre>
</body>
</html>
