<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-concurrent-DelayQueue'>/**@class java.util.concurrent.DelayQueue
</span> implements java.util.concurrent.BlockingQueue

@extends java.util.AbstractQueue

 An unbounded {@linkplain java.util.concurrent.BlockingQueue blocking queue} of
 {@code Delayed} elements, in which an element can only be taken
 when its delay has expired.  The &lt;em&gt;head&lt;/em&gt; of the queue is that
 {@code Delayed} element whose delay expired furthest in the
 past.  If no delay has expired there is no head and {@code poll}
 will return {@code null}. Expiration occurs when an element's
 {@code getDelay(TimeUnit.NANOSECONDS)} method returns a value less
 than or equal to zero.  Even though unexpired elements cannot be
 removed using {@code take} or {@code poll}, they are otherwise
 treated as normal elements. For example, the {@code size} method
 returns the count of both expired and unexpired elements.
 This queue does not permit null elements.

 &lt;p&gt;This class and its iterator implement all of the
 &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link Iterator} interfaces.  The Iterator provided in method {@link #iterator}() is &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of
 the DelayQueue in any particular order.

 @since 1.5
 @author Doug Lea
 @param &lt;E&gt; the type of elements held in this queue
*/
var DelayQueue = {

<span id='java-util-concurrent-DelayQueue-method-add'>/**Inserts the specified element into this delay queue.
</span>@param {Object {Delayed}} e the element to add
@return {Boolean} {@code true} (as specified by {@link Collection#add})
@throws NullPointerException if the specified element is null
*/
add : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-offer'>/**Inserts the specified element into this delay queue.
</span>@param {Object {Delayed}} e the element to add
@return {Boolean} {@code true}
@throws NullPointerException if the specified element is null
*/
offer : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-put'>/**Inserts the specified element into this delay queue. As the queue is
</span> unbounded this method will never block.
@param {Object {Delayed}} e the element to add
@throws NullPointerException {@inheritDoc}
*/
put : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-offer'>/**Inserts the specified element into this delay queue. As the queue is
</span> unbounded this method will never block.
@param {Object {Delayed}} e the element to add
@param {Number} timeout This parameter is ignored as the method never blocks
@param {Object {TimeUnit}} unit This parameter is ignored as the method never blocks
@return {Boolean} {@code true}
@throws NullPointerException {@inheritDoc}
*/
offer : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-poll'>/**Retrieves and removes the head of this queue, or returns {@code null}
</span> if this queue has no elements with an expired delay.
@return {Object {java.util.concurrent.Delayed}} the head of this queue, or {@code null} if this
         queue has no elements with an expired delay
*/
poll : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-take'>/**Retrieves and removes the head of this queue, waiting if necessary
</span> until an element with an expired delay is available on this queue.
@return {Object {java.util.concurrent.Delayed}} the head of this queue
@throws InterruptedException {@inheritDoc}
*/
take : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-poll'>/**Retrieves and removes the head of this queue, waiting if necessary
</span> until an element with an expired delay is available on this queue,
 or the specified wait time expires.
@return {Object {java.util.concurrent.Delayed}} the head of this queue, or {@code null} if the
         specified waiting time elapses before an element with
         an expired delay becomes available
@throws InterruptedException {@inheritDoc}
*/
poll : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-peek'>/**Retrieves, but does not remove, the head of this queue, or
</span> returns {@code null} if this queue is empty.  Unlike
 {@code poll}, if no expired elements are available in the queue,
 this method returns the element that will expire next,
 if one exists.
@return {Object {java.util.concurrent.Delayed}} the head of this queue, or {@code null} if this
         queue is empty
*/
peek : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-size'>/**
</span>*/
size : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-drainTo'>/**
</span>@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException            {@inheritDoc}
@throws NullPointerException          {@inheritDoc}
@throws IllegalArgumentException      {@inheritDoc}
*/
drainTo : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-drainTo'>/**
</span>@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException            {@inheritDoc}
@throws NullPointerException          {@inheritDoc}
@throws IllegalArgumentException      {@inheritDoc}
*/
drainTo : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-clear'>/**Atomically removes all of the elements from this delay queue.
</span> The queue will be empty after this call returns.
 Elements with an unexpired delay are not waited for; they are
 simply discarded from the queue.
*/
clear : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-remainingCapacity'>/**Always returns {@code Integer.MAX_VALUE} because
</span> a {@code DelayQueue} is not capacity constrained.
@return {Number} {@code Integer.MAX_VALUE}
*/
remainingCapacity : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-toArray'>/**Returns an array containing all of the elements in this queue.
</span> The returned array elements are in no particular order.

 &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 maintained by this queue.  (In other words, this method must allocate
 a new array).  The caller is thus free to modify the returned array.

 &lt;p&gt;This method acts as bridge between array-based and collection-based
 APIs.
@return {Object {java.lang.Object}} an array containing all of the elements in this queue
*/
toArray : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-toArray'>/**Returns an array containing all of the elements in this queue; the
</span> runtime type of the returned array is that of the specified array.
 The returned array elements are in no particular order.
 If the queue fits in the specified array, it is returned therein.
 Otherwise, a new array is allocated with the runtime type of the
 specified array and the size of this queue.

 &lt;p&gt;If this queue fits in the specified array with room to spare
 (i.e., the array has more elements than this queue), the element in
 the array immediately following the end of the queue is set to
 {@code null}.

 &lt;p&gt;Like the {@link #toArray}() method, this method acts as bridge between
 array-based and collection-based APIs.  Further, this method allows
 precise control over the runtime type of the output array, and may,
 under certain circumstances, be used to save allocation costs.

 &lt;p&gt;The following code can be used to dump a delay queue into a newly
 allocated array of {@code Delayed}:

 &lt;pre&gt; {@code Delayed[] a = q.toArray(new Delayed[0]);}&lt;/pre&gt;

 Note that {@code toArray(new Object[0])} is identical in function to
 {@code toArray()}.
@param {Object {java.lang.Object[]}} a the array into which the elements of the queue are to
          be stored, if it is big enough; otherwise, a new array of the
          same runtime type is allocated for this purpose
@return {Object {java.lang.Object}} an array containing all of the elements in this queue
@throws ArrayStoreException if the runtime type of the specified array
         is not a supertype of the runtime type of every element in
         this queue
@throws NullPointerException if the specified array is null
*/
toArray : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-remove'>/**Removes a single instance of the specified element from this
</span> queue, if it is present, whether or not it has expired.
*/
remove : function(  ) {},

<span id='java-util-concurrent-DelayQueue-method-iterator'>/**Returns an iterator over all the elements (both expired and
</span> unexpired) in this queue. The iterator does not return the
 elements in any particular order.

 &lt;p&gt;The returned iterator is
 &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
@return {Object {java.util.Iterator}} an iterator over the elements in this queue
*/
iterator : function(  ) {},


};</pre>
</body>
</html>
