<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-concurrent-ExecutorCompletionService'>/**@class java.util.concurrent.ExecutorCompletionService
</span> implements java.util.concurrent.CompletionService

@extends java.lang.Object

 A {@link java.util.concurrent.CompletionService} that uses a supplied {@link java.util.concurrent.Executor}
 to execute tasks.  This class arranges that submitted tasks are,
 upon completion, placed on a queue accessible using {@code take}.
 The class is lightweight enough to be suitable for transient use
 when processing groups of tasks.

 &lt;p&gt;

 &lt;b&gt;Usage Examples.&lt;/b&gt;

 Suppose you have a set of solvers for a certain problem, each
 returning a value of some type {@code Result}, and would like to
 run them concurrently, processing the results of each of them that
 return a non-null value, in some method {@code use(Result r)}. You
 could write this as:

 &lt;pre&gt; {@code
 void solve(Executor e,
            Collection&lt;Callable&lt;Result&gt;&gt; solvers)
     throws InterruptedException, ExecutionException {
   CompletionService&lt;Result&gt; ecs
       = new ExecutorCompletionService&lt;Result&gt;(e);
   for (Callable&lt;Result&gt; s : solvers)
     ecs.submit(s);
   int n = solvers.size();
   for (int i = 0; i &lt; n; ++i) {
     Result r = ecs.take().get();
     if (r != null)
       use(r);
   }
 }}&lt;/pre&gt;

 Suppose instead that you would like to use the first non-null result
 of the set of tasks, ignoring any that encounter exceptions,
 and cancelling all other tasks when the first one is ready:

 &lt;pre&gt; {@code
 void solve(Executor e,
            Collection&lt;Callable&lt;Result&gt;&gt; solvers)
     throws InterruptedException {
   CompletionService&lt;Result&gt; ecs
       = new ExecutorCompletionService&lt;Result&gt;(e);
   int n = solvers.size();
   List&lt;Future&lt;Result&gt;&gt; futures = new ArrayList&lt;&gt;(n);
   Result result = null;
   try {
     for (Callable&lt;Result&gt; s : solvers)
       futures.add(ecs.submit(s));
     for (int i = 0; i &lt; n; ++i) {
       try {
         Result r = ecs.take().get();
         if (r != null) {
           result = r;
           break;
         }
       } catch (ExecutionException ignore) {}
     }
   }
   finally {
     for (Future&lt;Result&gt; f : futures)
       f.cancel(true);
   }

   if (result != null)
     use(result);
 }}&lt;/pre&gt;
*/
var ExecutorCompletionService = {

<span id='java-util-concurrent-ExecutorCompletionService-method-submit'>/**
</span>*/
submit : function(  ) {},

<span id='java-util-concurrent-ExecutorCompletionService-method-submit'>/**
</span>*/
submit : function(  ) {},

<span id='java-util-concurrent-ExecutorCompletionService-method-take'>/**
</span>*/
take : function(  ) {},

<span id='java-util-concurrent-ExecutorCompletionService-method-poll'>/**
</span>*/
poll : function(  ) {},

<span id='java-util-concurrent-ExecutorCompletionService-method-poll'>/**
</span>*/
poll : function(  ) {},


};</pre>
</body>
</html>
