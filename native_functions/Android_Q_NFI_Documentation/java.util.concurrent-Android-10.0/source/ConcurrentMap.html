<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-util-concurrent-ConcurrentMap'>/**@class java.util.concurrent.ConcurrentMap
</span> implements java.util.Map

 A {@link java.util.Map} providing thread safety and atomicity
 guarantees.

 &lt;p&gt;To maintain the specified guarantees, default implementations of
 methods including {@link #putIfAbsent} inherited from {@link Map}
 must be overridden by implementations of this interface. Similarly,
 implementations of the collections returned by methods {@link #keySet}, {@link #values}, and {@link #entrySet} must override
 methods such as {@code removeIf} when necessary to
 preserve atomicity guarantees.

 &lt;p&gt;Memory consistency effects: As with other concurrent
 collections, actions in a thread prior to placing an object into a
 {@code ConcurrentMap} as a key or value
 &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
 actions subsequent to the access or removal of that object from
 the {@code ConcurrentMap} in another thread.

 @since 1.5
 @author Doug Lea
 @param &lt;K&gt; the type of keys maintained by this map
 @param &lt;V&gt; the type of mapped values
*/
var ConcurrentMap = {

<span id='java-util-concurrent-ConcurrentMap-method-getOrDefault'>/**{@inheritDoc}
</span>@implNote This implementation assumes that the ConcurrentMap cannot
 contain null values and {@code get()} returning null unambiguously means
 the key is absent. Implementations which support null values
 &lt;strong&gt;must&lt;/strong&gt; override this default implementation.
@throws ClassCastException {@inheritDoc}
@throws NullPointerException {@inheritDoc}
@since 1.8
*/
getOrDefault : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-forEach'>/**{@inheritDoc}
</span>@implSpec The default implementation is equivalent to, for this
 {@code map}:
 &lt;pre&gt; {@code
 for (Map.Entry&lt;K,V&gt; entry : map.entrySet()) {
   action.accept(entry.getKey(), entry.getValue());
 }}&lt;/pre&gt;
@implNote The default implementation assumes that
 {@code IllegalStateException} thrown by {@code getKey()} or
 {@code getValue()} indicates that the entry has been removed and cannot
 be processed. Operation continues for subsequent entries.
@throws NullPointerException {@inheritDoc}
@since 1.8
*/
forEach : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-putIfAbsent'>/**If the specified key is not already associated
</span> with a value, associates it with the given value.
 This is equivalent to, for this {@code map}:
 &lt;pre&gt; {@code
 if (!map.containsKey(key))
   return map.put(key, value);
 else
   return map.get(key);}&lt;/pre&gt;

 except that the action is performed atomically.
@param {Object {Object}} key key with which the specified value is to be associated
@param {Object {Object}} value value to be associated with the specified key
@param value value to be associated with the specified key
@return {Object {java.lang.Object}} the previous value associated with the specified key, or
         {@code null} if there was no mapping for the key.
         (A {@code null} return can also indicate that the map
         previously associated {@code null} with the key,
         if the implementation supports null values.)
@throws UnsupportedOperationException if the {@code put} operation
         is not supported by this map
@throws ClassCastException if the class of the specified key or value
         prevents it from being stored in this map
@throws NullPointerException if the specified key or value is null,
         and this map does not permit null keys or values
@throws IllegalArgumentException if some property of the specified key
         or value prevents it from being stored in this map
*/
putIfAbsent : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-remove'>/**Removes the entry for a key only if currently mapped to a given value.
</span> This is equivalent to, for this {@code map}:
 &lt;pre&gt; {@code
 if (map.containsKey(key)
     &amp;&amp; Objects.equals(map.get(key), value)) {
   map.remove(key);
   return true;
 } else {
   return false;
 }}&lt;/pre&gt;

 except that the action is performed atomically.
@param {Object {Object}} key key with which the specified value is associated
@param {Object {Object}} value value expected to be associated with the specified key
@param value value expected to be associated with the specified key
@return {Boolean} {@code true} if the value was removed
@throws UnsupportedOperationException if the {@code remove} operation
         is not supported by this map
@throws ClassCastException if the key or value is of an inappropriate
         type for this map
 (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
@throws NullPointerException if the specified key or value is null,
         and this map does not permit null keys or values
 (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
*/
remove : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-replace'>/**Replaces the entry for a key only if currently mapped to a given value.
</span> This is equivalent to, for this {@code map}:
 &lt;pre&gt; {@code
 if (map.containsKey(key)
     &amp;&amp; Objects.equals(map.get(key), oldValue)) {
   map.put(key, newValue);
   return true;
 } else {
   return false;
 }}&lt;/pre&gt;

 except that the action is performed atomically.
@param {Object {Object}} key key with which the specified value is associated
@param {Object {Object}} oldValue value expected to be associated with the specified key
@param {Object {Object}} newValue value to be associated with the specified key
@param newValue value to be associated with the specified key
@return {Boolean} {@code true} if the value was replaced
@throws UnsupportedOperationException if the {@code put} operation
         is not supported by this map
@throws ClassCastException if the class of a specified key or value
         prevents it from being stored in this map
@throws NullPointerException if a specified key or value is null,
         and this map does not permit null keys or values
@throws IllegalArgumentException if some property of a specified key
         or value prevents it from being stored in this map
*/
replace : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-replace'>/**Replaces the entry for a key only if currently mapped to some value.
</span> This is equivalent to, for this {@code map}:
 &lt;pre&gt; {@code
 if (map.containsKey(key))
   return map.put(key, value);
 else
   return null;}&lt;/pre&gt;

 except that the action is performed atomically.
@param {Object {Object}} key key with which the specified value is associated
@param {Object {Object}} value value to be associated with the specified key
@param value value to be associated with the specified key
@return {Object {java.lang.Object}} the previous value associated with the specified key, or
         {@code null} if there was no mapping for the key.
         (A {@code null} return can also indicate that the map
         previously associated {@code null} with the key,
         if the implementation supports null values.)
@throws UnsupportedOperationException if the {@code put} operation
         is not supported by this map
@throws ClassCastException if the class of the specified key or value
         prevents it from being stored in this map
@throws NullPointerException if the specified key or value is null,
         and this map does not permit null keys or values
@throws IllegalArgumentException if some property of the specified key
         or value prevents it from being stored in this map
*/
replace : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-replaceAll'>/**{@inheritDoc}
</span>@implSpec &lt;p&gt;The default implementation is equivalent to, for this {@code map}:
 &lt;pre&gt; {@code
 for (Map.Entry&lt;K,V&gt; entry : map.entrySet()) {
   K k;
   V v;
   do {
     k = entry.getKey();
     v = entry.getValue();
   } while (!map.replace(k, v, function.apply(k, v)));
 }}&lt;/pre&gt;

 The default implementation may retry these steps when multiple
 threads attempt updates including potentially calling the function
 repeatedly for a given key.

 &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
 values and {@code get()} returning null unambiguously means the key is
 absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
 override this default implementation.
@throws UnsupportedOperationException {@inheritDoc}
@throws NullPointerException {@inheritDoc}
@throws ClassCastException {@inheritDoc}
@throws IllegalArgumentException {@inheritDoc}
@since 1.8
*/
replaceAll : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-computeIfAbsent'>/**{@inheritDoc}
</span>@implSpec The default implementation is equivalent to the following steps for this
 {@code map}:

 &lt;pre&gt; {@code
 V oldValue, newValue;
 return ((oldValue = map.get(key)) == null
         &amp;&amp; (newValue = mappingFunction.apply(key)) != null
         &amp;&amp; (oldValue = map.putIfAbsent(key, newValue)) == null)
   ? newValue
   : oldValue;}&lt;/pre&gt;

 &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
 values and {@code get()} returning null unambiguously means the key is
 absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
 override this default implementation.
@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException {@inheritDoc}
@throws NullPointerException {@inheritDoc}
@throws IllegalArgumentException {@inheritDoc}
@since 1.8
*/
computeIfAbsent : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-computeIfPresent'>/**{@inheritDoc}
</span>@implSpec The default implementation is equivalent to performing the following
 steps for this {@code map}:

 &lt;pre&gt; {@code
 for (V oldValue; (oldValue = map.get(key)) != null; ) {
   V newValue = remappingFunction.apply(key, oldValue);
   if ((newValue == null)
       ? map.remove(key, oldValue)
       : map.replace(key, oldValue, newValue))
     return newValue;
 }
 return null;}&lt;/pre&gt;
 When multiple threads attempt updates, map operations and the
 remapping function may be called multiple times.

 &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
 values and {@code get()} returning null unambiguously means the key is
 absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
 override this default implementation.
@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException {@inheritDoc}
@throws NullPointerException {@inheritDoc}
@throws IllegalArgumentException {@inheritDoc}
@since 1.8
*/
computeIfPresent : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-compute'>/**{@inheritDoc}
</span>@implSpec The default implementation is equivalent to performing the following
 steps for this {@code map}:

 &lt;pre&gt; {@code
 for (;;) {
   V oldValue = map.get(key);
   V newValue = remappingFunction.apply(key, oldValue);
   if (newValue != null) {
     if ((oldValue != null)
       ? map.replace(key, oldValue, newValue)
       : map.putIfAbsent(key, newValue) == null)
       return newValue;
   } else if (oldValue == null || map.remove(key, oldValue)) {
     return null;
   }
 }}&lt;/pre&gt;
 When multiple threads attempt updates, map operations and the
 remapping function may be called multiple times.

 &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
 values and {@code get()} returning null unambiguously means the key is
 absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
 override this default implementation.
@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException {@inheritDoc}
@throws NullPointerException {@inheritDoc}
@throws IllegalArgumentException {@inheritDoc}
@since 1.8
*/
compute : function(  ) {},

<span id='java-util-concurrent-ConcurrentMap-method-merge'>/**{@inheritDoc}
</span>@implSpec The default implementation is equivalent to performing the following
 steps for this {@code map}:

 &lt;pre&gt; {@code
 for (;;) {
   V oldValue = map.get(key);
   if (oldValue != null) {
     V newValue = remappingFunction.apply(oldValue, value);
     if (newValue != null) {
       if (map.replace(key, oldValue, newValue))
         return newValue;
     } else if (map.remove(key, oldValue)) {
       return null;
     }
   } else if (map.putIfAbsent(key, value) == null) {
     return value;
   }
 }}&lt;/pre&gt;
 When multiple threads attempt updates, map operations and the
 remapping function may be called multiple times.

 &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
 values and {@code get()} returning null unambiguously means the key is
 absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
 override this default implementation.
@throws UnsupportedOperationException {@inheritDoc}
@throws ClassCastException {@inheritDoc}
@throws NullPointerException {@inheritDoc}
@throws IllegalArgumentException {@inheritDoc}
@since 1.8
*/
merge : function(  ) {},


};</pre>
</body>
</html>
